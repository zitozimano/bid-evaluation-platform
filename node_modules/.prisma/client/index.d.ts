
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model TenantBranding
 * 
 */
export type TenantBranding = $Result.DefaultSelection<Prisma.$TenantBrandingPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ScmTenderAssignment
 * 
 */
export type ScmTenderAssignment = $Result.DefaultSelection<Prisma.$ScmTenderAssignmentPayload>
/**
 * Model Tender
 * 
 */
export type Tender = $Result.DefaultSelection<Prisma.$TenderPayload>
/**
 * Model Bidder
 * 
 */
export type Bidder = $Result.DefaultSelection<Prisma.$BidderPayload>
/**
 * Model Bbbee
 * 
 */
export type Bbbee = $Result.DefaultSelection<Prisma.$BbbeePayload>
/**
 * Model Evidence
 * 
 */
export type Evidence = $Result.DefaultSelection<Prisma.$EvidencePayload>
/**
 * Model EvaluationConfig
 * 
 */
export type EvaluationConfig = $Result.DefaultSelection<Prisma.$EvaluationConfigPayload>
/**
 * Model BidderCriterionScore
 * 
 */
export type BidderCriterionScore = $Result.DefaultSelection<Prisma.$BidderCriterionScorePayload>
/**
 * Model EvaluationResult
 * 
 */
export type EvaluationResult = $Result.DefaultSelection<Prisma.$EvaluationResultPayload>
/**
 * Model WorkflowLog
 * 
 */
export type WorkflowLog = $Result.DefaultSelection<Prisma.$WorkflowLogPayload>
/**
 * Model Circular
 * 
 */
export type Circular = $Result.DefaultSelection<Prisma.$CircularPayload>
/**
 * Model ComplianceRule
 * 
 */
export type ComplianceRule = $Result.DefaultSelection<Prisma.$ComplianceRulePayload>
/**
 * Model ComplianceItem
 * 
 */
export type ComplianceItem = $Result.DefaultSelection<Prisma.$ComplianceItemPayload>
/**
 * Model EvaluationException
 * 
 */
export type EvaluationException = $Result.DefaultSelection<Prisma.$EvaluationExceptionPayload>
/**
 * Model EvaluationSignature
 * 
 */
export type EvaluationSignature = $Result.DefaultSelection<Prisma.$EvaluationSignaturePayload>
/**
 * Model EvaluationDocument
 * 
 */
export type EvaluationDocument = $Result.DefaultSelection<Prisma.$EvaluationDocumentPayload>
/**
 * Model AnalyticsAccessLog
 * 
 */
export type AnalyticsAccessLog = $Result.DefaultSelection<Prisma.$AnalyticsAccessLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationRule
 * 
 */
export type NotificationRule = $Result.DefaultSelection<Prisma.$NotificationRulePayload>
/**
 * Model TenderTimelineEvent
 * 
 */
export type TenderTimelineEvent = $Result.DefaultSelection<Prisma.$TenderTimelineEventPayload>
/**
 * Model TenderInsights
 * 
 */
export type TenderInsights = $Result.DefaultSelection<Prisma.$TenderInsightsPayload>
/**
 * Model TenderHeatmap
 * 
 */
export type TenderHeatmap = $Result.DefaultSelection<Prisma.$TenderHeatmapPayload>
/**
 * Model BidderIntelligence
 * 
 */
export type BidderIntelligence = $Result.DefaultSelection<Prisma.$BidderIntelligencePayload>
/**
 * Model BidderRiskProfile
 * 
 */
export type BidderRiskProfile = $Result.DefaultSelection<Prisma.$BidderRiskProfilePayload>
/**
 * Model TenderComplianceDashboard
 * 
 */
export type TenderComplianceDashboard = $Result.DefaultSelection<Prisma.$TenderComplianceDashboardPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.tenantBranding`: Exposes CRUD operations for the **TenantBranding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantBrandings
    * const tenantBrandings = await prisma.tenantBranding.findMany()
    * ```
    */
  get tenantBranding(): Prisma.TenantBrandingDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.scmTenderAssignment`: Exposes CRUD operations for the **ScmTenderAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScmTenderAssignments
    * const scmTenderAssignments = await prisma.scmTenderAssignment.findMany()
    * ```
    */
  get scmTenderAssignment(): Prisma.ScmTenderAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.tender`: Exposes CRUD operations for the **Tender** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenders
    * const tenders = await prisma.tender.findMany()
    * ```
    */
  get tender(): Prisma.TenderDelegate<ExtArgs>;

  /**
   * `prisma.bidder`: Exposes CRUD operations for the **Bidder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bidders
    * const bidders = await prisma.bidder.findMany()
    * ```
    */
  get bidder(): Prisma.BidderDelegate<ExtArgs>;

  /**
   * `prisma.bbbee`: Exposes CRUD operations for the **Bbbee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bbbees
    * const bbbees = await prisma.bbbee.findMany()
    * ```
    */
  get bbbee(): Prisma.BbbeeDelegate<ExtArgs>;

  /**
   * `prisma.evidence`: Exposes CRUD operations for the **Evidence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evidences
    * const evidences = await prisma.evidence.findMany()
    * ```
    */
  get evidence(): Prisma.EvidenceDelegate<ExtArgs>;

  /**
   * `prisma.evaluationConfig`: Exposes CRUD operations for the **EvaluationConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluationConfigs
    * const evaluationConfigs = await prisma.evaluationConfig.findMany()
    * ```
    */
  get evaluationConfig(): Prisma.EvaluationConfigDelegate<ExtArgs>;

  /**
   * `prisma.bidderCriterionScore`: Exposes CRUD operations for the **BidderCriterionScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BidderCriterionScores
    * const bidderCriterionScores = await prisma.bidderCriterionScore.findMany()
    * ```
    */
  get bidderCriterionScore(): Prisma.BidderCriterionScoreDelegate<ExtArgs>;

  /**
   * `prisma.evaluationResult`: Exposes CRUD operations for the **EvaluationResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluationResults
    * const evaluationResults = await prisma.evaluationResult.findMany()
    * ```
    */
  get evaluationResult(): Prisma.EvaluationResultDelegate<ExtArgs>;

  /**
   * `prisma.workflowLog`: Exposes CRUD operations for the **WorkflowLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowLogs
    * const workflowLogs = await prisma.workflowLog.findMany()
    * ```
    */
  get workflowLog(): Prisma.WorkflowLogDelegate<ExtArgs>;

  /**
   * `prisma.circular`: Exposes CRUD operations for the **Circular** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Circulars
    * const circulars = await prisma.circular.findMany()
    * ```
    */
  get circular(): Prisma.CircularDelegate<ExtArgs>;

  /**
   * `prisma.complianceRule`: Exposes CRUD operations for the **ComplianceRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplianceRules
    * const complianceRules = await prisma.complianceRule.findMany()
    * ```
    */
  get complianceRule(): Prisma.ComplianceRuleDelegate<ExtArgs>;

  /**
   * `prisma.complianceItem`: Exposes CRUD operations for the **ComplianceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplianceItems
    * const complianceItems = await prisma.complianceItem.findMany()
    * ```
    */
  get complianceItem(): Prisma.ComplianceItemDelegate<ExtArgs>;

  /**
   * `prisma.evaluationException`: Exposes CRUD operations for the **EvaluationException** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluationExceptions
    * const evaluationExceptions = await prisma.evaluationException.findMany()
    * ```
    */
  get evaluationException(): Prisma.EvaluationExceptionDelegate<ExtArgs>;

  /**
   * `prisma.evaluationSignature`: Exposes CRUD operations for the **EvaluationSignature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluationSignatures
    * const evaluationSignatures = await prisma.evaluationSignature.findMany()
    * ```
    */
  get evaluationSignature(): Prisma.EvaluationSignatureDelegate<ExtArgs>;

  /**
   * `prisma.evaluationDocument`: Exposes CRUD operations for the **EvaluationDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluationDocuments
    * const evaluationDocuments = await prisma.evaluationDocument.findMany()
    * ```
    */
  get evaluationDocument(): Prisma.EvaluationDocumentDelegate<ExtArgs>;

  /**
   * `prisma.analyticsAccessLog`: Exposes CRUD operations for the **AnalyticsAccessLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsAccessLogs
    * const analyticsAccessLogs = await prisma.analyticsAccessLog.findMany()
    * ```
    */
  get analyticsAccessLog(): Prisma.AnalyticsAccessLogDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.notificationRule`: Exposes CRUD operations for the **NotificationRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationRules
    * const notificationRules = await prisma.notificationRule.findMany()
    * ```
    */
  get notificationRule(): Prisma.NotificationRuleDelegate<ExtArgs>;

  /**
   * `prisma.tenderTimelineEvent`: Exposes CRUD operations for the **TenderTimelineEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenderTimelineEvents
    * const tenderTimelineEvents = await prisma.tenderTimelineEvent.findMany()
    * ```
    */
  get tenderTimelineEvent(): Prisma.TenderTimelineEventDelegate<ExtArgs>;

  /**
   * `prisma.tenderInsights`: Exposes CRUD operations for the **TenderInsights** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenderInsights
    * const tenderInsights = await prisma.tenderInsights.findMany()
    * ```
    */
  get tenderInsights(): Prisma.TenderInsightsDelegate<ExtArgs>;

  /**
   * `prisma.tenderHeatmap`: Exposes CRUD operations for the **TenderHeatmap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenderHeatmaps
    * const tenderHeatmaps = await prisma.tenderHeatmap.findMany()
    * ```
    */
  get tenderHeatmap(): Prisma.TenderHeatmapDelegate<ExtArgs>;

  /**
   * `prisma.bidderIntelligence`: Exposes CRUD operations for the **BidderIntelligence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BidderIntelligences
    * const bidderIntelligences = await prisma.bidderIntelligence.findMany()
    * ```
    */
  get bidderIntelligence(): Prisma.BidderIntelligenceDelegate<ExtArgs>;

  /**
   * `prisma.bidderRiskProfile`: Exposes CRUD operations for the **BidderRiskProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BidderRiskProfiles
    * const bidderRiskProfiles = await prisma.bidderRiskProfile.findMany()
    * ```
    */
  get bidderRiskProfile(): Prisma.BidderRiskProfileDelegate<ExtArgs>;

  /**
   * `prisma.tenderComplianceDashboard`: Exposes CRUD operations for the **TenderComplianceDashboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenderComplianceDashboards
    * const tenderComplianceDashboards = await prisma.tenderComplianceDashboard.findMany()
    * ```
    */
  get tenderComplianceDashboard(): Prisma.TenderComplianceDashboardDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    TenantBranding: 'TenantBranding',
    User: 'User',
    ScmTenderAssignment: 'ScmTenderAssignment',
    Tender: 'Tender',
    Bidder: 'Bidder',
    Bbbee: 'Bbbee',
    Evidence: 'Evidence',
    EvaluationConfig: 'EvaluationConfig',
    BidderCriterionScore: 'BidderCriterionScore',
    EvaluationResult: 'EvaluationResult',
    WorkflowLog: 'WorkflowLog',
    Circular: 'Circular',
    ComplianceRule: 'ComplianceRule',
    ComplianceItem: 'ComplianceItem',
    EvaluationException: 'EvaluationException',
    EvaluationSignature: 'EvaluationSignature',
    EvaluationDocument: 'EvaluationDocument',
    AnalyticsAccessLog: 'AnalyticsAccessLog',
    Notification: 'Notification',
    NotificationRule: 'NotificationRule',
    TenderTimelineEvent: 'TenderTimelineEvent',
    TenderInsights: 'TenderInsights',
    TenderHeatmap: 'TenderHeatmap',
    BidderIntelligence: 'BidderIntelligence',
    BidderRiskProfile: 'BidderRiskProfile',
    TenderComplianceDashboard: 'TenderComplianceDashboard'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "tenantBranding" | "user" | "scmTenderAssignment" | "tender" | "bidder" | "bbbee" | "evidence" | "evaluationConfig" | "bidderCriterionScore" | "evaluationResult" | "workflowLog" | "circular" | "complianceRule" | "complianceItem" | "evaluationException" | "evaluationSignature" | "evaluationDocument" | "analyticsAccessLog" | "notification" | "notificationRule" | "tenderTimelineEvent" | "tenderInsights" | "tenderHeatmap" | "bidderIntelligence" | "bidderRiskProfile" | "tenderComplianceDashboard"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      TenantBranding: {
        payload: Prisma.$TenantBrandingPayload<ExtArgs>
        fields: Prisma.TenantBrandingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantBrandingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBrandingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantBrandingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBrandingPayload>
          }
          findFirst: {
            args: Prisma.TenantBrandingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBrandingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantBrandingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBrandingPayload>
          }
          findMany: {
            args: Prisma.TenantBrandingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBrandingPayload>[]
          }
          create: {
            args: Prisma.TenantBrandingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBrandingPayload>
          }
          createMany: {
            args: Prisma.TenantBrandingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantBrandingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBrandingPayload>[]
          }
          delete: {
            args: Prisma.TenantBrandingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBrandingPayload>
          }
          update: {
            args: Prisma.TenantBrandingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBrandingPayload>
          }
          deleteMany: {
            args: Prisma.TenantBrandingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantBrandingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantBrandingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBrandingPayload>
          }
          aggregate: {
            args: Prisma.TenantBrandingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantBranding>
          }
          groupBy: {
            args: Prisma.TenantBrandingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantBrandingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantBrandingCountArgs<ExtArgs>
            result: $Utils.Optional<TenantBrandingCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ScmTenderAssignment: {
        payload: Prisma.$ScmTenderAssignmentPayload<ExtArgs>
        fields: Prisma.ScmTenderAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScmTenderAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScmTenderAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScmTenderAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScmTenderAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ScmTenderAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScmTenderAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScmTenderAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScmTenderAssignmentPayload>
          }
          findMany: {
            args: Prisma.ScmTenderAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScmTenderAssignmentPayload>[]
          }
          create: {
            args: Prisma.ScmTenderAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScmTenderAssignmentPayload>
          }
          createMany: {
            args: Prisma.ScmTenderAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScmTenderAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScmTenderAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ScmTenderAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScmTenderAssignmentPayload>
          }
          update: {
            args: Prisma.ScmTenderAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScmTenderAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ScmTenderAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScmTenderAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScmTenderAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScmTenderAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ScmTenderAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScmTenderAssignment>
          }
          groupBy: {
            args: Prisma.ScmTenderAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScmTenderAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScmTenderAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ScmTenderAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Tender: {
        payload: Prisma.$TenderPayload<ExtArgs>
        fields: Prisma.TenderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderPayload>
          }
          findFirst: {
            args: Prisma.TenderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderPayload>
          }
          findMany: {
            args: Prisma.TenderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderPayload>[]
          }
          create: {
            args: Prisma.TenderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderPayload>
          }
          createMany: {
            args: Prisma.TenderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderPayload>[]
          }
          delete: {
            args: Prisma.TenderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderPayload>
          }
          update: {
            args: Prisma.TenderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderPayload>
          }
          deleteMany: {
            args: Prisma.TenderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderPayload>
          }
          aggregate: {
            args: Prisma.TenderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTender>
          }
          groupBy: {
            args: Prisma.TenderGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenderGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenderCountArgs<ExtArgs>
            result: $Utils.Optional<TenderCountAggregateOutputType> | number
          }
        }
      }
      Bidder: {
        payload: Prisma.$BidderPayload<ExtArgs>
        fields: Prisma.BidderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BidderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BidderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderPayload>
          }
          findFirst: {
            args: Prisma.BidderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BidderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderPayload>
          }
          findMany: {
            args: Prisma.BidderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderPayload>[]
          }
          create: {
            args: Prisma.BidderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderPayload>
          }
          createMany: {
            args: Prisma.BidderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BidderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderPayload>[]
          }
          delete: {
            args: Prisma.BidderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderPayload>
          }
          update: {
            args: Prisma.BidderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderPayload>
          }
          deleteMany: {
            args: Prisma.BidderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BidderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BidderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderPayload>
          }
          aggregate: {
            args: Prisma.BidderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBidder>
          }
          groupBy: {
            args: Prisma.BidderGroupByArgs<ExtArgs>
            result: $Utils.Optional<BidderGroupByOutputType>[]
          }
          count: {
            args: Prisma.BidderCountArgs<ExtArgs>
            result: $Utils.Optional<BidderCountAggregateOutputType> | number
          }
        }
      }
      Bbbee: {
        payload: Prisma.$BbbeePayload<ExtArgs>
        fields: Prisma.BbbeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BbbeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BbbeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BbbeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BbbeePayload>
          }
          findFirst: {
            args: Prisma.BbbeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BbbeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BbbeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BbbeePayload>
          }
          findMany: {
            args: Prisma.BbbeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BbbeePayload>[]
          }
          create: {
            args: Prisma.BbbeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BbbeePayload>
          }
          createMany: {
            args: Prisma.BbbeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BbbeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BbbeePayload>[]
          }
          delete: {
            args: Prisma.BbbeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BbbeePayload>
          }
          update: {
            args: Prisma.BbbeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BbbeePayload>
          }
          deleteMany: {
            args: Prisma.BbbeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BbbeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BbbeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BbbeePayload>
          }
          aggregate: {
            args: Prisma.BbbeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBbbee>
          }
          groupBy: {
            args: Prisma.BbbeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BbbeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BbbeeCountArgs<ExtArgs>
            result: $Utils.Optional<BbbeeCountAggregateOutputType> | number
          }
        }
      }
      Evidence: {
        payload: Prisma.$EvidencePayload<ExtArgs>
        fields: Prisma.EvidenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvidenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvidenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          findFirst: {
            args: Prisma.EvidenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvidenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          findMany: {
            args: Prisma.EvidenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[]
          }
          create: {
            args: Prisma.EvidenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          createMany: {
            args: Prisma.EvidenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvidenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[]
          }
          delete: {
            args: Prisma.EvidenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          update: {
            args: Prisma.EvidenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          deleteMany: {
            args: Prisma.EvidenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvidenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvidenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          aggregate: {
            args: Prisma.EvidenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvidence>
          }
          groupBy: {
            args: Prisma.EvidenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvidenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvidenceCountArgs<ExtArgs>
            result: $Utils.Optional<EvidenceCountAggregateOutputType> | number
          }
        }
      }
      EvaluationConfig: {
        payload: Prisma.$EvaluationConfigPayload<ExtArgs>
        fields: Prisma.EvaluationConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationConfigPayload>
          }
          findFirst: {
            args: Prisma.EvaluationConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationConfigPayload>
          }
          findMany: {
            args: Prisma.EvaluationConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationConfigPayload>[]
          }
          create: {
            args: Prisma.EvaluationConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationConfigPayload>
          }
          createMany: {
            args: Prisma.EvaluationConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationConfigPayload>[]
          }
          delete: {
            args: Prisma.EvaluationConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationConfigPayload>
          }
          update: {
            args: Prisma.EvaluationConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationConfigPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationConfigPayload>
          }
          aggregate: {
            args: Prisma.EvaluationConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluationConfig>
          }
          groupBy: {
            args: Prisma.EvaluationConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationConfigCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationConfigCountAggregateOutputType> | number
          }
        }
      }
      BidderCriterionScore: {
        payload: Prisma.$BidderCriterionScorePayload<ExtArgs>
        fields: Prisma.BidderCriterionScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BidderCriterionScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderCriterionScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BidderCriterionScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderCriterionScorePayload>
          }
          findFirst: {
            args: Prisma.BidderCriterionScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderCriterionScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BidderCriterionScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderCriterionScorePayload>
          }
          findMany: {
            args: Prisma.BidderCriterionScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderCriterionScorePayload>[]
          }
          create: {
            args: Prisma.BidderCriterionScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderCriterionScorePayload>
          }
          createMany: {
            args: Prisma.BidderCriterionScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BidderCriterionScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderCriterionScorePayload>[]
          }
          delete: {
            args: Prisma.BidderCriterionScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderCriterionScorePayload>
          }
          update: {
            args: Prisma.BidderCriterionScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderCriterionScorePayload>
          }
          deleteMany: {
            args: Prisma.BidderCriterionScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BidderCriterionScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BidderCriterionScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderCriterionScorePayload>
          }
          aggregate: {
            args: Prisma.BidderCriterionScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBidderCriterionScore>
          }
          groupBy: {
            args: Prisma.BidderCriterionScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<BidderCriterionScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.BidderCriterionScoreCountArgs<ExtArgs>
            result: $Utils.Optional<BidderCriterionScoreCountAggregateOutputType> | number
          }
        }
      }
      EvaluationResult: {
        payload: Prisma.$EvaluationResultPayload<ExtArgs>
        fields: Prisma.EvaluationResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationResultPayload>
          }
          findFirst: {
            args: Prisma.EvaluationResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationResultPayload>
          }
          findMany: {
            args: Prisma.EvaluationResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationResultPayload>[]
          }
          create: {
            args: Prisma.EvaluationResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationResultPayload>
          }
          createMany: {
            args: Prisma.EvaluationResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationResultPayload>[]
          }
          delete: {
            args: Prisma.EvaluationResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationResultPayload>
          }
          update: {
            args: Prisma.EvaluationResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationResultPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationResultPayload>
          }
          aggregate: {
            args: Prisma.EvaluationResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluationResult>
          }
          groupBy: {
            args: Prisma.EvaluationResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationResultCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationResultCountAggregateOutputType> | number
          }
        }
      }
      WorkflowLog: {
        payload: Prisma.$WorkflowLogPayload<ExtArgs>
        fields: Prisma.WorkflowLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowLogPayload>
          }
          findFirst: {
            args: Prisma.WorkflowLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowLogPayload>
          }
          findMany: {
            args: Prisma.WorkflowLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowLogPayload>[]
          }
          create: {
            args: Prisma.WorkflowLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowLogPayload>
          }
          createMany: {
            args: Prisma.WorkflowLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowLogPayload>[]
          }
          delete: {
            args: Prisma.WorkflowLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowLogPayload>
          }
          update: {
            args: Prisma.WorkflowLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowLogPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowLogPayload>
          }
          aggregate: {
            args: Prisma.WorkflowLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowLog>
          }
          groupBy: {
            args: Prisma.WorkflowLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowLogCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowLogCountAggregateOutputType> | number
          }
        }
      }
      Circular: {
        payload: Prisma.$CircularPayload<ExtArgs>
        fields: Prisma.CircularFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CircularFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircularPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CircularFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircularPayload>
          }
          findFirst: {
            args: Prisma.CircularFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircularPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CircularFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircularPayload>
          }
          findMany: {
            args: Prisma.CircularFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircularPayload>[]
          }
          create: {
            args: Prisma.CircularCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircularPayload>
          }
          createMany: {
            args: Prisma.CircularCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CircularCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircularPayload>[]
          }
          delete: {
            args: Prisma.CircularDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircularPayload>
          }
          update: {
            args: Prisma.CircularUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircularPayload>
          }
          deleteMany: {
            args: Prisma.CircularDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CircularUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CircularUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircularPayload>
          }
          aggregate: {
            args: Prisma.CircularAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCircular>
          }
          groupBy: {
            args: Prisma.CircularGroupByArgs<ExtArgs>
            result: $Utils.Optional<CircularGroupByOutputType>[]
          }
          count: {
            args: Prisma.CircularCountArgs<ExtArgs>
            result: $Utils.Optional<CircularCountAggregateOutputType> | number
          }
        }
      }
      ComplianceRule: {
        payload: Prisma.$ComplianceRulePayload<ExtArgs>
        fields: Prisma.ComplianceRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplianceRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplianceRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceRulePayload>
          }
          findFirst: {
            args: Prisma.ComplianceRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplianceRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceRulePayload>
          }
          findMany: {
            args: Prisma.ComplianceRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceRulePayload>[]
          }
          create: {
            args: Prisma.ComplianceRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceRulePayload>
          }
          createMany: {
            args: Prisma.ComplianceRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplianceRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceRulePayload>[]
          }
          delete: {
            args: Prisma.ComplianceRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceRulePayload>
          }
          update: {
            args: Prisma.ComplianceRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceRulePayload>
          }
          deleteMany: {
            args: Prisma.ComplianceRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplianceRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplianceRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceRulePayload>
          }
          aggregate: {
            args: Prisma.ComplianceRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplianceRule>
          }
          groupBy: {
            args: Prisma.ComplianceRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplianceRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplianceRuleCountArgs<ExtArgs>
            result: $Utils.Optional<ComplianceRuleCountAggregateOutputType> | number
          }
        }
      }
      ComplianceItem: {
        payload: Prisma.$ComplianceItemPayload<ExtArgs>
        fields: Prisma.ComplianceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplianceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplianceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceItemPayload>
          }
          findFirst: {
            args: Prisma.ComplianceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplianceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceItemPayload>
          }
          findMany: {
            args: Prisma.ComplianceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceItemPayload>[]
          }
          create: {
            args: Prisma.ComplianceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceItemPayload>
          }
          createMany: {
            args: Prisma.ComplianceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplianceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceItemPayload>[]
          }
          delete: {
            args: Prisma.ComplianceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceItemPayload>
          }
          update: {
            args: Prisma.ComplianceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceItemPayload>
          }
          deleteMany: {
            args: Prisma.ComplianceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplianceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplianceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceItemPayload>
          }
          aggregate: {
            args: Prisma.ComplianceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplianceItem>
          }
          groupBy: {
            args: Prisma.ComplianceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplianceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplianceItemCountArgs<ExtArgs>
            result: $Utils.Optional<ComplianceItemCountAggregateOutputType> | number
          }
        }
      }
      EvaluationException: {
        payload: Prisma.$EvaluationExceptionPayload<ExtArgs>
        fields: Prisma.EvaluationExceptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationExceptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationExceptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationExceptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationExceptionPayload>
          }
          findFirst: {
            args: Prisma.EvaluationExceptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationExceptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationExceptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationExceptionPayload>
          }
          findMany: {
            args: Prisma.EvaluationExceptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationExceptionPayload>[]
          }
          create: {
            args: Prisma.EvaluationExceptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationExceptionPayload>
          }
          createMany: {
            args: Prisma.EvaluationExceptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationExceptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationExceptionPayload>[]
          }
          delete: {
            args: Prisma.EvaluationExceptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationExceptionPayload>
          }
          update: {
            args: Prisma.EvaluationExceptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationExceptionPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationExceptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationExceptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationExceptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationExceptionPayload>
          }
          aggregate: {
            args: Prisma.EvaluationExceptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluationException>
          }
          groupBy: {
            args: Prisma.EvaluationExceptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationExceptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationExceptionCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationExceptionCountAggregateOutputType> | number
          }
        }
      }
      EvaluationSignature: {
        payload: Prisma.$EvaluationSignaturePayload<ExtArgs>
        fields: Prisma.EvaluationSignatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationSignatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationSignaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationSignatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationSignaturePayload>
          }
          findFirst: {
            args: Prisma.EvaluationSignatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationSignaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationSignatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationSignaturePayload>
          }
          findMany: {
            args: Prisma.EvaluationSignatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationSignaturePayload>[]
          }
          create: {
            args: Prisma.EvaluationSignatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationSignaturePayload>
          }
          createMany: {
            args: Prisma.EvaluationSignatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationSignatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationSignaturePayload>[]
          }
          delete: {
            args: Prisma.EvaluationSignatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationSignaturePayload>
          }
          update: {
            args: Prisma.EvaluationSignatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationSignaturePayload>
          }
          deleteMany: {
            args: Prisma.EvaluationSignatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationSignatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationSignatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationSignaturePayload>
          }
          aggregate: {
            args: Prisma.EvaluationSignatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluationSignature>
          }
          groupBy: {
            args: Prisma.EvaluationSignatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationSignatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationSignatureCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationSignatureCountAggregateOutputType> | number
          }
        }
      }
      EvaluationDocument: {
        payload: Prisma.$EvaluationDocumentPayload<ExtArgs>
        fields: Prisma.EvaluationDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationDocumentPayload>
          }
          findFirst: {
            args: Prisma.EvaluationDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationDocumentPayload>
          }
          findMany: {
            args: Prisma.EvaluationDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationDocumentPayload>[]
          }
          create: {
            args: Prisma.EvaluationDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationDocumentPayload>
          }
          createMany: {
            args: Prisma.EvaluationDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationDocumentPayload>[]
          }
          delete: {
            args: Prisma.EvaluationDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationDocumentPayload>
          }
          update: {
            args: Prisma.EvaluationDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationDocumentPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationDocumentPayload>
          }
          aggregate: {
            args: Prisma.EvaluationDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluationDocument>
          }
          groupBy: {
            args: Prisma.EvaluationDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationDocumentCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsAccessLog: {
        payload: Prisma.$AnalyticsAccessLogPayload<ExtArgs>
        fields: Prisma.AnalyticsAccessLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsAccessLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAccessLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsAccessLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAccessLogPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsAccessLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAccessLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsAccessLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAccessLogPayload>
          }
          findMany: {
            args: Prisma.AnalyticsAccessLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAccessLogPayload>[]
          }
          create: {
            args: Prisma.AnalyticsAccessLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAccessLogPayload>
          }
          createMany: {
            args: Prisma.AnalyticsAccessLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsAccessLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAccessLogPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsAccessLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAccessLogPayload>
          }
          update: {
            args: Prisma.AnalyticsAccessLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAccessLogPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsAccessLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsAccessLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsAccessLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAccessLogPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsAccessLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsAccessLog>
          }
          groupBy: {
            args: Prisma.AnalyticsAccessLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsAccessLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsAccessLogCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsAccessLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationRule: {
        payload: Prisma.$NotificationRulePayload<ExtArgs>
        fields: Prisma.NotificationRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          findFirst: {
            args: Prisma.NotificationRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          findMany: {
            args: Prisma.NotificationRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>[]
          }
          create: {
            args: Prisma.NotificationRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          createMany: {
            args: Prisma.NotificationRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>[]
          }
          delete: {
            args: Prisma.NotificationRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          update: {
            args: Prisma.NotificationRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          deleteMany: {
            args: Prisma.NotificationRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          aggregate: {
            args: Prisma.NotificationRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationRule>
          }
          groupBy: {
            args: Prisma.NotificationRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationRuleCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationRuleCountAggregateOutputType> | number
          }
        }
      }
      TenderTimelineEvent: {
        payload: Prisma.$TenderTimelineEventPayload<ExtArgs>
        fields: Prisma.TenderTimelineEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenderTimelineEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderTimelineEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenderTimelineEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderTimelineEventPayload>
          }
          findFirst: {
            args: Prisma.TenderTimelineEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderTimelineEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenderTimelineEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderTimelineEventPayload>
          }
          findMany: {
            args: Prisma.TenderTimelineEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderTimelineEventPayload>[]
          }
          create: {
            args: Prisma.TenderTimelineEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderTimelineEventPayload>
          }
          createMany: {
            args: Prisma.TenderTimelineEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenderTimelineEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderTimelineEventPayload>[]
          }
          delete: {
            args: Prisma.TenderTimelineEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderTimelineEventPayload>
          }
          update: {
            args: Prisma.TenderTimelineEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderTimelineEventPayload>
          }
          deleteMany: {
            args: Prisma.TenderTimelineEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenderTimelineEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenderTimelineEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderTimelineEventPayload>
          }
          aggregate: {
            args: Prisma.TenderTimelineEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenderTimelineEvent>
          }
          groupBy: {
            args: Prisma.TenderTimelineEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenderTimelineEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenderTimelineEventCountArgs<ExtArgs>
            result: $Utils.Optional<TenderTimelineEventCountAggregateOutputType> | number
          }
        }
      }
      TenderInsights: {
        payload: Prisma.$TenderInsightsPayload<ExtArgs>
        fields: Prisma.TenderInsightsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenderInsightsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderInsightsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenderInsightsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderInsightsPayload>
          }
          findFirst: {
            args: Prisma.TenderInsightsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderInsightsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenderInsightsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderInsightsPayload>
          }
          findMany: {
            args: Prisma.TenderInsightsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderInsightsPayload>[]
          }
          create: {
            args: Prisma.TenderInsightsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderInsightsPayload>
          }
          createMany: {
            args: Prisma.TenderInsightsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenderInsightsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderInsightsPayload>[]
          }
          delete: {
            args: Prisma.TenderInsightsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderInsightsPayload>
          }
          update: {
            args: Prisma.TenderInsightsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderInsightsPayload>
          }
          deleteMany: {
            args: Prisma.TenderInsightsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenderInsightsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenderInsightsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderInsightsPayload>
          }
          aggregate: {
            args: Prisma.TenderInsightsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenderInsights>
          }
          groupBy: {
            args: Prisma.TenderInsightsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenderInsightsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenderInsightsCountArgs<ExtArgs>
            result: $Utils.Optional<TenderInsightsCountAggregateOutputType> | number
          }
        }
      }
      TenderHeatmap: {
        payload: Prisma.$TenderHeatmapPayload<ExtArgs>
        fields: Prisma.TenderHeatmapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenderHeatmapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderHeatmapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenderHeatmapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderHeatmapPayload>
          }
          findFirst: {
            args: Prisma.TenderHeatmapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderHeatmapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenderHeatmapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderHeatmapPayload>
          }
          findMany: {
            args: Prisma.TenderHeatmapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderHeatmapPayload>[]
          }
          create: {
            args: Prisma.TenderHeatmapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderHeatmapPayload>
          }
          createMany: {
            args: Prisma.TenderHeatmapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenderHeatmapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderHeatmapPayload>[]
          }
          delete: {
            args: Prisma.TenderHeatmapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderHeatmapPayload>
          }
          update: {
            args: Prisma.TenderHeatmapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderHeatmapPayload>
          }
          deleteMany: {
            args: Prisma.TenderHeatmapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenderHeatmapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenderHeatmapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderHeatmapPayload>
          }
          aggregate: {
            args: Prisma.TenderHeatmapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenderHeatmap>
          }
          groupBy: {
            args: Prisma.TenderHeatmapGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenderHeatmapGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenderHeatmapCountArgs<ExtArgs>
            result: $Utils.Optional<TenderHeatmapCountAggregateOutputType> | number
          }
        }
      }
      BidderIntelligence: {
        payload: Prisma.$BidderIntelligencePayload<ExtArgs>
        fields: Prisma.BidderIntelligenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BidderIntelligenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderIntelligencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BidderIntelligenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderIntelligencePayload>
          }
          findFirst: {
            args: Prisma.BidderIntelligenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderIntelligencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BidderIntelligenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderIntelligencePayload>
          }
          findMany: {
            args: Prisma.BidderIntelligenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderIntelligencePayload>[]
          }
          create: {
            args: Prisma.BidderIntelligenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderIntelligencePayload>
          }
          createMany: {
            args: Prisma.BidderIntelligenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BidderIntelligenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderIntelligencePayload>[]
          }
          delete: {
            args: Prisma.BidderIntelligenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderIntelligencePayload>
          }
          update: {
            args: Prisma.BidderIntelligenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderIntelligencePayload>
          }
          deleteMany: {
            args: Prisma.BidderIntelligenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BidderIntelligenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BidderIntelligenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderIntelligencePayload>
          }
          aggregate: {
            args: Prisma.BidderIntelligenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBidderIntelligence>
          }
          groupBy: {
            args: Prisma.BidderIntelligenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BidderIntelligenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BidderIntelligenceCountArgs<ExtArgs>
            result: $Utils.Optional<BidderIntelligenceCountAggregateOutputType> | number
          }
        }
      }
      BidderRiskProfile: {
        payload: Prisma.$BidderRiskProfilePayload<ExtArgs>
        fields: Prisma.BidderRiskProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BidderRiskProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderRiskProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BidderRiskProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderRiskProfilePayload>
          }
          findFirst: {
            args: Prisma.BidderRiskProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderRiskProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BidderRiskProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderRiskProfilePayload>
          }
          findMany: {
            args: Prisma.BidderRiskProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderRiskProfilePayload>[]
          }
          create: {
            args: Prisma.BidderRiskProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderRiskProfilePayload>
          }
          createMany: {
            args: Prisma.BidderRiskProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BidderRiskProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderRiskProfilePayload>[]
          }
          delete: {
            args: Prisma.BidderRiskProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderRiskProfilePayload>
          }
          update: {
            args: Prisma.BidderRiskProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderRiskProfilePayload>
          }
          deleteMany: {
            args: Prisma.BidderRiskProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BidderRiskProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BidderRiskProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidderRiskProfilePayload>
          }
          aggregate: {
            args: Prisma.BidderRiskProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBidderRiskProfile>
          }
          groupBy: {
            args: Prisma.BidderRiskProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<BidderRiskProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.BidderRiskProfileCountArgs<ExtArgs>
            result: $Utils.Optional<BidderRiskProfileCountAggregateOutputType> | number
          }
        }
      }
      TenderComplianceDashboard: {
        payload: Prisma.$TenderComplianceDashboardPayload<ExtArgs>
        fields: Prisma.TenderComplianceDashboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenderComplianceDashboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderComplianceDashboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenderComplianceDashboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderComplianceDashboardPayload>
          }
          findFirst: {
            args: Prisma.TenderComplianceDashboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderComplianceDashboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenderComplianceDashboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderComplianceDashboardPayload>
          }
          findMany: {
            args: Prisma.TenderComplianceDashboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderComplianceDashboardPayload>[]
          }
          create: {
            args: Prisma.TenderComplianceDashboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderComplianceDashboardPayload>
          }
          createMany: {
            args: Prisma.TenderComplianceDashboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenderComplianceDashboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderComplianceDashboardPayload>[]
          }
          delete: {
            args: Prisma.TenderComplianceDashboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderComplianceDashboardPayload>
          }
          update: {
            args: Prisma.TenderComplianceDashboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderComplianceDashboardPayload>
          }
          deleteMany: {
            args: Prisma.TenderComplianceDashboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenderComplianceDashboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenderComplianceDashboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenderComplianceDashboardPayload>
          }
          aggregate: {
            args: Prisma.TenderComplianceDashboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenderComplianceDashboard>
          }
          groupBy: {
            args: Prisma.TenderComplianceDashboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenderComplianceDashboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenderComplianceDashboardCountArgs<ExtArgs>
            result: $Utils.Optional<TenderComplianceDashboardCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    tenders: number
    users: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenders?: boolean | TenantCountOutputTypeCountTendersArgs
    users?: boolean | TenantCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTendersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenderWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    analyticsLogs: number
    scmAssignments: number
    notifications: number
    notificationRules: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyticsLogs?: boolean | UserCountOutputTypeCountAnalyticsLogsArgs
    scmAssignments?: boolean | UserCountOutputTypeCountScmAssignmentsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    notificationRules?: boolean | UserCountOutputTypeCountNotificationRulesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnalyticsLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsAccessLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScmAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScmTenderAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRuleWhereInput
  }


  /**
   * Count Type TenderCountOutputType
   */

  export type TenderCountOutputType = {
    bidders: number
    documents: number
    evaluationResults: number
    signatures: number
    scmAssignments: number
    timelineEvents: number
  }

  export type TenderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidders?: boolean | TenderCountOutputTypeCountBiddersArgs
    documents?: boolean | TenderCountOutputTypeCountDocumentsArgs
    evaluationResults?: boolean | TenderCountOutputTypeCountEvaluationResultsArgs
    signatures?: boolean | TenderCountOutputTypeCountSignaturesArgs
    scmAssignments?: boolean | TenderCountOutputTypeCountScmAssignmentsArgs
    timelineEvents?: boolean | TenderCountOutputTypeCountTimelineEventsArgs
  }

  // Custom InputTypes
  /**
   * TenderCountOutputType without action
   */
  export type TenderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderCountOutputType
     */
    select?: TenderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenderCountOutputType without action
   */
  export type TenderCountOutputTypeCountBiddersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidderWhereInput
  }

  /**
   * TenderCountOutputType without action
   */
  export type TenderCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationDocumentWhereInput
  }

  /**
   * TenderCountOutputType without action
   */
  export type TenderCountOutputTypeCountEvaluationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationResultWhereInput
  }

  /**
   * TenderCountOutputType without action
   */
  export type TenderCountOutputTypeCountSignaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationSignatureWhereInput
  }

  /**
   * TenderCountOutputType without action
   */
  export type TenderCountOutputTypeCountScmAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScmTenderAssignmentWhereInput
  }

  /**
   * TenderCountOutputType without action
   */
  export type TenderCountOutputTypeCountTimelineEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenderTimelineEventWhereInput
  }


  /**
   * Count Type BidderCountOutputType
   */

  export type BidderCountOutputType = {
    technicalScores: number
    evaluationResults: number
    evidence: number
  }

  export type BidderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    technicalScores?: boolean | BidderCountOutputTypeCountTechnicalScoresArgs
    evaluationResults?: boolean | BidderCountOutputTypeCountEvaluationResultsArgs
    evidence?: boolean | BidderCountOutputTypeCountEvidenceArgs
  }

  // Custom InputTypes
  /**
   * BidderCountOutputType without action
   */
  export type BidderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCountOutputType
     */
    select?: BidderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BidderCountOutputType without action
   */
  export type BidderCountOutputTypeCountTechnicalScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidderCriterionScoreWhereInput
  }

  /**
   * BidderCountOutputType without action
   */
  export type BidderCountOutputTypeCountEvaluationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationResultWhereInput
  }

  /**
   * BidderCountOutputType without action
   */
  export type BidderCountOutputTypeCountEvidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceWhereInput
  }


  /**
   * Count Type EvaluationResultCountOutputType
   */

  export type EvaluationResultCountOutputType = {
    compliance: number
    exceptions: number
    workflowLogs: number
  }

  export type EvaluationResultCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compliance?: boolean | EvaluationResultCountOutputTypeCountComplianceArgs
    exceptions?: boolean | EvaluationResultCountOutputTypeCountExceptionsArgs
    workflowLogs?: boolean | EvaluationResultCountOutputTypeCountWorkflowLogsArgs
  }

  // Custom InputTypes
  /**
   * EvaluationResultCountOutputType without action
   */
  export type EvaluationResultCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResultCountOutputType
     */
    select?: EvaluationResultCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvaluationResultCountOutputType without action
   */
  export type EvaluationResultCountOutputTypeCountComplianceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceItemWhereInput
  }

  /**
   * EvaluationResultCountOutputType without action
   */
  export type EvaluationResultCountOutputTypeCountExceptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationExceptionWhereInput
  }

  /**
   * EvaluationResultCountOutputType without action
   */
  export type EvaluationResultCountOutputTypeCountWorkflowLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowLogWhereInput
  }


  /**
   * Count Type CircularCountOutputType
   */

  export type CircularCountOutputType = {
    rules: number
  }

  export type CircularCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rules?: boolean | CircularCountOutputTypeCountRulesArgs
  }

  // Custom InputTypes
  /**
   * CircularCountOutputType without action
   */
  export type CircularCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircularCountOutputType
     */
    select?: CircularCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CircularCountOutputType without action
   */
  export type CircularCountOutputTypeCountRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceRuleWhereInput
  }


  /**
   * Count Type ComplianceRuleCountOutputType
   */

  export type ComplianceRuleCountOutputType = {
    items: number
  }

  export type ComplianceRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ComplianceRuleCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ComplianceRuleCountOutputType without action
   */
  export type ComplianceRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRuleCountOutputType
     */
    select?: ComplianceRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComplianceRuleCountOutputType without action
   */
  export type ComplianceRuleCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    code: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    code: string
    name: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branding?: boolean | Tenant$brandingArgs<ExtArgs>
    tenders?: boolean | Tenant$tendersArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branding?: boolean | Tenant$brandingArgs<ExtArgs>
    tenders?: boolean | Tenant$tendersArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      branding: Prisma.$TenantBrandingPayload<ExtArgs> | null
      tenders: Prisma.$TenderPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branding<T extends Tenant$brandingArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$brandingArgs<ExtArgs>>): Prisma__TenantBrandingClient<$Result.GetResult<Prisma.$TenantBrandingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tenders<T extends Tenant$tendersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tendersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly code: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly active: FieldRef<"Tenant", 'Boolean'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.branding
   */
  export type Tenant$brandingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingInclude<ExtArgs> | null
    where?: TenantBrandingWhereInput
  }

  /**
   * Tenant.tenders
   */
  export type Tenant$tendersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInclude<ExtArgs> | null
    where?: TenderWhereInput
    orderBy?: TenderOrderByWithRelationInput | TenderOrderByWithRelationInput[]
    cursor?: TenderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenderScalarFieldEnum | TenderScalarFieldEnum[]
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model TenantBranding
   */

  export type AggregateTenantBranding = {
    _count: TenantBrandingCountAggregateOutputType | null
    _min: TenantBrandingMinAggregateOutputType | null
    _max: TenantBrandingMaxAggregateOutputType | null
  }

  export type TenantBrandingMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    primaryColor: string | null
    secondaryColor: string | null
    logoUrl: string | null
    publicName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantBrandingMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    primaryColor: string | null
    secondaryColor: string | null
    logoUrl: string | null
    publicName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantBrandingCountAggregateOutputType = {
    id: number
    tenantId: number
    primaryColor: number
    secondaryColor: number
    logoUrl: number
    publicName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantBrandingMinAggregateInputType = {
    id?: true
    tenantId?: true
    primaryColor?: true
    secondaryColor?: true
    logoUrl?: true
    publicName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantBrandingMaxAggregateInputType = {
    id?: true
    tenantId?: true
    primaryColor?: true
    secondaryColor?: true
    logoUrl?: true
    publicName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantBrandingCountAggregateInputType = {
    id?: true
    tenantId?: true
    primaryColor?: true
    secondaryColor?: true
    logoUrl?: true
    publicName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantBrandingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantBranding to aggregate.
     */
    where?: TenantBrandingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBrandings to fetch.
     */
    orderBy?: TenantBrandingOrderByWithRelationInput | TenantBrandingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantBrandingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBrandings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBrandings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantBrandings
    **/
    _count?: true | TenantBrandingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantBrandingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantBrandingMaxAggregateInputType
  }

  export type GetTenantBrandingAggregateType<T extends TenantBrandingAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantBranding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantBranding[P]>
      : GetScalarType<T[P], AggregateTenantBranding[P]>
  }




  export type TenantBrandingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantBrandingWhereInput
    orderBy?: TenantBrandingOrderByWithAggregationInput | TenantBrandingOrderByWithAggregationInput[]
    by: TenantBrandingScalarFieldEnum[] | TenantBrandingScalarFieldEnum
    having?: TenantBrandingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantBrandingCountAggregateInputType | true
    _min?: TenantBrandingMinAggregateInputType
    _max?: TenantBrandingMaxAggregateInputType
  }

  export type TenantBrandingGroupByOutputType = {
    id: string
    tenantId: string
    primaryColor: string | null
    secondaryColor: string | null
    logoUrl: string | null
    publicName: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantBrandingCountAggregateOutputType | null
    _min: TenantBrandingMinAggregateOutputType | null
    _max: TenantBrandingMaxAggregateOutputType | null
  }

  type GetTenantBrandingGroupByPayload<T extends TenantBrandingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantBrandingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantBrandingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantBrandingGroupByOutputType[P]>
            : GetScalarType<T[P], TenantBrandingGroupByOutputType[P]>
        }
      >
    >


  export type TenantBrandingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    logoUrl?: boolean
    publicName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantBranding"]>

  export type TenantBrandingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    logoUrl?: boolean
    publicName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantBranding"]>

  export type TenantBrandingSelectScalar = {
    id?: boolean
    tenantId?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    logoUrl?: boolean
    publicName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantBrandingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantBrandingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantBrandingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantBranding"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      primaryColor: string | null
      secondaryColor: string | null
      logoUrl: string | null
      publicName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantBranding"]>
    composites: {}
  }

  type TenantBrandingGetPayload<S extends boolean | null | undefined | TenantBrandingDefaultArgs> = $Result.GetResult<Prisma.$TenantBrandingPayload, S>

  type TenantBrandingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantBrandingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantBrandingCountAggregateInputType | true
    }

  export interface TenantBrandingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantBranding'], meta: { name: 'TenantBranding' } }
    /**
     * Find zero or one TenantBranding that matches the filter.
     * @param {TenantBrandingFindUniqueArgs} args - Arguments to find a TenantBranding
     * @example
     * // Get one TenantBranding
     * const tenantBranding = await prisma.tenantBranding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantBrandingFindUniqueArgs>(args: SelectSubset<T, TenantBrandingFindUniqueArgs<ExtArgs>>): Prisma__TenantBrandingClient<$Result.GetResult<Prisma.$TenantBrandingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TenantBranding that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantBrandingFindUniqueOrThrowArgs} args - Arguments to find a TenantBranding
     * @example
     * // Get one TenantBranding
     * const tenantBranding = await prisma.tenantBranding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantBrandingFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantBrandingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantBrandingClient<$Result.GetResult<Prisma.$TenantBrandingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TenantBranding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBrandingFindFirstArgs} args - Arguments to find a TenantBranding
     * @example
     * // Get one TenantBranding
     * const tenantBranding = await prisma.tenantBranding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantBrandingFindFirstArgs>(args?: SelectSubset<T, TenantBrandingFindFirstArgs<ExtArgs>>): Prisma__TenantBrandingClient<$Result.GetResult<Prisma.$TenantBrandingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TenantBranding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBrandingFindFirstOrThrowArgs} args - Arguments to find a TenantBranding
     * @example
     * // Get one TenantBranding
     * const tenantBranding = await prisma.tenantBranding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantBrandingFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantBrandingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantBrandingClient<$Result.GetResult<Prisma.$TenantBrandingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TenantBrandings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBrandingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantBrandings
     * const tenantBrandings = await prisma.tenantBranding.findMany()
     * 
     * // Get first 10 TenantBrandings
     * const tenantBrandings = await prisma.tenantBranding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantBrandingWithIdOnly = await prisma.tenantBranding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantBrandingFindManyArgs>(args?: SelectSubset<T, TenantBrandingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantBrandingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TenantBranding.
     * @param {TenantBrandingCreateArgs} args - Arguments to create a TenantBranding.
     * @example
     * // Create one TenantBranding
     * const TenantBranding = await prisma.tenantBranding.create({
     *   data: {
     *     // ... data to create a TenantBranding
     *   }
     * })
     * 
     */
    create<T extends TenantBrandingCreateArgs>(args: SelectSubset<T, TenantBrandingCreateArgs<ExtArgs>>): Prisma__TenantBrandingClient<$Result.GetResult<Prisma.$TenantBrandingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TenantBrandings.
     * @param {TenantBrandingCreateManyArgs} args - Arguments to create many TenantBrandings.
     * @example
     * // Create many TenantBrandings
     * const tenantBranding = await prisma.tenantBranding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantBrandingCreateManyArgs>(args?: SelectSubset<T, TenantBrandingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantBrandings and returns the data saved in the database.
     * @param {TenantBrandingCreateManyAndReturnArgs} args - Arguments to create many TenantBrandings.
     * @example
     * // Create many TenantBrandings
     * const tenantBranding = await prisma.tenantBranding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantBrandings and only return the `id`
     * const tenantBrandingWithIdOnly = await prisma.tenantBranding.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantBrandingCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantBrandingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantBrandingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TenantBranding.
     * @param {TenantBrandingDeleteArgs} args - Arguments to delete one TenantBranding.
     * @example
     * // Delete one TenantBranding
     * const TenantBranding = await prisma.tenantBranding.delete({
     *   where: {
     *     // ... filter to delete one TenantBranding
     *   }
     * })
     * 
     */
    delete<T extends TenantBrandingDeleteArgs>(args: SelectSubset<T, TenantBrandingDeleteArgs<ExtArgs>>): Prisma__TenantBrandingClient<$Result.GetResult<Prisma.$TenantBrandingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TenantBranding.
     * @param {TenantBrandingUpdateArgs} args - Arguments to update one TenantBranding.
     * @example
     * // Update one TenantBranding
     * const tenantBranding = await prisma.tenantBranding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantBrandingUpdateArgs>(args: SelectSubset<T, TenantBrandingUpdateArgs<ExtArgs>>): Prisma__TenantBrandingClient<$Result.GetResult<Prisma.$TenantBrandingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TenantBrandings.
     * @param {TenantBrandingDeleteManyArgs} args - Arguments to filter TenantBrandings to delete.
     * @example
     * // Delete a few TenantBrandings
     * const { count } = await prisma.tenantBranding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantBrandingDeleteManyArgs>(args?: SelectSubset<T, TenantBrandingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantBrandings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBrandingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantBrandings
     * const tenantBranding = await prisma.tenantBranding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantBrandingUpdateManyArgs>(args: SelectSubset<T, TenantBrandingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TenantBranding.
     * @param {TenantBrandingUpsertArgs} args - Arguments to update or create a TenantBranding.
     * @example
     * // Update or create a TenantBranding
     * const tenantBranding = await prisma.tenantBranding.upsert({
     *   create: {
     *     // ... data to create a TenantBranding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantBranding we want to update
     *   }
     * })
     */
    upsert<T extends TenantBrandingUpsertArgs>(args: SelectSubset<T, TenantBrandingUpsertArgs<ExtArgs>>): Prisma__TenantBrandingClient<$Result.GetResult<Prisma.$TenantBrandingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TenantBrandings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBrandingCountArgs} args - Arguments to filter TenantBrandings to count.
     * @example
     * // Count the number of TenantBrandings
     * const count = await prisma.tenantBranding.count({
     *   where: {
     *     // ... the filter for the TenantBrandings we want to count
     *   }
     * })
    **/
    count<T extends TenantBrandingCountArgs>(
      args?: Subset<T, TenantBrandingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantBrandingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantBranding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBrandingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantBrandingAggregateArgs>(args: Subset<T, TenantBrandingAggregateArgs>): Prisma.PrismaPromise<GetTenantBrandingAggregateType<T>>

    /**
     * Group by TenantBranding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBrandingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantBrandingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantBrandingGroupByArgs['orderBy'] }
        : { orderBy?: TenantBrandingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantBrandingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantBrandingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantBranding model
   */
  readonly fields: TenantBrandingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantBranding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantBrandingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantBranding model
   */ 
  interface TenantBrandingFieldRefs {
    readonly id: FieldRef<"TenantBranding", 'String'>
    readonly tenantId: FieldRef<"TenantBranding", 'String'>
    readonly primaryColor: FieldRef<"TenantBranding", 'String'>
    readonly secondaryColor: FieldRef<"TenantBranding", 'String'>
    readonly logoUrl: FieldRef<"TenantBranding", 'String'>
    readonly publicName: FieldRef<"TenantBranding", 'String'>
    readonly createdAt: FieldRef<"TenantBranding", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantBranding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantBranding findUnique
   */
  export type TenantBrandingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingInclude<ExtArgs> | null
    /**
     * Filter, which TenantBranding to fetch.
     */
    where: TenantBrandingWhereUniqueInput
  }

  /**
   * TenantBranding findUniqueOrThrow
   */
  export type TenantBrandingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingInclude<ExtArgs> | null
    /**
     * Filter, which TenantBranding to fetch.
     */
    where: TenantBrandingWhereUniqueInput
  }

  /**
   * TenantBranding findFirst
   */
  export type TenantBrandingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingInclude<ExtArgs> | null
    /**
     * Filter, which TenantBranding to fetch.
     */
    where?: TenantBrandingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBrandings to fetch.
     */
    orderBy?: TenantBrandingOrderByWithRelationInput | TenantBrandingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantBrandings.
     */
    cursor?: TenantBrandingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBrandings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBrandings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantBrandings.
     */
    distinct?: TenantBrandingScalarFieldEnum | TenantBrandingScalarFieldEnum[]
  }

  /**
   * TenantBranding findFirstOrThrow
   */
  export type TenantBrandingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingInclude<ExtArgs> | null
    /**
     * Filter, which TenantBranding to fetch.
     */
    where?: TenantBrandingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBrandings to fetch.
     */
    orderBy?: TenantBrandingOrderByWithRelationInput | TenantBrandingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantBrandings.
     */
    cursor?: TenantBrandingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBrandings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBrandings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantBrandings.
     */
    distinct?: TenantBrandingScalarFieldEnum | TenantBrandingScalarFieldEnum[]
  }

  /**
   * TenantBranding findMany
   */
  export type TenantBrandingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingInclude<ExtArgs> | null
    /**
     * Filter, which TenantBrandings to fetch.
     */
    where?: TenantBrandingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBrandings to fetch.
     */
    orderBy?: TenantBrandingOrderByWithRelationInput | TenantBrandingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantBrandings.
     */
    cursor?: TenantBrandingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBrandings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBrandings.
     */
    skip?: number
    distinct?: TenantBrandingScalarFieldEnum | TenantBrandingScalarFieldEnum[]
  }

  /**
   * TenantBranding create
   */
  export type TenantBrandingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantBranding.
     */
    data: XOR<TenantBrandingCreateInput, TenantBrandingUncheckedCreateInput>
  }

  /**
   * TenantBranding createMany
   */
  export type TenantBrandingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantBrandings.
     */
    data: TenantBrandingCreateManyInput | TenantBrandingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantBranding createManyAndReturn
   */
  export type TenantBrandingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TenantBrandings.
     */
    data: TenantBrandingCreateManyInput | TenantBrandingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantBranding update
   */
  export type TenantBrandingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantBranding.
     */
    data: XOR<TenantBrandingUpdateInput, TenantBrandingUncheckedUpdateInput>
    /**
     * Choose, which TenantBranding to update.
     */
    where: TenantBrandingWhereUniqueInput
  }

  /**
   * TenantBranding updateMany
   */
  export type TenantBrandingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantBrandings.
     */
    data: XOR<TenantBrandingUpdateManyMutationInput, TenantBrandingUncheckedUpdateManyInput>
    /**
     * Filter which TenantBrandings to update
     */
    where?: TenantBrandingWhereInput
  }

  /**
   * TenantBranding upsert
   */
  export type TenantBrandingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantBranding to update in case it exists.
     */
    where: TenantBrandingWhereUniqueInput
    /**
     * In case the TenantBranding found by the `where` argument doesn't exist, create a new TenantBranding with this data.
     */
    create: XOR<TenantBrandingCreateInput, TenantBrandingUncheckedCreateInput>
    /**
     * In case the TenantBranding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantBrandingUpdateInput, TenantBrandingUncheckedUpdateInput>
  }

  /**
   * TenantBranding delete
   */
  export type TenantBrandingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingInclude<ExtArgs> | null
    /**
     * Filter which TenantBranding to delete.
     */
    where: TenantBrandingWhereUniqueInput
  }

  /**
   * TenantBranding deleteMany
   */
  export type TenantBrandingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantBrandings to delete
     */
    where?: TenantBrandingWhereInput
  }

  /**
   * TenantBranding without action
   */
  export type TenantBrandingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBranding
     */
    select?: TenantBrandingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBrandingInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
    tenantId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
    tenantId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    password: number
    tenantId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    tenantId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    tenantId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    tenantId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    role: string
    createdAt: Date
    updatedAt: Date
    password: string
    tenantId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    tenantId?: boolean
    analyticsLogs?: boolean | User$analyticsLogsArgs<ExtArgs>
    scmAssignments?: boolean | User$scmAssignmentsArgs<ExtArgs>
    tenant?: boolean | User$tenantArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notificationRules?: boolean | User$notificationRulesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    tenantId?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    tenantId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyticsLogs?: boolean | User$analyticsLogsArgs<ExtArgs>
    scmAssignments?: boolean | User$scmAssignmentsArgs<ExtArgs>
    tenant?: boolean | User$tenantArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notificationRules?: boolean | User$notificationRulesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      analyticsLogs: Prisma.$AnalyticsAccessLogPayload<ExtArgs>[]
      scmAssignments: Prisma.$ScmTenderAssignmentPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      notificationRules: Prisma.$NotificationRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      role: string
      createdAt: Date
      updatedAt: Date
      password: string
      tenantId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analyticsLogs<T extends User$analyticsLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$analyticsLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsAccessLogPayload<ExtArgs>, T, "findMany"> | Null>
    scmAssignments<T extends User$scmAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$scmAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    tenant<T extends User$tenantArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    notificationRules<T extends User$notificationRulesArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.analyticsLogs
   */
  export type User$analyticsLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogInclude<ExtArgs> | null
    where?: AnalyticsAccessLogWhereInput
    orderBy?: AnalyticsAccessLogOrderByWithRelationInput | AnalyticsAccessLogOrderByWithRelationInput[]
    cursor?: AnalyticsAccessLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsAccessLogScalarFieldEnum | AnalyticsAccessLogScalarFieldEnum[]
  }

  /**
   * User.scmAssignments
   */
  export type User$scmAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
    where?: ScmTenderAssignmentWhereInput
    orderBy?: ScmTenderAssignmentOrderByWithRelationInput | ScmTenderAssignmentOrderByWithRelationInput[]
    cursor?: ScmTenderAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScmTenderAssignmentScalarFieldEnum | ScmTenderAssignmentScalarFieldEnum[]
  }

  /**
   * User.tenant
   */
  export type User$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.notificationRules
   */
  export type User$notificationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    where?: NotificationRuleWhereInput
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    cursor?: NotificationRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ScmTenderAssignment
   */

  export type AggregateScmTenderAssignment = {
    _count: ScmTenderAssignmentCountAggregateOutputType | null
    _min: ScmTenderAssignmentMinAggregateOutputType | null
    _max: ScmTenderAssignmentMaxAggregateOutputType | null
  }

  export type ScmTenderAssignmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenderId: string | null
    createdAt: Date | null
  }

  export type ScmTenderAssignmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenderId: string | null
    createdAt: Date | null
  }

  export type ScmTenderAssignmentCountAggregateOutputType = {
    id: number
    userId: number
    tenderId: number
    createdAt: number
    _all: number
  }


  export type ScmTenderAssignmentMinAggregateInputType = {
    id?: true
    userId?: true
    tenderId?: true
    createdAt?: true
  }

  export type ScmTenderAssignmentMaxAggregateInputType = {
    id?: true
    userId?: true
    tenderId?: true
    createdAt?: true
  }

  export type ScmTenderAssignmentCountAggregateInputType = {
    id?: true
    userId?: true
    tenderId?: true
    createdAt?: true
    _all?: true
  }

  export type ScmTenderAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScmTenderAssignment to aggregate.
     */
    where?: ScmTenderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScmTenderAssignments to fetch.
     */
    orderBy?: ScmTenderAssignmentOrderByWithRelationInput | ScmTenderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScmTenderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScmTenderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScmTenderAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScmTenderAssignments
    **/
    _count?: true | ScmTenderAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScmTenderAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScmTenderAssignmentMaxAggregateInputType
  }

  export type GetScmTenderAssignmentAggregateType<T extends ScmTenderAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateScmTenderAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScmTenderAssignment[P]>
      : GetScalarType<T[P], AggregateScmTenderAssignment[P]>
  }




  export type ScmTenderAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScmTenderAssignmentWhereInput
    orderBy?: ScmTenderAssignmentOrderByWithAggregationInput | ScmTenderAssignmentOrderByWithAggregationInput[]
    by: ScmTenderAssignmentScalarFieldEnum[] | ScmTenderAssignmentScalarFieldEnum
    having?: ScmTenderAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScmTenderAssignmentCountAggregateInputType | true
    _min?: ScmTenderAssignmentMinAggregateInputType
    _max?: ScmTenderAssignmentMaxAggregateInputType
  }

  export type ScmTenderAssignmentGroupByOutputType = {
    id: string
    userId: string
    tenderId: string
    createdAt: Date
    _count: ScmTenderAssignmentCountAggregateOutputType | null
    _min: ScmTenderAssignmentMinAggregateOutputType | null
    _max: ScmTenderAssignmentMaxAggregateOutputType | null
  }

  type GetScmTenderAssignmentGroupByPayload<T extends ScmTenderAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScmTenderAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScmTenderAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScmTenderAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ScmTenderAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ScmTenderAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenderId?: boolean
    createdAt?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scmTenderAssignment"]>

  export type ScmTenderAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenderId?: boolean
    createdAt?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scmTenderAssignment"]>

  export type ScmTenderAssignmentSelectScalar = {
    id?: boolean
    userId?: boolean
    tenderId?: boolean
    createdAt?: boolean
  }

  export type ScmTenderAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ScmTenderAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ScmTenderAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScmTenderAssignment"
    objects: {
      tender: Prisma.$TenderPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tenderId: string
      createdAt: Date
    }, ExtArgs["result"]["scmTenderAssignment"]>
    composites: {}
  }

  type ScmTenderAssignmentGetPayload<S extends boolean | null | undefined | ScmTenderAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ScmTenderAssignmentPayload, S>

  type ScmTenderAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScmTenderAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScmTenderAssignmentCountAggregateInputType | true
    }

  export interface ScmTenderAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScmTenderAssignment'], meta: { name: 'ScmTenderAssignment' } }
    /**
     * Find zero or one ScmTenderAssignment that matches the filter.
     * @param {ScmTenderAssignmentFindUniqueArgs} args - Arguments to find a ScmTenderAssignment
     * @example
     * // Get one ScmTenderAssignment
     * const scmTenderAssignment = await prisma.scmTenderAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScmTenderAssignmentFindUniqueArgs>(args: SelectSubset<T, ScmTenderAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ScmTenderAssignmentClient<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScmTenderAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScmTenderAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ScmTenderAssignment
     * @example
     * // Get one ScmTenderAssignment
     * const scmTenderAssignment = await prisma.scmTenderAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScmTenderAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ScmTenderAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScmTenderAssignmentClient<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScmTenderAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScmTenderAssignmentFindFirstArgs} args - Arguments to find a ScmTenderAssignment
     * @example
     * // Get one ScmTenderAssignment
     * const scmTenderAssignment = await prisma.scmTenderAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScmTenderAssignmentFindFirstArgs>(args?: SelectSubset<T, ScmTenderAssignmentFindFirstArgs<ExtArgs>>): Prisma__ScmTenderAssignmentClient<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScmTenderAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScmTenderAssignmentFindFirstOrThrowArgs} args - Arguments to find a ScmTenderAssignment
     * @example
     * // Get one ScmTenderAssignment
     * const scmTenderAssignment = await prisma.scmTenderAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScmTenderAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ScmTenderAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScmTenderAssignmentClient<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScmTenderAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScmTenderAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScmTenderAssignments
     * const scmTenderAssignments = await prisma.scmTenderAssignment.findMany()
     * 
     * // Get first 10 ScmTenderAssignments
     * const scmTenderAssignments = await prisma.scmTenderAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scmTenderAssignmentWithIdOnly = await prisma.scmTenderAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScmTenderAssignmentFindManyArgs>(args?: SelectSubset<T, ScmTenderAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScmTenderAssignment.
     * @param {ScmTenderAssignmentCreateArgs} args - Arguments to create a ScmTenderAssignment.
     * @example
     * // Create one ScmTenderAssignment
     * const ScmTenderAssignment = await prisma.scmTenderAssignment.create({
     *   data: {
     *     // ... data to create a ScmTenderAssignment
     *   }
     * })
     * 
     */
    create<T extends ScmTenderAssignmentCreateArgs>(args: SelectSubset<T, ScmTenderAssignmentCreateArgs<ExtArgs>>): Prisma__ScmTenderAssignmentClient<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScmTenderAssignments.
     * @param {ScmTenderAssignmentCreateManyArgs} args - Arguments to create many ScmTenderAssignments.
     * @example
     * // Create many ScmTenderAssignments
     * const scmTenderAssignment = await prisma.scmTenderAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScmTenderAssignmentCreateManyArgs>(args?: SelectSubset<T, ScmTenderAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScmTenderAssignments and returns the data saved in the database.
     * @param {ScmTenderAssignmentCreateManyAndReturnArgs} args - Arguments to create many ScmTenderAssignments.
     * @example
     * // Create many ScmTenderAssignments
     * const scmTenderAssignment = await prisma.scmTenderAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScmTenderAssignments and only return the `id`
     * const scmTenderAssignmentWithIdOnly = await prisma.scmTenderAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScmTenderAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ScmTenderAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScmTenderAssignment.
     * @param {ScmTenderAssignmentDeleteArgs} args - Arguments to delete one ScmTenderAssignment.
     * @example
     * // Delete one ScmTenderAssignment
     * const ScmTenderAssignment = await prisma.scmTenderAssignment.delete({
     *   where: {
     *     // ... filter to delete one ScmTenderAssignment
     *   }
     * })
     * 
     */
    delete<T extends ScmTenderAssignmentDeleteArgs>(args: SelectSubset<T, ScmTenderAssignmentDeleteArgs<ExtArgs>>): Prisma__ScmTenderAssignmentClient<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScmTenderAssignment.
     * @param {ScmTenderAssignmentUpdateArgs} args - Arguments to update one ScmTenderAssignment.
     * @example
     * // Update one ScmTenderAssignment
     * const scmTenderAssignment = await prisma.scmTenderAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScmTenderAssignmentUpdateArgs>(args: SelectSubset<T, ScmTenderAssignmentUpdateArgs<ExtArgs>>): Prisma__ScmTenderAssignmentClient<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScmTenderAssignments.
     * @param {ScmTenderAssignmentDeleteManyArgs} args - Arguments to filter ScmTenderAssignments to delete.
     * @example
     * // Delete a few ScmTenderAssignments
     * const { count } = await prisma.scmTenderAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScmTenderAssignmentDeleteManyArgs>(args?: SelectSubset<T, ScmTenderAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScmTenderAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScmTenderAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScmTenderAssignments
     * const scmTenderAssignment = await prisma.scmTenderAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScmTenderAssignmentUpdateManyArgs>(args: SelectSubset<T, ScmTenderAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScmTenderAssignment.
     * @param {ScmTenderAssignmentUpsertArgs} args - Arguments to update or create a ScmTenderAssignment.
     * @example
     * // Update or create a ScmTenderAssignment
     * const scmTenderAssignment = await prisma.scmTenderAssignment.upsert({
     *   create: {
     *     // ... data to create a ScmTenderAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScmTenderAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ScmTenderAssignmentUpsertArgs>(args: SelectSubset<T, ScmTenderAssignmentUpsertArgs<ExtArgs>>): Prisma__ScmTenderAssignmentClient<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScmTenderAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScmTenderAssignmentCountArgs} args - Arguments to filter ScmTenderAssignments to count.
     * @example
     * // Count the number of ScmTenderAssignments
     * const count = await prisma.scmTenderAssignment.count({
     *   where: {
     *     // ... the filter for the ScmTenderAssignments we want to count
     *   }
     * })
    **/
    count<T extends ScmTenderAssignmentCountArgs>(
      args?: Subset<T, ScmTenderAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScmTenderAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScmTenderAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScmTenderAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScmTenderAssignmentAggregateArgs>(args: Subset<T, ScmTenderAssignmentAggregateArgs>): Prisma.PrismaPromise<GetScmTenderAssignmentAggregateType<T>>

    /**
     * Group by ScmTenderAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScmTenderAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScmTenderAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScmTenderAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ScmTenderAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScmTenderAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScmTenderAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScmTenderAssignment model
   */
  readonly fields: ScmTenderAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScmTenderAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScmTenderAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tender<T extends TenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenderDefaultArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScmTenderAssignment model
   */ 
  interface ScmTenderAssignmentFieldRefs {
    readonly id: FieldRef<"ScmTenderAssignment", 'String'>
    readonly userId: FieldRef<"ScmTenderAssignment", 'String'>
    readonly tenderId: FieldRef<"ScmTenderAssignment", 'String'>
    readonly createdAt: FieldRef<"ScmTenderAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScmTenderAssignment findUnique
   */
  export type ScmTenderAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ScmTenderAssignment to fetch.
     */
    where: ScmTenderAssignmentWhereUniqueInput
  }

  /**
   * ScmTenderAssignment findUniqueOrThrow
   */
  export type ScmTenderAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ScmTenderAssignment to fetch.
     */
    where: ScmTenderAssignmentWhereUniqueInput
  }

  /**
   * ScmTenderAssignment findFirst
   */
  export type ScmTenderAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ScmTenderAssignment to fetch.
     */
    where?: ScmTenderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScmTenderAssignments to fetch.
     */
    orderBy?: ScmTenderAssignmentOrderByWithRelationInput | ScmTenderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScmTenderAssignments.
     */
    cursor?: ScmTenderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScmTenderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScmTenderAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScmTenderAssignments.
     */
    distinct?: ScmTenderAssignmentScalarFieldEnum | ScmTenderAssignmentScalarFieldEnum[]
  }

  /**
   * ScmTenderAssignment findFirstOrThrow
   */
  export type ScmTenderAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ScmTenderAssignment to fetch.
     */
    where?: ScmTenderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScmTenderAssignments to fetch.
     */
    orderBy?: ScmTenderAssignmentOrderByWithRelationInput | ScmTenderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScmTenderAssignments.
     */
    cursor?: ScmTenderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScmTenderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScmTenderAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScmTenderAssignments.
     */
    distinct?: ScmTenderAssignmentScalarFieldEnum | ScmTenderAssignmentScalarFieldEnum[]
  }

  /**
   * ScmTenderAssignment findMany
   */
  export type ScmTenderAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ScmTenderAssignments to fetch.
     */
    where?: ScmTenderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScmTenderAssignments to fetch.
     */
    orderBy?: ScmTenderAssignmentOrderByWithRelationInput | ScmTenderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScmTenderAssignments.
     */
    cursor?: ScmTenderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScmTenderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScmTenderAssignments.
     */
    skip?: number
    distinct?: ScmTenderAssignmentScalarFieldEnum | ScmTenderAssignmentScalarFieldEnum[]
  }

  /**
   * ScmTenderAssignment create
   */
  export type ScmTenderAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ScmTenderAssignment.
     */
    data: XOR<ScmTenderAssignmentCreateInput, ScmTenderAssignmentUncheckedCreateInput>
  }

  /**
   * ScmTenderAssignment createMany
   */
  export type ScmTenderAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScmTenderAssignments.
     */
    data: ScmTenderAssignmentCreateManyInput | ScmTenderAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScmTenderAssignment createManyAndReturn
   */
  export type ScmTenderAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScmTenderAssignments.
     */
    data: ScmTenderAssignmentCreateManyInput | ScmTenderAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScmTenderAssignment update
   */
  export type ScmTenderAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ScmTenderAssignment.
     */
    data: XOR<ScmTenderAssignmentUpdateInput, ScmTenderAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ScmTenderAssignment to update.
     */
    where: ScmTenderAssignmentWhereUniqueInput
  }

  /**
   * ScmTenderAssignment updateMany
   */
  export type ScmTenderAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScmTenderAssignments.
     */
    data: XOR<ScmTenderAssignmentUpdateManyMutationInput, ScmTenderAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ScmTenderAssignments to update
     */
    where?: ScmTenderAssignmentWhereInput
  }

  /**
   * ScmTenderAssignment upsert
   */
  export type ScmTenderAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ScmTenderAssignment to update in case it exists.
     */
    where: ScmTenderAssignmentWhereUniqueInput
    /**
     * In case the ScmTenderAssignment found by the `where` argument doesn't exist, create a new ScmTenderAssignment with this data.
     */
    create: XOR<ScmTenderAssignmentCreateInput, ScmTenderAssignmentUncheckedCreateInput>
    /**
     * In case the ScmTenderAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScmTenderAssignmentUpdateInput, ScmTenderAssignmentUncheckedUpdateInput>
  }

  /**
   * ScmTenderAssignment delete
   */
  export type ScmTenderAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ScmTenderAssignment to delete.
     */
    where: ScmTenderAssignmentWhereUniqueInput
  }

  /**
   * ScmTenderAssignment deleteMany
   */
  export type ScmTenderAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScmTenderAssignments to delete
     */
    where?: ScmTenderAssignmentWhereInput
  }

  /**
   * ScmTenderAssignment without action
   */
  export type ScmTenderAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Tender
   */

  export type AggregateTender = {
    _count: TenderCountAggregateOutputType | null
    _min: TenderMinAggregateOutputType | null
    _max: TenderMaxAggregateOutputType | null
  }

  export type TenderMinAggregateOutputType = {
    id: string | null
    number: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tenantId: string | null
  }

  export type TenderMaxAggregateOutputType = {
    id: string | null
    number: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tenantId: string | null
  }

  export type TenderCountAggregateOutputType = {
    id: number
    number: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    tenantId: number
    _all: number
  }


  export type TenderMinAggregateInputType = {
    id?: true
    number?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    tenantId?: true
  }

  export type TenderMaxAggregateInputType = {
    id?: true
    number?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    tenantId?: true
  }

  export type TenderCountAggregateInputType = {
    id?: true
    number?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    tenantId?: true
    _all?: true
  }

  export type TenderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tender to aggregate.
     */
    where?: TenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenders to fetch.
     */
    orderBy?: TenderOrderByWithRelationInput | TenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenders
    **/
    _count?: true | TenderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenderMaxAggregateInputType
  }

  export type GetTenderAggregateType<T extends TenderAggregateArgs> = {
        [P in keyof T & keyof AggregateTender]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTender[P]>
      : GetScalarType<T[P], AggregateTender[P]>
  }




  export type TenderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenderWhereInput
    orderBy?: TenderOrderByWithAggregationInput | TenderOrderByWithAggregationInput[]
    by: TenderScalarFieldEnum[] | TenderScalarFieldEnum
    having?: TenderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenderCountAggregateInputType | true
    _min?: TenderMinAggregateInputType
    _max?: TenderMaxAggregateInputType
  }

  export type TenderGroupByOutputType = {
    id: string
    number: string
    description: string
    category: string | null
    createdAt: Date
    updatedAt: Date
    tenantId: string | null
    _count: TenderCountAggregateOutputType | null
    _min: TenderMinAggregateOutputType | null
    _max: TenderMaxAggregateOutputType | null
  }

  type GetTenderGroupByPayload<T extends TenderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenderGroupByOutputType[P]>
            : GetScalarType<T[P], TenderGroupByOutputType[P]>
        }
      >
    >


  export type TenderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenantId?: boolean
    bidders?: boolean | Tender$biddersArgs<ExtArgs>
    evaluationConfig?: boolean | Tender$evaluationConfigArgs<ExtArgs>
    documents?: boolean | Tender$documentsArgs<ExtArgs>
    evaluationResults?: boolean | Tender$evaluationResultsArgs<ExtArgs>
    signatures?: boolean | Tender$signaturesArgs<ExtArgs>
    scmAssignments?: boolean | Tender$scmAssignmentsArgs<ExtArgs>
    tenant?: boolean | Tender$tenantArgs<ExtArgs>
    timelineEvents?: boolean | Tender$timelineEventsArgs<ExtArgs>
    insights?: boolean | Tender$insightsArgs<ExtArgs>
    heatmap?: boolean | Tender$heatmapArgs<ExtArgs>
    complianceDashboard?: boolean | Tender$complianceDashboardArgs<ExtArgs>
    _count?: boolean | TenderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tender"]>

  export type TenderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenantId?: boolean
    tenant?: boolean | Tender$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["tender"]>

  export type TenderSelectScalar = {
    id?: boolean
    number?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenantId?: boolean
  }

  export type TenderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidders?: boolean | Tender$biddersArgs<ExtArgs>
    evaluationConfig?: boolean | Tender$evaluationConfigArgs<ExtArgs>
    documents?: boolean | Tender$documentsArgs<ExtArgs>
    evaluationResults?: boolean | Tender$evaluationResultsArgs<ExtArgs>
    signatures?: boolean | Tender$signaturesArgs<ExtArgs>
    scmAssignments?: boolean | Tender$scmAssignmentsArgs<ExtArgs>
    tenant?: boolean | Tender$tenantArgs<ExtArgs>
    timelineEvents?: boolean | Tender$timelineEventsArgs<ExtArgs>
    insights?: boolean | Tender$insightsArgs<ExtArgs>
    heatmap?: boolean | Tender$heatmapArgs<ExtArgs>
    complianceDashboard?: boolean | Tender$complianceDashboardArgs<ExtArgs>
    _count?: boolean | TenderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Tender$tenantArgs<ExtArgs>
  }

  export type $TenderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tender"
    objects: {
      bidders: Prisma.$BidderPayload<ExtArgs>[]
      evaluationConfig: Prisma.$EvaluationConfigPayload<ExtArgs> | null
      documents: Prisma.$EvaluationDocumentPayload<ExtArgs>[]
      evaluationResults: Prisma.$EvaluationResultPayload<ExtArgs>[]
      signatures: Prisma.$EvaluationSignaturePayload<ExtArgs>[]
      scmAssignments: Prisma.$ScmTenderAssignmentPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      timelineEvents: Prisma.$TenderTimelineEventPayload<ExtArgs>[]
      insights: Prisma.$TenderInsightsPayload<ExtArgs> | null
      heatmap: Prisma.$TenderHeatmapPayload<ExtArgs> | null
      complianceDashboard: Prisma.$TenderComplianceDashboardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      description: string
      category: string | null
      createdAt: Date
      updatedAt: Date
      tenantId: string | null
    }, ExtArgs["result"]["tender"]>
    composites: {}
  }

  type TenderGetPayload<S extends boolean | null | undefined | TenderDefaultArgs> = $Result.GetResult<Prisma.$TenderPayload, S>

  type TenderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenderCountAggregateInputType | true
    }

  export interface TenderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tender'], meta: { name: 'Tender' } }
    /**
     * Find zero or one Tender that matches the filter.
     * @param {TenderFindUniqueArgs} args - Arguments to find a Tender
     * @example
     * // Get one Tender
     * const tender = await prisma.tender.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenderFindUniqueArgs>(args: SelectSubset<T, TenderFindUniqueArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tender that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenderFindUniqueOrThrowArgs} args - Arguments to find a Tender
     * @example
     * // Get one Tender
     * const tender = await prisma.tender.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenderFindUniqueOrThrowArgs>(args: SelectSubset<T, TenderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tender that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderFindFirstArgs} args - Arguments to find a Tender
     * @example
     * // Get one Tender
     * const tender = await prisma.tender.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenderFindFirstArgs>(args?: SelectSubset<T, TenderFindFirstArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tender that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderFindFirstOrThrowArgs} args - Arguments to find a Tender
     * @example
     * // Get one Tender
     * const tender = await prisma.tender.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenderFindFirstOrThrowArgs>(args?: SelectSubset<T, TenderFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenders
     * const tenders = await prisma.tender.findMany()
     * 
     * // Get first 10 Tenders
     * const tenders = await prisma.tender.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenderWithIdOnly = await prisma.tender.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenderFindManyArgs>(args?: SelectSubset<T, TenderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tender.
     * @param {TenderCreateArgs} args - Arguments to create a Tender.
     * @example
     * // Create one Tender
     * const Tender = await prisma.tender.create({
     *   data: {
     *     // ... data to create a Tender
     *   }
     * })
     * 
     */
    create<T extends TenderCreateArgs>(args: SelectSubset<T, TenderCreateArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenders.
     * @param {TenderCreateManyArgs} args - Arguments to create many Tenders.
     * @example
     * // Create many Tenders
     * const tender = await prisma.tender.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenderCreateManyArgs>(args?: SelectSubset<T, TenderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenders and returns the data saved in the database.
     * @param {TenderCreateManyAndReturnArgs} args - Arguments to create many Tenders.
     * @example
     * // Create many Tenders
     * const tender = await prisma.tender.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenders and only return the `id`
     * const tenderWithIdOnly = await prisma.tender.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenderCreateManyAndReturnArgs>(args?: SelectSubset<T, TenderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tender.
     * @param {TenderDeleteArgs} args - Arguments to delete one Tender.
     * @example
     * // Delete one Tender
     * const Tender = await prisma.tender.delete({
     *   where: {
     *     // ... filter to delete one Tender
     *   }
     * })
     * 
     */
    delete<T extends TenderDeleteArgs>(args: SelectSubset<T, TenderDeleteArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tender.
     * @param {TenderUpdateArgs} args - Arguments to update one Tender.
     * @example
     * // Update one Tender
     * const tender = await prisma.tender.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenderUpdateArgs>(args: SelectSubset<T, TenderUpdateArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenders.
     * @param {TenderDeleteManyArgs} args - Arguments to filter Tenders to delete.
     * @example
     * // Delete a few Tenders
     * const { count } = await prisma.tender.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenderDeleteManyArgs>(args?: SelectSubset<T, TenderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenders
     * const tender = await prisma.tender.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenderUpdateManyArgs>(args: SelectSubset<T, TenderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tender.
     * @param {TenderUpsertArgs} args - Arguments to update or create a Tender.
     * @example
     * // Update or create a Tender
     * const tender = await prisma.tender.upsert({
     *   create: {
     *     // ... data to create a Tender
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tender we want to update
     *   }
     * })
     */
    upsert<T extends TenderUpsertArgs>(args: SelectSubset<T, TenderUpsertArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderCountArgs} args - Arguments to filter Tenders to count.
     * @example
     * // Count the number of Tenders
     * const count = await prisma.tender.count({
     *   where: {
     *     // ... the filter for the Tenders we want to count
     *   }
     * })
    **/
    count<T extends TenderCountArgs>(
      args?: Subset<T, TenderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenderAggregateArgs>(args: Subset<T, TenderAggregateArgs>): Prisma.PrismaPromise<GetTenderAggregateType<T>>

    /**
     * Group by Tender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenderGroupByArgs['orderBy'] }
        : { orderBy?: TenderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tender model
   */
  readonly fields: TenderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tender.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bidders<T extends Tender$biddersArgs<ExtArgs> = {}>(args?: Subset<T, Tender$biddersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findMany"> | Null>
    evaluationConfig<T extends Tender$evaluationConfigArgs<ExtArgs> = {}>(args?: Subset<T, Tender$evaluationConfigArgs<ExtArgs>>): Prisma__EvaluationConfigClient<$Result.GetResult<Prisma.$EvaluationConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    documents<T extends Tender$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Tender$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    evaluationResults<T extends Tender$evaluationResultsArgs<ExtArgs> = {}>(args?: Subset<T, Tender$evaluationResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "findMany"> | Null>
    signatures<T extends Tender$signaturesArgs<ExtArgs> = {}>(args?: Subset<T, Tender$signaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationSignaturePayload<ExtArgs>, T, "findMany"> | Null>
    scmAssignments<T extends Tender$scmAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Tender$scmAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScmTenderAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    tenant<T extends Tender$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Tender$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    timelineEvents<T extends Tender$timelineEventsArgs<ExtArgs> = {}>(args?: Subset<T, Tender$timelineEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderTimelineEventPayload<ExtArgs>, T, "findMany"> | Null>
    insights<T extends Tender$insightsArgs<ExtArgs> = {}>(args?: Subset<T, Tender$insightsArgs<ExtArgs>>): Prisma__TenderInsightsClient<$Result.GetResult<Prisma.$TenderInsightsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    heatmap<T extends Tender$heatmapArgs<ExtArgs> = {}>(args?: Subset<T, Tender$heatmapArgs<ExtArgs>>): Prisma__TenderHeatmapClient<$Result.GetResult<Prisma.$TenderHeatmapPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    complianceDashboard<T extends Tender$complianceDashboardArgs<ExtArgs> = {}>(args?: Subset<T, Tender$complianceDashboardArgs<ExtArgs>>): Prisma__TenderComplianceDashboardClient<$Result.GetResult<Prisma.$TenderComplianceDashboardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tender model
   */ 
  interface TenderFieldRefs {
    readonly id: FieldRef<"Tender", 'String'>
    readonly number: FieldRef<"Tender", 'String'>
    readonly description: FieldRef<"Tender", 'String'>
    readonly category: FieldRef<"Tender", 'String'>
    readonly createdAt: FieldRef<"Tender", 'DateTime'>
    readonly updatedAt: FieldRef<"Tender", 'DateTime'>
    readonly tenantId: FieldRef<"Tender", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tender findUnique
   */
  export type TenderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInclude<ExtArgs> | null
    /**
     * Filter, which Tender to fetch.
     */
    where: TenderWhereUniqueInput
  }

  /**
   * Tender findUniqueOrThrow
   */
  export type TenderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInclude<ExtArgs> | null
    /**
     * Filter, which Tender to fetch.
     */
    where: TenderWhereUniqueInput
  }

  /**
   * Tender findFirst
   */
  export type TenderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInclude<ExtArgs> | null
    /**
     * Filter, which Tender to fetch.
     */
    where?: TenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenders to fetch.
     */
    orderBy?: TenderOrderByWithRelationInput | TenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenders.
     */
    cursor?: TenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenders.
     */
    distinct?: TenderScalarFieldEnum | TenderScalarFieldEnum[]
  }

  /**
   * Tender findFirstOrThrow
   */
  export type TenderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInclude<ExtArgs> | null
    /**
     * Filter, which Tender to fetch.
     */
    where?: TenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenders to fetch.
     */
    orderBy?: TenderOrderByWithRelationInput | TenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenders.
     */
    cursor?: TenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenders.
     */
    distinct?: TenderScalarFieldEnum | TenderScalarFieldEnum[]
  }

  /**
   * Tender findMany
   */
  export type TenderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInclude<ExtArgs> | null
    /**
     * Filter, which Tenders to fetch.
     */
    where?: TenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenders to fetch.
     */
    orderBy?: TenderOrderByWithRelationInput | TenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenders.
     */
    cursor?: TenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenders.
     */
    skip?: number
    distinct?: TenderScalarFieldEnum | TenderScalarFieldEnum[]
  }

  /**
   * Tender create
   */
  export type TenderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInclude<ExtArgs> | null
    /**
     * The data needed to create a Tender.
     */
    data: XOR<TenderCreateInput, TenderUncheckedCreateInput>
  }

  /**
   * Tender createMany
   */
  export type TenderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenders.
     */
    data: TenderCreateManyInput | TenderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tender createManyAndReturn
   */
  export type TenderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenders.
     */
    data: TenderCreateManyInput | TenderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tender update
   */
  export type TenderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInclude<ExtArgs> | null
    /**
     * The data needed to update a Tender.
     */
    data: XOR<TenderUpdateInput, TenderUncheckedUpdateInput>
    /**
     * Choose, which Tender to update.
     */
    where: TenderWhereUniqueInput
  }

  /**
   * Tender updateMany
   */
  export type TenderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenders.
     */
    data: XOR<TenderUpdateManyMutationInput, TenderUncheckedUpdateManyInput>
    /**
     * Filter which Tenders to update
     */
    where?: TenderWhereInput
  }

  /**
   * Tender upsert
   */
  export type TenderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInclude<ExtArgs> | null
    /**
     * The filter to search for the Tender to update in case it exists.
     */
    where: TenderWhereUniqueInput
    /**
     * In case the Tender found by the `where` argument doesn't exist, create a new Tender with this data.
     */
    create: XOR<TenderCreateInput, TenderUncheckedCreateInput>
    /**
     * In case the Tender was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenderUpdateInput, TenderUncheckedUpdateInput>
  }

  /**
   * Tender delete
   */
  export type TenderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInclude<ExtArgs> | null
    /**
     * Filter which Tender to delete.
     */
    where: TenderWhereUniqueInput
  }

  /**
   * Tender deleteMany
   */
  export type TenderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenders to delete
     */
    where?: TenderWhereInput
  }

  /**
   * Tender.bidders
   */
  export type Tender$biddersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderInclude<ExtArgs> | null
    where?: BidderWhereInput
    orderBy?: BidderOrderByWithRelationInput | BidderOrderByWithRelationInput[]
    cursor?: BidderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidderScalarFieldEnum | BidderScalarFieldEnum[]
  }

  /**
   * Tender.evaluationConfig
   */
  export type Tender$evaluationConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigInclude<ExtArgs> | null
    where?: EvaluationConfigWhereInput
  }

  /**
   * Tender.documents
   */
  export type Tender$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentInclude<ExtArgs> | null
    where?: EvaluationDocumentWhereInput
    orderBy?: EvaluationDocumentOrderByWithRelationInput | EvaluationDocumentOrderByWithRelationInput[]
    cursor?: EvaluationDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationDocumentScalarFieldEnum | EvaluationDocumentScalarFieldEnum[]
  }

  /**
   * Tender.evaluationResults
   */
  export type Tender$evaluationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
    where?: EvaluationResultWhereInput
    orderBy?: EvaluationResultOrderByWithRelationInput | EvaluationResultOrderByWithRelationInput[]
    cursor?: EvaluationResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationResultScalarFieldEnum | EvaluationResultScalarFieldEnum[]
  }

  /**
   * Tender.signatures
   */
  export type Tender$signaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureInclude<ExtArgs> | null
    where?: EvaluationSignatureWhereInput
    orderBy?: EvaluationSignatureOrderByWithRelationInput | EvaluationSignatureOrderByWithRelationInput[]
    cursor?: EvaluationSignatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationSignatureScalarFieldEnum | EvaluationSignatureScalarFieldEnum[]
  }

  /**
   * Tender.scmAssignments
   */
  export type Tender$scmAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScmTenderAssignment
     */
    select?: ScmTenderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScmTenderAssignmentInclude<ExtArgs> | null
    where?: ScmTenderAssignmentWhereInput
    orderBy?: ScmTenderAssignmentOrderByWithRelationInput | ScmTenderAssignmentOrderByWithRelationInput[]
    cursor?: ScmTenderAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScmTenderAssignmentScalarFieldEnum | ScmTenderAssignmentScalarFieldEnum[]
  }

  /**
   * Tender.tenant
   */
  export type Tender$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Tender.timelineEvents
   */
  export type Tender$timelineEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventInclude<ExtArgs> | null
    where?: TenderTimelineEventWhereInput
    orderBy?: TenderTimelineEventOrderByWithRelationInput | TenderTimelineEventOrderByWithRelationInput[]
    cursor?: TenderTimelineEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenderTimelineEventScalarFieldEnum | TenderTimelineEventScalarFieldEnum[]
  }

  /**
   * Tender.insights
   */
  export type Tender$insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsInclude<ExtArgs> | null
    where?: TenderInsightsWhereInput
  }

  /**
   * Tender.heatmap
   */
  export type Tender$heatmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapInclude<ExtArgs> | null
    where?: TenderHeatmapWhereInput
  }

  /**
   * Tender.complianceDashboard
   */
  export type Tender$complianceDashboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardInclude<ExtArgs> | null
    where?: TenderComplianceDashboardWhereInput
  }

  /**
   * Tender without action
   */
  export type TenderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tender
     */
    select?: TenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInclude<ExtArgs> | null
  }


  /**
   * Model Bidder
   */

  export type AggregateBidder = {
    _count: BidderCountAggregateOutputType | null
    _avg: BidderAvgAggregateOutputType | null
    _sum: BidderSumAggregateOutputType | null
    _min: BidderMinAggregateOutputType | null
    _max: BidderMaxAggregateOutputType | null
  }

  export type BidderAvgAggregateOutputType = {
    price: number | null
  }

  export type BidderSumAggregateOutputType = {
    price: number | null
  }

  export type BidderMinAggregateOutputType = {
    id: string | null
    tenderId: string | null
    name: string | null
    price: number | null
    disqualified: boolean | null
    disqualificationReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidderMaxAggregateOutputType = {
    id: string | null
    tenderId: string | null
    name: string | null
    price: number | null
    disqualified: boolean | null
    disqualificationReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidderCountAggregateOutputType = {
    id: number
    tenderId: number
    name: number
    price: number
    disqualified: number
    disqualificationReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BidderAvgAggregateInputType = {
    price?: true
  }

  export type BidderSumAggregateInputType = {
    price?: true
  }

  export type BidderMinAggregateInputType = {
    id?: true
    tenderId?: true
    name?: true
    price?: true
    disqualified?: true
    disqualificationReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidderMaxAggregateInputType = {
    id?: true
    tenderId?: true
    name?: true
    price?: true
    disqualified?: true
    disqualificationReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidderCountAggregateInputType = {
    id?: true
    tenderId?: true
    name?: true
    price?: true
    disqualified?: true
    disqualificationReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BidderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bidder to aggregate.
     */
    where?: BidderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bidders to fetch.
     */
    orderBy?: BidderOrderByWithRelationInput | BidderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bidders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bidders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bidders
    **/
    _count?: true | BidderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BidderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BidderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidderMaxAggregateInputType
  }

  export type GetBidderAggregateType<T extends BidderAggregateArgs> = {
        [P in keyof T & keyof AggregateBidder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBidder[P]>
      : GetScalarType<T[P], AggregateBidder[P]>
  }




  export type BidderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidderWhereInput
    orderBy?: BidderOrderByWithAggregationInput | BidderOrderByWithAggregationInput[]
    by: BidderScalarFieldEnum[] | BidderScalarFieldEnum
    having?: BidderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidderCountAggregateInputType | true
    _avg?: BidderAvgAggregateInputType
    _sum?: BidderSumAggregateInputType
    _min?: BidderMinAggregateInputType
    _max?: BidderMaxAggregateInputType
  }

  export type BidderGroupByOutputType = {
    id: string
    tenderId: string
    name: string
    price: number | null
    disqualified: boolean
    disqualificationReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: BidderCountAggregateOutputType | null
    _avg: BidderAvgAggregateOutputType | null
    _sum: BidderSumAggregateOutputType | null
    _min: BidderMinAggregateOutputType | null
    _max: BidderMaxAggregateOutputType | null
  }

  type GetBidderGroupByPayload<T extends BidderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BidderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidderGroupByOutputType[P]>
            : GetScalarType<T[P], BidderGroupByOutputType[P]>
        }
      >
    >


  export type BidderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    name?: boolean
    price?: boolean
    disqualified?: boolean
    disqualificationReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bbbee?: boolean | Bidder$bbbeeArgs<ExtArgs>
    tender?: boolean | TenderDefaultArgs<ExtArgs>
    technicalScores?: boolean | Bidder$technicalScoresArgs<ExtArgs>
    evaluationResults?: boolean | Bidder$evaluationResultsArgs<ExtArgs>
    evidence?: boolean | Bidder$evidenceArgs<ExtArgs>
    intelligence?: boolean | Bidder$intelligenceArgs<ExtArgs>
    riskProfile?: boolean | Bidder$riskProfileArgs<ExtArgs>
    _count?: boolean | BidderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bidder"]>

  export type BidderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    name?: boolean
    price?: boolean
    disqualified?: boolean
    disqualificationReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bidder"]>

  export type BidderSelectScalar = {
    id?: boolean
    tenderId?: boolean
    name?: boolean
    price?: boolean
    disqualified?: boolean
    disqualificationReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BidderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bbbee?: boolean | Bidder$bbbeeArgs<ExtArgs>
    tender?: boolean | TenderDefaultArgs<ExtArgs>
    technicalScores?: boolean | Bidder$technicalScoresArgs<ExtArgs>
    evaluationResults?: boolean | Bidder$evaluationResultsArgs<ExtArgs>
    evidence?: boolean | Bidder$evidenceArgs<ExtArgs>
    intelligence?: boolean | Bidder$intelligenceArgs<ExtArgs>
    riskProfile?: boolean | Bidder$riskProfileArgs<ExtArgs>
    _count?: boolean | BidderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BidderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }

  export type $BidderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bidder"
    objects: {
      bbbee: Prisma.$BbbeePayload<ExtArgs> | null
      tender: Prisma.$TenderPayload<ExtArgs>
      technicalScores: Prisma.$BidderCriterionScorePayload<ExtArgs>[]
      evaluationResults: Prisma.$EvaluationResultPayload<ExtArgs>[]
      evidence: Prisma.$EvidencePayload<ExtArgs>[]
      intelligence: Prisma.$BidderIntelligencePayload<ExtArgs> | null
      riskProfile: Prisma.$BidderRiskProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenderId: string
      name: string
      price: number | null
      disqualified: boolean
      disqualificationReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bidder"]>
    composites: {}
  }

  type BidderGetPayload<S extends boolean | null | undefined | BidderDefaultArgs> = $Result.GetResult<Prisma.$BidderPayload, S>

  type BidderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BidderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BidderCountAggregateInputType | true
    }

  export interface BidderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bidder'], meta: { name: 'Bidder' } }
    /**
     * Find zero or one Bidder that matches the filter.
     * @param {BidderFindUniqueArgs} args - Arguments to find a Bidder
     * @example
     * // Get one Bidder
     * const bidder = await prisma.bidder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BidderFindUniqueArgs>(args: SelectSubset<T, BidderFindUniqueArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bidder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BidderFindUniqueOrThrowArgs} args - Arguments to find a Bidder
     * @example
     * // Get one Bidder
     * const bidder = await prisma.bidder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BidderFindUniqueOrThrowArgs>(args: SelectSubset<T, BidderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bidder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderFindFirstArgs} args - Arguments to find a Bidder
     * @example
     * // Get one Bidder
     * const bidder = await prisma.bidder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BidderFindFirstArgs>(args?: SelectSubset<T, BidderFindFirstArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bidder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderFindFirstOrThrowArgs} args - Arguments to find a Bidder
     * @example
     * // Get one Bidder
     * const bidder = await prisma.bidder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BidderFindFirstOrThrowArgs>(args?: SelectSubset<T, BidderFindFirstOrThrowArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bidders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bidders
     * const bidders = await prisma.bidder.findMany()
     * 
     * // Get first 10 Bidders
     * const bidders = await prisma.bidder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bidderWithIdOnly = await prisma.bidder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BidderFindManyArgs>(args?: SelectSubset<T, BidderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bidder.
     * @param {BidderCreateArgs} args - Arguments to create a Bidder.
     * @example
     * // Create one Bidder
     * const Bidder = await prisma.bidder.create({
     *   data: {
     *     // ... data to create a Bidder
     *   }
     * })
     * 
     */
    create<T extends BidderCreateArgs>(args: SelectSubset<T, BidderCreateArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bidders.
     * @param {BidderCreateManyArgs} args - Arguments to create many Bidders.
     * @example
     * // Create many Bidders
     * const bidder = await prisma.bidder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BidderCreateManyArgs>(args?: SelectSubset<T, BidderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bidders and returns the data saved in the database.
     * @param {BidderCreateManyAndReturnArgs} args - Arguments to create many Bidders.
     * @example
     * // Create many Bidders
     * const bidder = await prisma.bidder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bidders and only return the `id`
     * const bidderWithIdOnly = await prisma.bidder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BidderCreateManyAndReturnArgs>(args?: SelectSubset<T, BidderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bidder.
     * @param {BidderDeleteArgs} args - Arguments to delete one Bidder.
     * @example
     * // Delete one Bidder
     * const Bidder = await prisma.bidder.delete({
     *   where: {
     *     // ... filter to delete one Bidder
     *   }
     * })
     * 
     */
    delete<T extends BidderDeleteArgs>(args: SelectSubset<T, BidderDeleteArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bidder.
     * @param {BidderUpdateArgs} args - Arguments to update one Bidder.
     * @example
     * // Update one Bidder
     * const bidder = await prisma.bidder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BidderUpdateArgs>(args: SelectSubset<T, BidderUpdateArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bidders.
     * @param {BidderDeleteManyArgs} args - Arguments to filter Bidders to delete.
     * @example
     * // Delete a few Bidders
     * const { count } = await prisma.bidder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BidderDeleteManyArgs>(args?: SelectSubset<T, BidderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bidders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bidders
     * const bidder = await prisma.bidder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BidderUpdateManyArgs>(args: SelectSubset<T, BidderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bidder.
     * @param {BidderUpsertArgs} args - Arguments to update or create a Bidder.
     * @example
     * // Update or create a Bidder
     * const bidder = await prisma.bidder.upsert({
     *   create: {
     *     // ... data to create a Bidder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bidder we want to update
     *   }
     * })
     */
    upsert<T extends BidderUpsertArgs>(args: SelectSubset<T, BidderUpsertArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bidders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderCountArgs} args - Arguments to filter Bidders to count.
     * @example
     * // Count the number of Bidders
     * const count = await prisma.bidder.count({
     *   where: {
     *     // ... the filter for the Bidders we want to count
     *   }
     * })
    **/
    count<T extends BidderCountArgs>(
      args?: Subset<T, BidderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bidder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidderAggregateArgs>(args: Subset<T, BidderAggregateArgs>): Prisma.PrismaPromise<GetBidderAggregateType<T>>

    /**
     * Group by Bidder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidderGroupByArgs['orderBy'] }
        : { orderBy?: BidderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bidder model
   */
  readonly fields: BidderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bidder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BidderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bbbee<T extends Bidder$bbbeeArgs<ExtArgs> = {}>(args?: Subset<T, Bidder$bbbeeArgs<ExtArgs>>): Prisma__BbbeeClient<$Result.GetResult<Prisma.$BbbeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tender<T extends TenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenderDefaultArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    technicalScores<T extends Bidder$technicalScoresArgs<ExtArgs> = {}>(args?: Subset<T, Bidder$technicalScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidderCriterionScorePayload<ExtArgs>, T, "findMany"> | Null>
    evaluationResults<T extends Bidder$evaluationResultsArgs<ExtArgs> = {}>(args?: Subset<T, Bidder$evaluationResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "findMany"> | Null>
    evidence<T extends Bidder$evidenceArgs<ExtArgs> = {}>(args?: Subset<T, Bidder$evidenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findMany"> | Null>
    intelligence<T extends Bidder$intelligenceArgs<ExtArgs> = {}>(args?: Subset<T, Bidder$intelligenceArgs<ExtArgs>>): Prisma__BidderIntelligenceClient<$Result.GetResult<Prisma.$BidderIntelligencePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    riskProfile<T extends Bidder$riskProfileArgs<ExtArgs> = {}>(args?: Subset<T, Bidder$riskProfileArgs<ExtArgs>>): Prisma__BidderRiskProfileClient<$Result.GetResult<Prisma.$BidderRiskProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bidder model
   */ 
  interface BidderFieldRefs {
    readonly id: FieldRef<"Bidder", 'String'>
    readonly tenderId: FieldRef<"Bidder", 'String'>
    readonly name: FieldRef<"Bidder", 'String'>
    readonly price: FieldRef<"Bidder", 'Float'>
    readonly disqualified: FieldRef<"Bidder", 'Boolean'>
    readonly disqualificationReason: FieldRef<"Bidder", 'String'>
    readonly createdAt: FieldRef<"Bidder", 'DateTime'>
    readonly updatedAt: FieldRef<"Bidder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bidder findUnique
   */
  export type BidderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderInclude<ExtArgs> | null
    /**
     * Filter, which Bidder to fetch.
     */
    where: BidderWhereUniqueInput
  }

  /**
   * Bidder findUniqueOrThrow
   */
  export type BidderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderInclude<ExtArgs> | null
    /**
     * Filter, which Bidder to fetch.
     */
    where: BidderWhereUniqueInput
  }

  /**
   * Bidder findFirst
   */
  export type BidderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderInclude<ExtArgs> | null
    /**
     * Filter, which Bidder to fetch.
     */
    where?: BidderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bidders to fetch.
     */
    orderBy?: BidderOrderByWithRelationInput | BidderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bidders.
     */
    cursor?: BidderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bidders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bidders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bidders.
     */
    distinct?: BidderScalarFieldEnum | BidderScalarFieldEnum[]
  }

  /**
   * Bidder findFirstOrThrow
   */
  export type BidderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderInclude<ExtArgs> | null
    /**
     * Filter, which Bidder to fetch.
     */
    where?: BidderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bidders to fetch.
     */
    orderBy?: BidderOrderByWithRelationInput | BidderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bidders.
     */
    cursor?: BidderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bidders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bidders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bidders.
     */
    distinct?: BidderScalarFieldEnum | BidderScalarFieldEnum[]
  }

  /**
   * Bidder findMany
   */
  export type BidderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderInclude<ExtArgs> | null
    /**
     * Filter, which Bidders to fetch.
     */
    where?: BidderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bidders to fetch.
     */
    orderBy?: BidderOrderByWithRelationInput | BidderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bidders.
     */
    cursor?: BidderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bidders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bidders.
     */
    skip?: number
    distinct?: BidderScalarFieldEnum | BidderScalarFieldEnum[]
  }

  /**
   * Bidder create
   */
  export type BidderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderInclude<ExtArgs> | null
    /**
     * The data needed to create a Bidder.
     */
    data: XOR<BidderCreateInput, BidderUncheckedCreateInput>
  }

  /**
   * Bidder createMany
   */
  export type BidderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bidders.
     */
    data: BidderCreateManyInput | BidderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bidder createManyAndReturn
   */
  export type BidderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bidders.
     */
    data: BidderCreateManyInput | BidderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bidder update
   */
  export type BidderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderInclude<ExtArgs> | null
    /**
     * The data needed to update a Bidder.
     */
    data: XOR<BidderUpdateInput, BidderUncheckedUpdateInput>
    /**
     * Choose, which Bidder to update.
     */
    where: BidderWhereUniqueInput
  }

  /**
   * Bidder updateMany
   */
  export type BidderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bidders.
     */
    data: XOR<BidderUpdateManyMutationInput, BidderUncheckedUpdateManyInput>
    /**
     * Filter which Bidders to update
     */
    where?: BidderWhereInput
  }

  /**
   * Bidder upsert
   */
  export type BidderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderInclude<ExtArgs> | null
    /**
     * The filter to search for the Bidder to update in case it exists.
     */
    where: BidderWhereUniqueInput
    /**
     * In case the Bidder found by the `where` argument doesn't exist, create a new Bidder with this data.
     */
    create: XOR<BidderCreateInput, BidderUncheckedCreateInput>
    /**
     * In case the Bidder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidderUpdateInput, BidderUncheckedUpdateInput>
  }

  /**
   * Bidder delete
   */
  export type BidderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderInclude<ExtArgs> | null
    /**
     * Filter which Bidder to delete.
     */
    where: BidderWhereUniqueInput
  }

  /**
   * Bidder deleteMany
   */
  export type BidderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bidders to delete
     */
    where?: BidderWhereInput
  }

  /**
   * Bidder.bbbee
   */
  export type Bidder$bbbeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeInclude<ExtArgs> | null
    where?: BbbeeWhereInput
  }

  /**
   * Bidder.technicalScores
   */
  export type Bidder$technicalScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreInclude<ExtArgs> | null
    where?: BidderCriterionScoreWhereInput
    orderBy?: BidderCriterionScoreOrderByWithRelationInput | BidderCriterionScoreOrderByWithRelationInput[]
    cursor?: BidderCriterionScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidderCriterionScoreScalarFieldEnum | BidderCriterionScoreScalarFieldEnum[]
  }

  /**
   * Bidder.evaluationResults
   */
  export type Bidder$evaluationResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
    where?: EvaluationResultWhereInput
    orderBy?: EvaluationResultOrderByWithRelationInput | EvaluationResultOrderByWithRelationInput[]
    cursor?: EvaluationResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationResultScalarFieldEnum | EvaluationResultScalarFieldEnum[]
  }

  /**
   * Bidder.evidence
   */
  export type Bidder$evidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    where?: EvidenceWhereInput
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    cursor?: EvidenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Bidder.intelligence
   */
  export type Bidder$intelligenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceInclude<ExtArgs> | null
    where?: BidderIntelligenceWhereInput
  }

  /**
   * Bidder.riskProfile
   */
  export type Bidder$riskProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileInclude<ExtArgs> | null
    where?: BidderRiskProfileWhereInput
  }

  /**
   * Bidder without action
   */
  export type BidderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bidder
     */
    select?: BidderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderInclude<ExtArgs> | null
  }


  /**
   * Model Bbbee
   */

  export type AggregateBbbee = {
    _count: BbbeeCountAggregateOutputType | null
    _avg: BbbeeAvgAggregateOutputType | null
    _sum: BbbeeSumAggregateOutputType | null
    _min: BbbeeMinAggregateOutputType | null
    _max: BbbeeMaxAggregateOutputType | null
  }

  export type BbbeeAvgAggregateOutputType = {
    level: number | null
  }

  export type BbbeeSumAggregateOutputType = {
    level: number | null
  }

  export type BbbeeMinAggregateOutputType = {
    id: string | null
    bidderId: string | null
    level: number | null
    expiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BbbeeMaxAggregateOutputType = {
    id: string | null
    bidderId: string | null
    level: number | null
    expiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BbbeeCountAggregateOutputType = {
    id: number
    bidderId: number
    level: number
    expiry: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BbbeeAvgAggregateInputType = {
    level?: true
  }

  export type BbbeeSumAggregateInputType = {
    level?: true
  }

  export type BbbeeMinAggregateInputType = {
    id?: true
    bidderId?: true
    level?: true
    expiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BbbeeMaxAggregateInputType = {
    id?: true
    bidderId?: true
    level?: true
    expiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BbbeeCountAggregateInputType = {
    id?: true
    bidderId?: true
    level?: true
    expiry?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BbbeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bbbee to aggregate.
     */
    where?: BbbeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bbbees to fetch.
     */
    orderBy?: BbbeeOrderByWithRelationInput | BbbeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BbbeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bbbees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bbbees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bbbees
    **/
    _count?: true | BbbeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BbbeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BbbeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BbbeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BbbeeMaxAggregateInputType
  }

  export type GetBbbeeAggregateType<T extends BbbeeAggregateArgs> = {
        [P in keyof T & keyof AggregateBbbee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBbbee[P]>
      : GetScalarType<T[P], AggregateBbbee[P]>
  }




  export type BbbeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BbbeeWhereInput
    orderBy?: BbbeeOrderByWithAggregationInput | BbbeeOrderByWithAggregationInput[]
    by: BbbeeScalarFieldEnum[] | BbbeeScalarFieldEnum
    having?: BbbeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BbbeeCountAggregateInputType | true
    _avg?: BbbeeAvgAggregateInputType
    _sum?: BbbeeSumAggregateInputType
    _min?: BbbeeMinAggregateInputType
    _max?: BbbeeMaxAggregateInputType
  }

  export type BbbeeGroupByOutputType = {
    id: string
    bidderId: string
    level: number | null
    expiry: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BbbeeCountAggregateOutputType | null
    _avg: BbbeeAvgAggregateOutputType | null
    _sum: BbbeeSumAggregateOutputType | null
    _min: BbbeeMinAggregateOutputType | null
    _max: BbbeeMaxAggregateOutputType | null
  }

  type GetBbbeeGroupByPayload<T extends BbbeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BbbeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BbbeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BbbeeGroupByOutputType[P]>
            : GetScalarType<T[P], BbbeeGroupByOutputType[P]>
        }
      >
    >


  export type BbbeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bidderId?: boolean
    level?: boolean
    expiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bbbee"]>

  export type BbbeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bidderId?: boolean
    level?: boolean
    expiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bbbee"]>

  export type BbbeeSelectScalar = {
    id?: boolean
    bidderId?: boolean
    level?: boolean
    expiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BbbeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }
  export type BbbeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }

  export type $BbbeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bbbee"
    objects: {
      bidder: Prisma.$BidderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bidderId: string
      level: number | null
      expiry: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bbbee"]>
    composites: {}
  }

  type BbbeeGetPayload<S extends boolean | null | undefined | BbbeeDefaultArgs> = $Result.GetResult<Prisma.$BbbeePayload, S>

  type BbbeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BbbeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BbbeeCountAggregateInputType | true
    }

  export interface BbbeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bbbee'], meta: { name: 'Bbbee' } }
    /**
     * Find zero or one Bbbee that matches the filter.
     * @param {BbbeeFindUniqueArgs} args - Arguments to find a Bbbee
     * @example
     * // Get one Bbbee
     * const bbbee = await prisma.bbbee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BbbeeFindUniqueArgs>(args: SelectSubset<T, BbbeeFindUniqueArgs<ExtArgs>>): Prisma__BbbeeClient<$Result.GetResult<Prisma.$BbbeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bbbee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BbbeeFindUniqueOrThrowArgs} args - Arguments to find a Bbbee
     * @example
     * // Get one Bbbee
     * const bbbee = await prisma.bbbee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BbbeeFindUniqueOrThrowArgs>(args: SelectSubset<T, BbbeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BbbeeClient<$Result.GetResult<Prisma.$BbbeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bbbee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BbbeeFindFirstArgs} args - Arguments to find a Bbbee
     * @example
     * // Get one Bbbee
     * const bbbee = await prisma.bbbee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BbbeeFindFirstArgs>(args?: SelectSubset<T, BbbeeFindFirstArgs<ExtArgs>>): Prisma__BbbeeClient<$Result.GetResult<Prisma.$BbbeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bbbee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BbbeeFindFirstOrThrowArgs} args - Arguments to find a Bbbee
     * @example
     * // Get one Bbbee
     * const bbbee = await prisma.bbbee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BbbeeFindFirstOrThrowArgs>(args?: SelectSubset<T, BbbeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BbbeeClient<$Result.GetResult<Prisma.$BbbeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bbbees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BbbeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bbbees
     * const bbbees = await prisma.bbbee.findMany()
     * 
     * // Get first 10 Bbbees
     * const bbbees = await prisma.bbbee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bbbeeWithIdOnly = await prisma.bbbee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BbbeeFindManyArgs>(args?: SelectSubset<T, BbbeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BbbeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bbbee.
     * @param {BbbeeCreateArgs} args - Arguments to create a Bbbee.
     * @example
     * // Create one Bbbee
     * const Bbbee = await prisma.bbbee.create({
     *   data: {
     *     // ... data to create a Bbbee
     *   }
     * })
     * 
     */
    create<T extends BbbeeCreateArgs>(args: SelectSubset<T, BbbeeCreateArgs<ExtArgs>>): Prisma__BbbeeClient<$Result.GetResult<Prisma.$BbbeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bbbees.
     * @param {BbbeeCreateManyArgs} args - Arguments to create many Bbbees.
     * @example
     * // Create many Bbbees
     * const bbbee = await prisma.bbbee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BbbeeCreateManyArgs>(args?: SelectSubset<T, BbbeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bbbees and returns the data saved in the database.
     * @param {BbbeeCreateManyAndReturnArgs} args - Arguments to create many Bbbees.
     * @example
     * // Create many Bbbees
     * const bbbee = await prisma.bbbee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bbbees and only return the `id`
     * const bbbeeWithIdOnly = await prisma.bbbee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BbbeeCreateManyAndReturnArgs>(args?: SelectSubset<T, BbbeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BbbeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bbbee.
     * @param {BbbeeDeleteArgs} args - Arguments to delete one Bbbee.
     * @example
     * // Delete one Bbbee
     * const Bbbee = await prisma.bbbee.delete({
     *   where: {
     *     // ... filter to delete one Bbbee
     *   }
     * })
     * 
     */
    delete<T extends BbbeeDeleteArgs>(args: SelectSubset<T, BbbeeDeleteArgs<ExtArgs>>): Prisma__BbbeeClient<$Result.GetResult<Prisma.$BbbeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bbbee.
     * @param {BbbeeUpdateArgs} args - Arguments to update one Bbbee.
     * @example
     * // Update one Bbbee
     * const bbbee = await prisma.bbbee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BbbeeUpdateArgs>(args: SelectSubset<T, BbbeeUpdateArgs<ExtArgs>>): Prisma__BbbeeClient<$Result.GetResult<Prisma.$BbbeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bbbees.
     * @param {BbbeeDeleteManyArgs} args - Arguments to filter Bbbees to delete.
     * @example
     * // Delete a few Bbbees
     * const { count } = await prisma.bbbee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BbbeeDeleteManyArgs>(args?: SelectSubset<T, BbbeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bbbees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BbbeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bbbees
     * const bbbee = await prisma.bbbee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BbbeeUpdateManyArgs>(args: SelectSubset<T, BbbeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bbbee.
     * @param {BbbeeUpsertArgs} args - Arguments to update or create a Bbbee.
     * @example
     * // Update or create a Bbbee
     * const bbbee = await prisma.bbbee.upsert({
     *   create: {
     *     // ... data to create a Bbbee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bbbee we want to update
     *   }
     * })
     */
    upsert<T extends BbbeeUpsertArgs>(args: SelectSubset<T, BbbeeUpsertArgs<ExtArgs>>): Prisma__BbbeeClient<$Result.GetResult<Prisma.$BbbeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bbbees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BbbeeCountArgs} args - Arguments to filter Bbbees to count.
     * @example
     * // Count the number of Bbbees
     * const count = await prisma.bbbee.count({
     *   where: {
     *     // ... the filter for the Bbbees we want to count
     *   }
     * })
    **/
    count<T extends BbbeeCountArgs>(
      args?: Subset<T, BbbeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BbbeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bbbee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BbbeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BbbeeAggregateArgs>(args: Subset<T, BbbeeAggregateArgs>): Prisma.PrismaPromise<GetBbbeeAggregateType<T>>

    /**
     * Group by Bbbee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BbbeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BbbeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BbbeeGroupByArgs['orderBy'] }
        : { orderBy?: BbbeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BbbeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBbbeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bbbee model
   */
  readonly fields: BbbeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bbbee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BbbeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bidder<T extends BidderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BidderDefaultArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bbbee model
   */ 
  interface BbbeeFieldRefs {
    readonly id: FieldRef<"Bbbee", 'String'>
    readonly bidderId: FieldRef<"Bbbee", 'String'>
    readonly level: FieldRef<"Bbbee", 'Int'>
    readonly expiry: FieldRef<"Bbbee", 'DateTime'>
    readonly createdAt: FieldRef<"Bbbee", 'DateTime'>
    readonly updatedAt: FieldRef<"Bbbee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bbbee findUnique
   */
  export type BbbeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeInclude<ExtArgs> | null
    /**
     * Filter, which Bbbee to fetch.
     */
    where: BbbeeWhereUniqueInput
  }

  /**
   * Bbbee findUniqueOrThrow
   */
  export type BbbeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeInclude<ExtArgs> | null
    /**
     * Filter, which Bbbee to fetch.
     */
    where: BbbeeWhereUniqueInput
  }

  /**
   * Bbbee findFirst
   */
  export type BbbeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeInclude<ExtArgs> | null
    /**
     * Filter, which Bbbee to fetch.
     */
    where?: BbbeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bbbees to fetch.
     */
    orderBy?: BbbeeOrderByWithRelationInput | BbbeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bbbees.
     */
    cursor?: BbbeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bbbees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bbbees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bbbees.
     */
    distinct?: BbbeeScalarFieldEnum | BbbeeScalarFieldEnum[]
  }

  /**
   * Bbbee findFirstOrThrow
   */
  export type BbbeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeInclude<ExtArgs> | null
    /**
     * Filter, which Bbbee to fetch.
     */
    where?: BbbeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bbbees to fetch.
     */
    orderBy?: BbbeeOrderByWithRelationInput | BbbeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bbbees.
     */
    cursor?: BbbeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bbbees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bbbees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bbbees.
     */
    distinct?: BbbeeScalarFieldEnum | BbbeeScalarFieldEnum[]
  }

  /**
   * Bbbee findMany
   */
  export type BbbeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeInclude<ExtArgs> | null
    /**
     * Filter, which Bbbees to fetch.
     */
    where?: BbbeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bbbees to fetch.
     */
    orderBy?: BbbeeOrderByWithRelationInput | BbbeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bbbees.
     */
    cursor?: BbbeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bbbees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bbbees.
     */
    skip?: number
    distinct?: BbbeeScalarFieldEnum | BbbeeScalarFieldEnum[]
  }

  /**
   * Bbbee create
   */
  export type BbbeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Bbbee.
     */
    data: XOR<BbbeeCreateInput, BbbeeUncheckedCreateInput>
  }

  /**
   * Bbbee createMany
   */
  export type BbbeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bbbees.
     */
    data: BbbeeCreateManyInput | BbbeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bbbee createManyAndReturn
   */
  export type BbbeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bbbees.
     */
    data: BbbeeCreateManyInput | BbbeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bbbee update
   */
  export type BbbeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Bbbee.
     */
    data: XOR<BbbeeUpdateInput, BbbeeUncheckedUpdateInput>
    /**
     * Choose, which Bbbee to update.
     */
    where: BbbeeWhereUniqueInput
  }

  /**
   * Bbbee updateMany
   */
  export type BbbeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bbbees.
     */
    data: XOR<BbbeeUpdateManyMutationInput, BbbeeUncheckedUpdateManyInput>
    /**
     * Filter which Bbbees to update
     */
    where?: BbbeeWhereInput
  }

  /**
   * Bbbee upsert
   */
  export type BbbeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Bbbee to update in case it exists.
     */
    where: BbbeeWhereUniqueInput
    /**
     * In case the Bbbee found by the `where` argument doesn't exist, create a new Bbbee with this data.
     */
    create: XOR<BbbeeCreateInput, BbbeeUncheckedCreateInput>
    /**
     * In case the Bbbee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BbbeeUpdateInput, BbbeeUncheckedUpdateInput>
  }

  /**
   * Bbbee delete
   */
  export type BbbeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeInclude<ExtArgs> | null
    /**
     * Filter which Bbbee to delete.
     */
    where: BbbeeWhereUniqueInput
  }

  /**
   * Bbbee deleteMany
   */
  export type BbbeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bbbees to delete
     */
    where?: BbbeeWhereInput
  }

  /**
   * Bbbee without action
   */
  export type BbbeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bbbee
     */
    select?: BbbeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BbbeeInclude<ExtArgs> | null
  }


  /**
   * Model Evidence
   */

  export type AggregateEvidence = {
    _count: EvidenceCountAggregateOutputType | null
    _min: EvidenceMinAggregateOutputType | null
    _max: EvidenceMaxAggregateOutputType | null
  }

  export type EvidenceMinAggregateOutputType = {
    id: string | null
    bidderId: string | null
    type: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvidenceMaxAggregateOutputType = {
    id: string | null
    bidderId: string | null
    type: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvidenceCountAggregateOutputType = {
    id: number
    bidderId: number
    type: number
    metadata: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvidenceMinAggregateInputType = {
    id?: true
    bidderId?: true
    type?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvidenceMaxAggregateInputType = {
    id?: true
    bidderId?: true
    type?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvidenceCountAggregateInputType = {
    id?: true
    bidderId?: true
    type?: true
    metadata?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvidenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidence to aggregate.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evidences
    **/
    _count?: true | EvidenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvidenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvidenceMaxAggregateInputType
  }

  export type GetEvidenceAggregateType<T extends EvidenceAggregateArgs> = {
        [P in keyof T & keyof AggregateEvidence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidence[P]>
      : GetScalarType<T[P], AggregateEvidence[P]>
  }




  export type EvidenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceWhereInput
    orderBy?: EvidenceOrderByWithAggregationInput | EvidenceOrderByWithAggregationInput[]
    by: EvidenceScalarFieldEnum[] | EvidenceScalarFieldEnum
    having?: EvidenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvidenceCountAggregateInputType | true
    _min?: EvidenceMinAggregateInputType
    _max?: EvidenceMaxAggregateInputType
  }

  export type EvidenceGroupByOutputType = {
    id: string
    bidderId: string
    type: string
    metadata: JsonValue | null
    url: string | null
    createdAt: Date
    updatedAt: Date
    _count: EvidenceCountAggregateOutputType | null
    _min: EvidenceMinAggregateOutputType | null
    _max: EvidenceMaxAggregateOutputType | null
  }

  type GetEvidenceGroupByPayload<T extends EvidenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvidenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvidenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenceGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenceGroupByOutputType[P]>
        }
      >
    >


  export type EvidenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bidderId?: boolean
    type?: boolean
    metadata?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidence"]>

  export type EvidenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bidderId?: boolean
    type?: boolean
    metadata?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidence"]>

  export type EvidenceSelectScalar = {
    id?: boolean
    bidderId?: boolean
    type?: boolean
    metadata?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EvidenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }
  export type EvidenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }

  export type $EvidencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evidence"
    objects: {
      bidder: Prisma.$BidderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bidderId: string
      type: string
      metadata: Prisma.JsonValue | null
      url: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evidence"]>
    composites: {}
  }

  type EvidenceGetPayload<S extends boolean | null | undefined | EvidenceDefaultArgs> = $Result.GetResult<Prisma.$EvidencePayload, S>

  type EvidenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvidenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvidenceCountAggregateInputType | true
    }

  export interface EvidenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evidence'], meta: { name: 'Evidence' } }
    /**
     * Find zero or one Evidence that matches the filter.
     * @param {EvidenceFindUniqueArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenceFindUniqueArgs>(args: SelectSubset<T, EvidenceFindUniqueArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Evidence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvidenceFindUniqueOrThrowArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenceFindUniqueOrThrowArgs>(args: SelectSubset<T, EvidenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Evidence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindFirstArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenceFindFirstArgs>(args?: SelectSubset<T, EvidenceFindFirstArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Evidence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindFirstOrThrowArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenceFindFirstOrThrowArgs>(args?: SelectSubset<T, EvidenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Evidences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evidences
     * const evidences = await prisma.evidence.findMany()
     * 
     * // Get first 10 Evidences
     * const evidences = await prisma.evidence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evidenceWithIdOnly = await prisma.evidence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvidenceFindManyArgs>(args?: SelectSubset<T, EvidenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Evidence.
     * @param {EvidenceCreateArgs} args - Arguments to create a Evidence.
     * @example
     * // Create one Evidence
     * const Evidence = await prisma.evidence.create({
     *   data: {
     *     // ... data to create a Evidence
     *   }
     * })
     * 
     */
    create<T extends EvidenceCreateArgs>(args: SelectSubset<T, EvidenceCreateArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Evidences.
     * @param {EvidenceCreateManyArgs} args - Arguments to create many Evidences.
     * @example
     * // Create many Evidences
     * const evidence = await prisma.evidence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvidenceCreateManyArgs>(args?: SelectSubset<T, EvidenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evidences and returns the data saved in the database.
     * @param {EvidenceCreateManyAndReturnArgs} args - Arguments to create many Evidences.
     * @example
     * // Create many Evidences
     * const evidence = await prisma.evidence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evidences and only return the `id`
     * const evidenceWithIdOnly = await prisma.evidence.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvidenceCreateManyAndReturnArgs>(args?: SelectSubset<T, EvidenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Evidence.
     * @param {EvidenceDeleteArgs} args - Arguments to delete one Evidence.
     * @example
     * // Delete one Evidence
     * const Evidence = await prisma.evidence.delete({
     *   where: {
     *     // ... filter to delete one Evidence
     *   }
     * })
     * 
     */
    delete<T extends EvidenceDeleteArgs>(args: SelectSubset<T, EvidenceDeleteArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Evidence.
     * @param {EvidenceUpdateArgs} args - Arguments to update one Evidence.
     * @example
     * // Update one Evidence
     * const evidence = await prisma.evidence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvidenceUpdateArgs>(args: SelectSubset<T, EvidenceUpdateArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Evidences.
     * @param {EvidenceDeleteManyArgs} args - Arguments to filter Evidences to delete.
     * @example
     * // Delete a few Evidences
     * const { count } = await prisma.evidence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvidenceDeleteManyArgs>(args?: SelectSubset<T, EvidenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evidences
     * const evidence = await prisma.evidence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvidenceUpdateManyArgs>(args: SelectSubset<T, EvidenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evidence.
     * @param {EvidenceUpsertArgs} args - Arguments to update or create a Evidence.
     * @example
     * // Update or create a Evidence
     * const evidence = await prisma.evidence.upsert({
     *   create: {
     *     // ... data to create a Evidence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evidence we want to update
     *   }
     * })
     */
    upsert<T extends EvidenceUpsertArgs>(args: SelectSubset<T, EvidenceUpsertArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Evidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceCountArgs} args - Arguments to filter Evidences to count.
     * @example
     * // Count the number of Evidences
     * const count = await prisma.evidence.count({
     *   where: {
     *     // ... the filter for the Evidences we want to count
     *   }
     * })
    **/
    count<T extends EvidenceCountArgs>(
      args?: Subset<T, EvidenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvidenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvidenceAggregateArgs>(args: Subset<T, EvidenceAggregateArgs>): Prisma.PrismaPromise<GetEvidenceAggregateType<T>>

    /**
     * Group by Evidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvidenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenceGroupByArgs['orderBy'] }
        : { orderBy?: EvidenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvidenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvidenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evidence model
   */
  readonly fields: EvidenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evidence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bidder<T extends BidderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BidderDefaultArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evidence model
   */ 
  interface EvidenceFieldRefs {
    readonly id: FieldRef<"Evidence", 'String'>
    readonly bidderId: FieldRef<"Evidence", 'String'>
    readonly type: FieldRef<"Evidence", 'String'>
    readonly metadata: FieldRef<"Evidence", 'Json'>
    readonly url: FieldRef<"Evidence", 'String'>
    readonly createdAt: FieldRef<"Evidence", 'DateTime'>
    readonly updatedAt: FieldRef<"Evidence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evidence findUnique
   */
  export type EvidenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence findUniqueOrThrow
   */
  export type EvidenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence findFirst
   */
  export type EvidenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidences.
     */
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence findFirstOrThrow
   */
  export type EvidenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidences.
     */
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence findMany
   */
  export type EvidenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidences to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence create
   */
  export type EvidenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Evidence.
     */
    data: XOR<EvidenceCreateInput, EvidenceUncheckedCreateInput>
  }

  /**
   * Evidence createMany
   */
  export type EvidenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evidences.
     */
    data: EvidenceCreateManyInput | EvidenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evidence createManyAndReturn
   */
  export type EvidenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Evidences.
     */
    data: EvidenceCreateManyInput | EvidenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evidence update
   */
  export type EvidenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Evidence.
     */
    data: XOR<EvidenceUpdateInput, EvidenceUncheckedUpdateInput>
    /**
     * Choose, which Evidence to update.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence updateMany
   */
  export type EvidenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evidences.
     */
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyInput>
    /**
     * Filter which Evidences to update
     */
    where?: EvidenceWhereInput
  }

  /**
   * Evidence upsert
   */
  export type EvidenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Evidence to update in case it exists.
     */
    where: EvidenceWhereUniqueInput
    /**
     * In case the Evidence found by the `where` argument doesn't exist, create a new Evidence with this data.
     */
    create: XOR<EvidenceCreateInput, EvidenceUncheckedCreateInput>
    /**
     * In case the Evidence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenceUpdateInput, EvidenceUncheckedUpdateInput>
  }

  /**
   * Evidence delete
   */
  export type EvidenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter which Evidence to delete.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence deleteMany
   */
  export type EvidenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidences to delete
     */
    where?: EvidenceWhereInput
  }

  /**
   * Evidence without action
   */
  export type EvidenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
  }


  /**
   * Model EvaluationConfig
   */

  export type AggregateEvaluationConfig = {
    _count: EvaluationConfigCountAggregateOutputType | null
    _avg: EvaluationConfigAvgAggregateOutputType | null
    _sum: EvaluationConfigSumAggregateOutputType | null
    _min: EvaluationConfigMinAggregateOutputType | null
    _max: EvaluationConfigMaxAggregateOutputType | null
  }

  export type EvaluationConfigAvgAggregateOutputType = {
    priceWeight: number | null
    bbbeeWeight: number | null
    functionalityPass: number | null
    functionalityMax: number | null
  }

  export type EvaluationConfigSumAggregateOutputType = {
    priceWeight: number | null
    bbbeeWeight: number | null
    functionalityPass: number | null
    functionalityMax: number | null
  }

  export type EvaluationConfigMinAggregateOutputType = {
    id: string | null
    tenderId: string | null
    priceWeight: number | null
    bbbeeWeight: number | null
    functionalityPass: number | null
    functionalityMax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationConfigMaxAggregateOutputType = {
    id: string | null
    tenderId: string | null
    priceWeight: number | null
    bbbeeWeight: number | null
    functionalityPass: number | null
    functionalityMax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationConfigCountAggregateOutputType = {
    id: number
    tenderId: number
    priceWeight: number
    bbbeeWeight: number
    functionalityPass: number
    functionalityMax: number
    criteria: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvaluationConfigAvgAggregateInputType = {
    priceWeight?: true
    bbbeeWeight?: true
    functionalityPass?: true
    functionalityMax?: true
  }

  export type EvaluationConfigSumAggregateInputType = {
    priceWeight?: true
    bbbeeWeight?: true
    functionalityPass?: true
    functionalityMax?: true
  }

  export type EvaluationConfigMinAggregateInputType = {
    id?: true
    tenderId?: true
    priceWeight?: true
    bbbeeWeight?: true
    functionalityPass?: true
    functionalityMax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationConfigMaxAggregateInputType = {
    id?: true
    tenderId?: true
    priceWeight?: true
    bbbeeWeight?: true
    functionalityPass?: true
    functionalityMax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationConfigCountAggregateInputType = {
    id?: true
    tenderId?: true
    priceWeight?: true
    bbbeeWeight?: true
    functionalityPass?: true
    functionalityMax?: true
    criteria?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvaluationConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationConfig to aggregate.
     */
    where?: EvaluationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationConfigs to fetch.
     */
    orderBy?: EvaluationConfigOrderByWithRelationInput | EvaluationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluationConfigs
    **/
    _count?: true | EvaluationConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationConfigMaxAggregateInputType
  }

  export type GetEvaluationConfigAggregateType<T extends EvaluationConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluationConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluationConfig[P]>
      : GetScalarType<T[P], AggregateEvaluationConfig[P]>
  }




  export type EvaluationConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationConfigWhereInput
    orderBy?: EvaluationConfigOrderByWithAggregationInput | EvaluationConfigOrderByWithAggregationInput[]
    by: EvaluationConfigScalarFieldEnum[] | EvaluationConfigScalarFieldEnum
    having?: EvaluationConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationConfigCountAggregateInputType | true
    _avg?: EvaluationConfigAvgAggregateInputType
    _sum?: EvaluationConfigSumAggregateInputType
    _min?: EvaluationConfigMinAggregateInputType
    _max?: EvaluationConfigMaxAggregateInputType
  }

  export type EvaluationConfigGroupByOutputType = {
    id: string
    tenderId: string
    priceWeight: number
    bbbeeWeight: number
    functionalityPass: number
    functionalityMax: number
    criteria: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: EvaluationConfigCountAggregateOutputType | null
    _avg: EvaluationConfigAvgAggregateOutputType | null
    _sum: EvaluationConfigSumAggregateOutputType | null
    _min: EvaluationConfigMinAggregateOutputType | null
    _max: EvaluationConfigMaxAggregateOutputType | null
  }

  type GetEvaluationConfigGroupByPayload<T extends EvaluationConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationConfigGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationConfigGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    priceWeight?: boolean
    bbbeeWeight?: boolean
    functionalityPass?: boolean
    functionalityMax?: boolean
    criteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationConfig"]>

  export type EvaluationConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    priceWeight?: boolean
    bbbeeWeight?: boolean
    functionalityPass?: boolean
    functionalityMax?: boolean
    criteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationConfig"]>

  export type EvaluationConfigSelectScalar = {
    id?: boolean
    tenderId?: boolean
    priceWeight?: boolean
    bbbeeWeight?: boolean
    functionalityPass?: boolean
    functionalityMax?: boolean
    criteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EvaluationConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }
  export type EvaluationConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }

  export type $EvaluationConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluationConfig"
    objects: {
      tender: Prisma.$TenderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenderId: string
      priceWeight: number
      bbbeeWeight: number
      functionalityPass: number
      functionalityMax: number
      criteria: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evaluationConfig"]>
    composites: {}
  }

  type EvaluationConfigGetPayload<S extends boolean | null | undefined | EvaluationConfigDefaultArgs> = $Result.GetResult<Prisma.$EvaluationConfigPayload, S>

  type EvaluationConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationConfigCountAggregateInputType | true
    }

  export interface EvaluationConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluationConfig'], meta: { name: 'EvaluationConfig' } }
    /**
     * Find zero or one EvaluationConfig that matches the filter.
     * @param {EvaluationConfigFindUniqueArgs} args - Arguments to find a EvaluationConfig
     * @example
     * // Get one EvaluationConfig
     * const evaluationConfig = await prisma.evaluationConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationConfigFindUniqueArgs>(args: SelectSubset<T, EvaluationConfigFindUniqueArgs<ExtArgs>>): Prisma__EvaluationConfigClient<$Result.GetResult<Prisma.$EvaluationConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvaluationConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvaluationConfigFindUniqueOrThrowArgs} args - Arguments to find a EvaluationConfig
     * @example
     * // Get one EvaluationConfig
     * const evaluationConfig = await prisma.evaluationConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationConfigClient<$Result.GetResult<Prisma.$EvaluationConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvaluationConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationConfigFindFirstArgs} args - Arguments to find a EvaluationConfig
     * @example
     * // Get one EvaluationConfig
     * const evaluationConfig = await prisma.evaluationConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationConfigFindFirstArgs>(args?: SelectSubset<T, EvaluationConfigFindFirstArgs<ExtArgs>>): Prisma__EvaluationConfigClient<$Result.GetResult<Prisma.$EvaluationConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvaluationConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationConfigFindFirstOrThrowArgs} args - Arguments to find a EvaluationConfig
     * @example
     * // Get one EvaluationConfig
     * const evaluationConfig = await prisma.evaluationConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationConfigClient<$Result.GetResult<Prisma.$EvaluationConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvaluationConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluationConfigs
     * const evaluationConfigs = await prisma.evaluationConfig.findMany()
     * 
     * // Get first 10 EvaluationConfigs
     * const evaluationConfigs = await prisma.evaluationConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationConfigWithIdOnly = await prisma.evaluationConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationConfigFindManyArgs>(args?: SelectSubset<T, EvaluationConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvaluationConfig.
     * @param {EvaluationConfigCreateArgs} args - Arguments to create a EvaluationConfig.
     * @example
     * // Create one EvaluationConfig
     * const EvaluationConfig = await prisma.evaluationConfig.create({
     *   data: {
     *     // ... data to create a EvaluationConfig
     *   }
     * })
     * 
     */
    create<T extends EvaluationConfigCreateArgs>(args: SelectSubset<T, EvaluationConfigCreateArgs<ExtArgs>>): Prisma__EvaluationConfigClient<$Result.GetResult<Prisma.$EvaluationConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvaluationConfigs.
     * @param {EvaluationConfigCreateManyArgs} args - Arguments to create many EvaluationConfigs.
     * @example
     * // Create many EvaluationConfigs
     * const evaluationConfig = await prisma.evaluationConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationConfigCreateManyArgs>(args?: SelectSubset<T, EvaluationConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvaluationConfigs and returns the data saved in the database.
     * @param {EvaluationConfigCreateManyAndReturnArgs} args - Arguments to create many EvaluationConfigs.
     * @example
     * // Create many EvaluationConfigs
     * const evaluationConfig = await prisma.evaluationConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvaluationConfigs and only return the `id`
     * const evaluationConfigWithIdOnly = await prisma.evaluationConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvaluationConfig.
     * @param {EvaluationConfigDeleteArgs} args - Arguments to delete one EvaluationConfig.
     * @example
     * // Delete one EvaluationConfig
     * const EvaluationConfig = await prisma.evaluationConfig.delete({
     *   where: {
     *     // ... filter to delete one EvaluationConfig
     *   }
     * })
     * 
     */
    delete<T extends EvaluationConfigDeleteArgs>(args: SelectSubset<T, EvaluationConfigDeleteArgs<ExtArgs>>): Prisma__EvaluationConfigClient<$Result.GetResult<Prisma.$EvaluationConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvaluationConfig.
     * @param {EvaluationConfigUpdateArgs} args - Arguments to update one EvaluationConfig.
     * @example
     * // Update one EvaluationConfig
     * const evaluationConfig = await prisma.evaluationConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationConfigUpdateArgs>(args: SelectSubset<T, EvaluationConfigUpdateArgs<ExtArgs>>): Prisma__EvaluationConfigClient<$Result.GetResult<Prisma.$EvaluationConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvaluationConfigs.
     * @param {EvaluationConfigDeleteManyArgs} args - Arguments to filter EvaluationConfigs to delete.
     * @example
     * // Delete a few EvaluationConfigs
     * const { count } = await prisma.evaluationConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationConfigDeleteManyArgs>(args?: SelectSubset<T, EvaluationConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluationConfigs
     * const evaluationConfig = await prisma.evaluationConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationConfigUpdateManyArgs>(args: SelectSubset<T, EvaluationConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvaluationConfig.
     * @param {EvaluationConfigUpsertArgs} args - Arguments to update or create a EvaluationConfig.
     * @example
     * // Update or create a EvaluationConfig
     * const evaluationConfig = await prisma.evaluationConfig.upsert({
     *   create: {
     *     // ... data to create a EvaluationConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluationConfig we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationConfigUpsertArgs>(args: SelectSubset<T, EvaluationConfigUpsertArgs<ExtArgs>>): Prisma__EvaluationConfigClient<$Result.GetResult<Prisma.$EvaluationConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvaluationConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationConfigCountArgs} args - Arguments to filter EvaluationConfigs to count.
     * @example
     * // Count the number of EvaluationConfigs
     * const count = await prisma.evaluationConfig.count({
     *   where: {
     *     // ... the filter for the EvaluationConfigs we want to count
     *   }
     * })
    **/
    count<T extends EvaluationConfigCountArgs>(
      args?: Subset<T, EvaluationConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluationConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationConfigAggregateArgs>(args: Subset<T, EvaluationConfigAggregateArgs>): Prisma.PrismaPromise<GetEvaluationConfigAggregateType<T>>

    /**
     * Group by EvaluationConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationConfigGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluationConfig model
   */
  readonly fields: EvaluationConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluationConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tender<T extends TenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenderDefaultArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaluationConfig model
   */ 
  interface EvaluationConfigFieldRefs {
    readonly id: FieldRef<"EvaluationConfig", 'String'>
    readonly tenderId: FieldRef<"EvaluationConfig", 'String'>
    readonly priceWeight: FieldRef<"EvaluationConfig", 'Int'>
    readonly bbbeeWeight: FieldRef<"EvaluationConfig", 'Int'>
    readonly functionalityPass: FieldRef<"EvaluationConfig", 'Int'>
    readonly functionalityMax: FieldRef<"EvaluationConfig", 'Int'>
    readonly criteria: FieldRef<"EvaluationConfig", 'Json'>
    readonly createdAt: FieldRef<"EvaluationConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"EvaluationConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvaluationConfig findUnique
   */
  export type EvaluationConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationConfig to fetch.
     */
    where: EvaluationConfigWhereUniqueInput
  }

  /**
   * EvaluationConfig findUniqueOrThrow
   */
  export type EvaluationConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationConfig to fetch.
     */
    where: EvaluationConfigWhereUniqueInput
  }

  /**
   * EvaluationConfig findFirst
   */
  export type EvaluationConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationConfig to fetch.
     */
    where?: EvaluationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationConfigs to fetch.
     */
    orderBy?: EvaluationConfigOrderByWithRelationInput | EvaluationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationConfigs.
     */
    cursor?: EvaluationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationConfigs.
     */
    distinct?: EvaluationConfigScalarFieldEnum | EvaluationConfigScalarFieldEnum[]
  }

  /**
   * EvaluationConfig findFirstOrThrow
   */
  export type EvaluationConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationConfig to fetch.
     */
    where?: EvaluationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationConfigs to fetch.
     */
    orderBy?: EvaluationConfigOrderByWithRelationInput | EvaluationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationConfigs.
     */
    cursor?: EvaluationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationConfigs.
     */
    distinct?: EvaluationConfigScalarFieldEnum | EvaluationConfigScalarFieldEnum[]
  }

  /**
   * EvaluationConfig findMany
   */
  export type EvaluationConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationConfigs to fetch.
     */
    where?: EvaluationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationConfigs to fetch.
     */
    orderBy?: EvaluationConfigOrderByWithRelationInput | EvaluationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluationConfigs.
     */
    cursor?: EvaluationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationConfigs.
     */
    skip?: number
    distinct?: EvaluationConfigScalarFieldEnum | EvaluationConfigScalarFieldEnum[]
  }

  /**
   * EvaluationConfig create
   */
  export type EvaluationConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaluationConfig.
     */
    data: XOR<EvaluationConfigCreateInput, EvaluationConfigUncheckedCreateInput>
  }

  /**
   * EvaluationConfig createMany
   */
  export type EvaluationConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluationConfigs.
     */
    data: EvaluationConfigCreateManyInput | EvaluationConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvaluationConfig createManyAndReturn
   */
  export type EvaluationConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvaluationConfigs.
     */
    data: EvaluationConfigCreateManyInput | EvaluationConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvaluationConfig update
   */
  export type EvaluationConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaluationConfig.
     */
    data: XOR<EvaluationConfigUpdateInput, EvaluationConfigUncheckedUpdateInput>
    /**
     * Choose, which EvaluationConfig to update.
     */
    where: EvaluationConfigWhereUniqueInput
  }

  /**
   * EvaluationConfig updateMany
   */
  export type EvaluationConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluationConfigs.
     */
    data: XOR<EvaluationConfigUpdateManyMutationInput, EvaluationConfigUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationConfigs to update
     */
    where?: EvaluationConfigWhereInput
  }

  /**
   * EvaluationConfig upsert
   */
  export type EvaluationConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaluationConfig to update in case it exists.
     */
    where: EvaluationConfigWhereUniqueInput
    /**
     * In case the EvaluationConfig found by the `where` argument doesn't exist, create a new EvaluationConfig with this data.
     */
    create: XOR<EvaluationConfigCreateInput, EvaluationConfigUncheckedCreateInput>
    /**
     * In case the EvaluationConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationConfigUpdateInput, EvaluationConfigUncheckedUpdateInput>
  }

  /**
   * EvaluationConfig delete
   */
  export type EvaluationConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigInclude<ExtArgs> | null
    /**
     * Filter which EvaluationConfig to delete.
     */
    where: EvaluationConfigWhereUniqueInput
  }

  /**
   * EvaluationConfig deleteMany
   */
  export type EvaluationConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationConfigs to delete
     */
    where?: EvaluationConfigWhereInput
  }

  /**
   * EvaluationConfig without action
   */
  export type EvaluationConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationConfig
     */
    select?: EvaluationConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationConfigInclude<ExtArgs> | null
  }


  /**
   * Model BidderCriterionScore
   */

  export type AggregateBidderCriterionScore = {
    _count: BidderCriterionScoreCountAggregateOutputType | null
    _avg: BidderCriterionScoreAvgAggregateOutputType | null
    _sum: BidderCriterionScoreSumAggregateOutputType | null
    _min: BidderCriterionScoreMinAggregateOutputType | null
    _max: BidderCriterionScoreMaxAggregateOutputType | null
  }

  export type BidderCriterionScoreAvgAggregateOutputType = {
    rawScore: number | null
    scaleMax: number | null
    weight: number | null
  }

  export type BidderCriterionScoreSumAggregateOutputType = {
    rawScore: number | null
    scaleMax: number | null
    weight: number | null
  }

  export type BidderCriterionScoreMinAggregateOutputType = {
    id: string | null
    bidderId: string | null
    criterionCode: string | null
    rawScore: number | null
    scaleMax: number | null
    weight: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidderCriterionScoreMaxAggregateOutputType = {
    id: string | null
    bidderId: string | null
    criterionCode: string | null
    rawScore: number | null
    scaleMax: number | null
    weight: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidderCriterionScoreCountAggregateOutputType = {
    id: number
    bidderId: number
    criterionCode: number
    rawScore: number
    scaleMax: number
    weight: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BidderCriterionScoreAvgAggregateInputType = {
    rawScore?: true
    scaleMax?: true
    weight?: true
  }

  export type BidderCriterionScoreSumAggregateInputType = {
    rawScore?: true
    scaleMax?: true
    weight?: true
  }

  export type BidderCriterionScoreMinAggregateInputType = {
    id?: true
    bidderId?: true
    criterionCode?: true
    rawScore?: true
    scaleMax?: true
    weight?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidderCriterionScoreMaxAggregateInputType = {
    id?: true
    bidderId?: true
    criterionCode?: true
    rawScore?: true
    scaleMax?: true
    weight?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidderCriterionScoreCountAggregateInputType = {
    id?: true
    bidderId?: true
    criterionCode?: true
    rawScore?: true
    scaleMax?: true
    weight?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BidderCriterionScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BidderCriterionScore to aggregate.
     */
    where?: BidderCriterionScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderCriterionScores to fetch.
     */
    orderBy?: BidderCriterionScoreOrderByWithRelationInput | BidderCriterionScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidderCriterionScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderCriterionScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderCriterionScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BidderCriterionScores
    **/
    _count?: true | BidderCriterionScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BidderCriterionScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BidderCriterionScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidderCriterionScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidderCriterionScoreMaxAggregateInputType
  }

  export type GetBidderCriterionScoreAggregateType<T extends BidderCriterionScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateBidderCriterionScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBidderCriterionScore[P]>
      : GetScalarType<T[P], AggregateBidderCriterionScore[P]>
  }




  export type BidderCriterionScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidderCriterionScoreWhereInput
    orderBy?: BidderCriterionScoreOrderByWithAggregationInput | BidderCriterionScoreOrderByWithAggregationInput[]
    by: BidderCriterionScoreScalarFieldEnum[] | BidderCriterionScoreScalarFieldEnum
    having?: BidderCriterionScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidderCriterionScoreCountAggregateInputType | true
    _avg?: BidderCriterionScoreAvgAggregateInputType
    _sum?: BidderCriterionScoreSumAggregateInputType
    _min?: BidderCriterionScoreMinAggregateInputType
    _max?: BidderCriterionScoreMaxAggregateInputType
  }

  export type BidderCriterionScoreGroupByOutputType = {
    id: string
    bidderId: string
    criterionCode: string
    rawScore: number
    scaleMax: number
    weight: number
    createdAt: Date
    updatedAt: Date
    _count: BidderCriterionScoreCountAggregateOutputType | null
    _avg: BidderCriterionScoreAvgAggregateOutputType | null
    _sum: BidderCriterionScoreSumAggregateOutputType | null
    _min: BidderCriterionScoreMinAggregateOutputType | null
    _max: BidderCriterionScoreMaxAggregateOutputType | null
  }

  type GetBidderCriterionScoreGroupByPayload<T extends BidderCriterionScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BidderCriterionScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidderCriterionScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidderCriterionScoreGroupByOutputType[P]>
            : GetScalarType<T[P], BidderCriterionScoreGroupByOutputType[P]>
        }
      >
    >


  export type BidderCriterionScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bidderId?: boolean
    criterionCode?: boolean
    rawScore?: boolean
    scaleMax?: boolean
    weight?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bidderCriterionScore"]>

  export type BidderCriterionScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bidderId?: boolean
    criterionCode?: boolean
    rawScore?: boolean
    scaleMax?: boolean
    weight?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bidderCriterionScore"]>

  export type BidderCriterionScoreSelectScalar = {
    id?: boolean
    bidderId?: boolean
    criterionCode?: boolean
    rawScore?: boolean
    scaleMax?: boolean
    weight?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BidderCriterionScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }
  export type BidderCriterionScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }

  export type $BidderCriterionScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BidderCriterionScore"
    objects: {
      bidder: Prisma.$BidderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bidderId: string
      criterionCode: string
      rawScore: number
      scaleMax: number
      weight: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bidderCriterionScore"]>
    composites: {}
  }

  type BidderCriterionScoreGetPayload<S extends boolean | null | undefined | BidderCriterionScoreDefaultArgs> = $Result.GetResult<Prisma.$BidderCriterionScorePayload, S>

  type BidderCriterionScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BidderCriterionScoreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BidderCriterionScoreCountAggregateInputType | true
    }

  export interface BidderCriterionScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BidderCriterionScore'], meta: { name: 'BidderCriterionScore' } }
    /**
     * Find zero or one BidderCriterionScore that matches the filter.
     * @param {BidderCriterionScoreFindUniqueArgs} args - Arguments to find a BidderCriterionScore
     * @example
     * // Get one BidderCriterionScore
     * const bidderCriterionScore = await prisma.bidderCriterionScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BidderCriterionScoreFindUniqueArgs>(args: SelectSubset<T, BidderCriterionScoreFindUniqueArgs<ExtArgs>>): Prisma__BidderCriterionScoreClient<$Result.GetResult<Prisma.$BidderCriterionScorePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BidderCriterionScore that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BidderCriterionScoreFindUniqueOrThrowArgs} args - Arguments to find a BidderCriterionScore
     * @example
     * // Get one BidderCriterionScore
     * const bidderCriterionScore = await prisma.bidderCriterionScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BidderCriterionScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, BidderCriterionScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BidderCriterionScoreClient<$Result.GetResult<Prisma.$BidderCriterionScorePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BidderCriterionScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderCriterionScoreFindFirstArgs} args - Arguments to find a BidderCriterionScore
     * @example
     * // Get one BidderCriterionScore
     * const bidderCriterionScore = await prisma.bidderCriterionScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BidderCriterionScoreFindFirstArgs>(args?: SelectSubset<T, BidderCriterionScoreFindFirstArgs<ExtArgs>>): Prisma__BidderCriterionScoreClient<$Result.GetResult<Prisma.$BidderCriterionScorePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BidderCriterionScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderCriterionScoreFindFirstOrThrowArgs} args - Arguments to find a BidderCriterionScore
     * @example
     * // Get one BidderCriterionScore
     * const bidderCriterionScore = await prisma.bidderCriterionScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BidderCriterionScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, BidderCriterionScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__BidderCriterionScoreClient<$Result.GetResult<Prisma.$BidderCriterionScorePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BidderCriterionScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderCriterionScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BidderCriterionScores
     * const bidderCriterionScores = await prisma.bidderCriterionScore.findMany()
     * 
     * // Get first 10 BidderCriterionScores
     * const bidderCriterionScores = await prisma.bidderCriterionScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bidderCriterionScoreWithIdOnly = await prisma.bidderCriterionScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BidderCriterionScoreFindManyArgs>(args?: SelectSubset<T, BidderCriterionScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidderCriterionScorePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BidderCriterionScore.
     * @param {BidderCriterionScoreCreateArgs} args - Arguments to create a BidderCriterionScore.
     * @example
     * // Create one BidderCriterionScore
     * const BidderCriterionScore = await prisma.bidderCriterionScore.create({
     *   data: {
     *     // ... data to create a BidderCriterionScore
     *   }
     * })
     * 
     */
    create<T extends BidderCriterionScoreCreateArgs>(args: SelectSubset<T, BidderCriterionScoreCreateArgs<ExtArgs>>): Prisma__BidderCriterionScoreClient<$Result.GetResult<Prisma.$BidderCriterionScorePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BidderCriterionScores.
     * @param {BidderCriterionScoreCreateManyArgs} args - Arguments to create many BidderCriterionScores.
     * @example
     * // Create many BidderCriterionScores
     * const bidderCriterionScore = await prisma.bidderCriterionScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BidderCriterionScoreCreateManyArgs>(args?: SelectSubset<T, BidderCriterionScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BidderCriterionScores and returns the data saved in the database.
     * @param {BidderCriterionScoreCreateManyAndReturnArgs} args - Arguments to create many BidderCriterionScores.
     * @example
     * // Create many BidderCriterionScores
     * const bidderCriterionScore = await prisma.bidderCriterionScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BidderCriterionScores and only return the `id`
     * const bidderCriterionScoreWithIdOnly = await prisma.bidderCriterionScore.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BidderCriterionScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, BidderCriterionScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidderCriterionScorePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BidderCriterionScore.
     * @param {BidderCriterionScoreDeleteArgs} args - Arguments to delete one BidderCriterionScore.
     * @example
     * // Delete one BidderCriterionScore
     * const BidderCriterionScore = await prisma.bidderCriterionScore.delete({
     *   where: {
     *     // ... filter to delete one BidderCriterionScore
     *   }
     * })
     * 
     */
    delete<T extends BidderCriterionScoreDeleteArgs>(args: SelectSubset<T, BidderCriterionScoreDeleteArgs<ExtArgs>>): Prisma__BidderCriterionScoreClient<$Result.GetResult<Prisma.$BidderCriterionScorePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BidderCriterionScore.
     * @param {BidderCriterionScoreUpdateArgs} args - Arguments to update one BidderCriterionScore.
     * @example
     * // Update one BidderCriterionScore
     * const bidderCriterionScore = await prisma.bidderCriterionScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BidderCriterionScoreUpdateArgs>(args: SelectSubset<T, BidderCriterionScoreUpdateArgs<ExtArgs>>): Prisma__BidderCriterionScoreClient<$Result.GetResult<Prisma.$BidderCriterionScorePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BidderCriterionScores.
     * @param {BidderCriterionScoreDeleteManyArgs} args - Arguments to filter BidderCriterionScores to delete.
     * @example
     * // Delete a few BidderCriterionScores
     * const { count } = await prisma.bidderCriterionScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BidderCriterionScoreDeleteManyArgs>(args?: SelectSubset<T, BidderCriterionScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BidderCriterionScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderCriterionScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BidderCriterionScores
     * const bidderCriterionScore = await prisma.bidderCriterionScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BidderCriterionScoreUpdateManyArgs>(args: SelectSubset<T, BidderCriterionScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BidderCriterionScore.
     * @param {BidderCriterionScoreUpsertArgs} args - Arguments to update or create a BidderCriterionScore.
     * @example
     * // Update or create a BidderCriterionScore
     * const bidderCriterionScore = await prisma.bidderCriterionScore.upsert({
     *   create: {
     *     // ... data to create a BidderCriterionScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BidderCriterionScore we want to update
     *   }
     * })
     */
    upsert<T extends BidderCriterionScoreUpsertArgs>(args: SelectSubset<T, BidderCriterionScoreUpsertArgs<ExtArgs>>): Prisma__BidderCriterionScoreClient<$Result.GetResult<Prisma.$BidderCriterionScorePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BidderCriterionScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderCriterionScoreCountArgs} args - Arguments to filter BidderCriterionScores to count.
     * @example
     * // Count the number of BidderCriterionScores
     * const count = await prisma.bidderCriterionScore.count({
     *   where: {
     *     // ... the filter for the BidderCriterionScores we want to count
     *   }
     * })
    **/
    count<T extends BidderCriterionScoreCountArgs>(
      args?: Subset<T, BidderCriterionScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidderCriterionScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BidderCriterionScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderCriterionScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidderCriterionScoreAggregateArgs>(args: Subset<T, BidderCriterionScoreAggregateArgs>): Prisma.PrismaPromise<GetBidderCriterionScoreAggregateType<T>>

    /**
     * Group by BidderCriterionScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderCriterionScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidderCriterionScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidderCriterionScoreGroupByArgs['orderBy'] }
        : { orderBy?: BidderCriterionScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidderCriterionScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidderCriterionScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BidderCriterionScore model
   */
  readonly fields: BidderCriterionScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BidderCriterionScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BidderCriterionScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bidder<T extends BidderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BidderDefaultArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BidderCriterionScore model
   */ 
  interface BidderCriterionScoreFieldRefs {
    readonly id: FieldRef<"BidderCriterionScore", 'String'>
    readonly bidderId: FieldRef<"BidderCriterionScore", 'String'>
    readonly criterionCode: FieldRef<"BidderCriterionScore", 'String'>
    readonly rawScore: FieldRef<"BidderCriterionScore", 'Float'>
    readonly scaleMax: FieldRef<"BidderCriterionScore", 'Float'>
    readonly weight: FieldRef<"BidderCriterionScore", 'Float'>
    readonly createdAt: FieldRef<"BidderCriterionScore", 'DateTime'>
    readonly updatedAt: FieldRef<"BidderCriterionScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BidderCriterionScore findUnique
   */
  export type BidderCriterionScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreInclude<ExtArgs> | null
    /**
     * Filter, which BidderCriterionScore to fetch.
     */
    where: BidderCriterionScoreWhereUniqueInput
  }

  /**
   * BidderCriterionScore findUniqueOrThrow
   */
  export type BidderCriterionScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreInclude<ExtArgs> | null
    /**
     * Filter, which BidderCriterionScore to fetch.
     */
    where: BidderCriterionScoreWhereUniqueInput
  }

  /**
   * BidderCriterionScore findFirst
   */
  export type BidderCriterionScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreInclude<ExtArgs> | null
    /**
     * Filter, which BidderCriterionScore to fetch.
     */
    where?: BidderCriterionScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderCriterionScores to fetch.
     */
    orderBy?: BidderCriterionScoreOrderByWithRelationInput | BidderCriterionScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidderCriterionScores.
     */
    cursor?: BidderCriterionScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderCriterionScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderCriterionScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidderCriterionScores.
     */
    distinct?: BidderCriterionScoreScalarFieldEnum | BidderCriterionScoreScalarFieldEnum[]
  }

  /**
   * BidderCriterionScore findFirstOrThrow
   */
  export type BidderCriterionScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreInclude<ExtArgs> | null
    /**
     * Filter, which BidderCriterionScore to fetch.
     */
    where?: BidderCriterionScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderCriterionScores to fetch.
     */
    orderBy?: BidderCriterionScoreOrderByWithRelationInput | BidderCriterionScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidderCriterionScores.
     */
    cursor?: BidderCriterionScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderCriterionScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderCriterionScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidderCriterionScores.
     */
    distinct?: BidderCriterionScoreScalarFieldEnum | BidderCriterionScoreScalarFieldEnum[]
  }

  /**
   * BidderCriterionScore findMany
   */
  export type BidderCriterionScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreInclude<ExtArgs> | null
    /**
     * Filter, which BidderCriterionScores to fetch.
     */
    where?: BidderCriterionScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderCriterionScores to fetch.
     */
    orderBy?: BidderCriterionScoreOrderByWithRelationInput | BidderCriterionScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BidderCriterionScores.
     */
    cursor?: BidderCriterionScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderCriterionScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderCriterionScores.
     */
    skip?: number
    distinct?: BidderCriterionScoreScalarFieldEnum | BidderCriterionScoreScalarFieldEnum[]
  }

  /**
   * BidderCriterionScore create
   */
  export type BidderCriterionScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a BidderCriterionScore.
     */
    data: XOR<BidderCriterionScoreCreateInput, BidderCriterionScoreUncheckedCreateInput>
  }

  /**
   * BidderCriterionScore createMany
   */
  export type BidderCriterionScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BidderCriterionScores.
     */
    data: BidderCriterionScoreCreateManyInput | BidderCriterionScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BidderCriterionScore createManyAndReturn
   */
  export type BidderCriterionScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BidderCriterionScores.
     */
    data: BidderCriterionScoreCreateManyInput | BidderCriterionScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BidderCriterionScore update
   */
  export type BidderCriterionScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a BidderCriterionScore.
     */
    data: XOR<BidderCriterionScoreUpdateInput, BidderCriterionScoreUncheckedUpdateInput>
    /**
     * Choose, which BidderCriterionScore to update.
     */
    where: BidderCriterionScoreWhereUniqueInput
  }

  /**
   * BidderCriterionScore updateMany
   */
  export type BidderCriterionScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BidderCriterionScores.
     */
    data: XOR<BidderCriterionScoreUpdateManyMutationInput, BidderCriterionScoreUncheckedUpdateManyInput>
    /**
     * Filter which BidderCriterionScores to update
     */
    where?: BidderCriterionScoreWhereInput
  }

  /**
   * BidderCriterionScore upsert
   */
  export type BidderCriterionScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the BidderCriterionScore to update in case it exists.
     */
    where: BidderCriterionScoreWhereUniqueInput
    /**
     * In case the BidderCriterionScore found by the `where` argument doesn't exist, create a new BidderCriterionScore with this data.
     */
    create: XOR<BidderCriterionScoreCreateInput, BidderCriterionScoreUncheckedCreateInput>
    /**
     * In case the BidderCriterionScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidderCriterionScoreUpdateInput, BidderCriterionScoreUncheckedUpdateInput>
  }

  /**
   * BidderCriterionScore delete
   */
  export type BidderCriterionScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreInclude<ExtArgs> | null
    /**
     * Filter which BidderCriterionScore to delete.
     */
    where: BidderCriterionScoreWhereUniqueInput
  }

  /**
   * BidderCriterionScore deleteMany
   */
  export type BidderCriterionScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BidderCriterionScores to delete
     */
    where?: BidderCriterionScoreWhereInput
  }

  /**
   * BidderCriterionScore without action
   */
  export type BidderCriterionScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderCriterionScore
     */
    select?: BidderCriterionScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderCriterionScoreInclude<ExtArgs> | null
  }


  /**
   * Model EvaluationResult
   */

  export type AggregateEvaluationResult = {
    _count: EvaluationResultCountAggregateOutputType | null
    _avg: EvaluationResultAvgAggregateOutputType | null
    _sum: EvaluationResultSumAggregateOutputType | null
    _min: EvaluationResultMinAggregateOutputType | null
    _max: EvaluationResultMaxAggregateOutputType | null
  }

  export type EvaluationResultAvgAggregateOutputType = {
    functionalityScore: number | null
    price: number | null
    priceScore: number | null
    bbbeeLevel: number | null
    bbbeePoints: number | null
    totalScore: number | null
    riskScore: number | null
    complianceRate: number | null
    exceptionsCount: number | null
  }

  export type EvaluationResultSumAggregateOutputType = {
    functionalityScore: number | null
    price: number | null
    priceScore: number | null
    bbbeeLevel: number | null
    bbbeePoints: number | null
    totalScore: number | null
    riskScore: number | null
    complianceRate: number | null
    exceptionsCount: number | null
  }

  export type EvaluationResultMinAggregateOutputType = {
    id: string | null
    tenderId: string | null
    bidderId: string | null
    functionalityScore: number | null
    qualifies: boolean | null
    price: number | null
    priceScore: number | null
    bbbeeLevel: number | null
    bbbeePoints: number | null
    totalScore: number | null
    riskScore: number | null
    complianceRate: number | null
    exceptionsCount: number | null
    slaBreached: boolean | null
    currentStage: string | null
    createdAt: Date | null
    hash: string | null
  }

  export type EvaluationResultMaxAggregateOutputType = {
    id: string | null
    tenderId: string | null
    bidderId: string | null
    functionalityScore: number | null
    qualifies: boolean | null
    price: number | null
    priceScore: number | null
    bbbeeLevel: number | null
    bbbeePoints: number | null
    totalScore: number | null
    riskScore: number | null
    complianceRate: number | null
    exceptionsCount: number | null
    slaBreached: boolean | null
    currentStage: string | null
    createdAt: Date | null
    hash: string | null
  }

  export type EvaluationResultCountAggregateOutputType = {
    id: number
    tenderId: number
    bidderId: number
    functionalityScore: number
    qualifies: number
    price: number
    priceScore: number
    bbbeeLevel: number
    bbbeePoints: number
    totalScore: number
    riskScore: number
    complianceRate: number
    exceptionsCount: number
    slaBreached: number
    currentStage: number
    createdAt: number
    hash: number
    _all: number
  }


  export type EvaluationResultAvgAggregateInputType = {
    functionalityScore?: true
    price?: true
    priceScore?: true
    bbbeeLevel?: true
    bbbeePoints?: true
    totalScore?: true
    riskScore?: true
    complianceRate?: true
    exceptionsCount?: true
  }

  export type EvaluationResultSumAggregateInputType = {
    functionalityScore?: true
    price?: true
    priceScore?: true
    bbbeeLevel?: true
    bbbeePoints?: true
    totalScore?: true
    riskScore?: true
    complianceRate?: true
    exceptionsCount?: true
  }

  export type EvaluationResultMinAggregateInputType = {
    id?: true
    tenderId?: true
    bidderId?: true
    functionalityScore?: true
    qualifies?: true
    price?: true
    priceScore?: true
    bbbeeLevel?: true
    bbbeePoints?: true
    totalScore?: true
    riskScore?: true
    complianceRate?: true
    exceptionsCount?: true
    slaBreached?: true
    currentStage?: true
    createdAt?: true
    hash?: true
  }

  export type EvaluationResultMaxAggregateInputType = {
    id?: true
    tenderId?: true
    bidderId?: true
    functionalityScore?: true
    qualifies?: true
    price?: true
    priceScore?: true
    bbbeeLevel?: true
    bbbeePoints?: true
    totalScore?: true
    riskScore?: true
    complianceRate?: true
    exceptionsCount?: true
    slaBreached?: true
    currentStage?: true
    createdAt?: true
    hash?: true
  }

  export type EvaluationResultCountAggregateInputType = {
    id?: true
    tenderId?: true
    bidderId?: true
    functionalityScore?: true
    qualifies?: true
    price?: true
    priceScore?: true
    bbbeeLevel?: true
    bbbeePoints?: true
    totalScore?: true
    riskScore?: true
    complianceRate?: true
    exceptionsCount?: true
    slaBreached?: true
    currentStage?: true
    createdAt?: true
    hash?: true
    _all?: true
  }

  export type EvaluationResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationResult to aggregate.
     */
    where?: EvaluationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationResults to fetch.
     */
    orderBy?: EvaluationResultOrderByWithRelationInput | EvaluationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluationResults
    **/
    _count?: true | EvaluationResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationResultMaxAggregateInputType
  }

  export type GetEvaluationResultAggregateType<T extends EvaluationResultAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluationResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluationResult[P]>
      : GetScalarType<T[P], AggregateEvaluationResult[P]>
  }




  export type EvaluationResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationResultWhereInput
    orderBy?: EvaluationResultOrderByWithAggregationInput | EvaluationResultOrderByWithAggregationInput[]
    by: EvaluationResultScalarFieldEnum[] | EvaluationResultScalarFieldEnum
    having?: EvaluationResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationResultCountAggregateInputType | true
    _avg?: EvaluationResultAvgAggregateInputType
    _sum?: EvaluationResultSumAggregateInputType
    _min?: EvaluationResultMinAggregateInputType
    _max?: EvaluationResultMaxAggregateInputType
  }

  export type EvaluationResultGroupByOutputType = {
    id: string
    tenderId: string
    bidderId: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel: number | null
    bbbeePoints: number
    totalScore: number
    riskScore: number | null
    complianceRate: number | null
    exceptionsCount: number
    slaBreached: boolean
    currentStage: string | null
    createdAt: Date
    hash: string
    _count: EvaluationResultCountAggregateOutputType | null
    _avg: EvaluationResultAvgAggregateOutputType | null
    _sum: EvaluationResultSumAggregateOutputType | null
    _min: EvaluationResultMinAggregateOutputType | null
    _max: EvaluationResultMaxAggregateOutputType | null
  }

  type GetEvaluationResultGroupByPayload<T extends EvaluationResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationResultGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationResultGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    bidderId?: boolean
    functionalityScore?: boolean
    qualifies?: boolean
    price?: boolean
    priceScore?: boolean
    bbbeeLevel?: boolean
    bbbeePoints?: boolean
    totalScore?: boolean
    riskScore?: boolean
    complianceRate?: boolean
    exceptionsCount?: boolean
    slaBreached?: boolean
    currentStage?: boolean
    createdAt?: boolean
    hash?: boolean
    compliance?: boolean | EvaluationResult$complianceArgs<ExtArgs>
    exceptions?: boolean | EvaluationResult$exceptionsArgs<ExtArgs>
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
    tender?: boolean | TenderDefaultArgs<ExtArgs>
    workflowLogs?: boolean | EvaluationResult$workflowLogsArgs<ExtArgs>
    _count?: boolean | EvaluationResultCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationResult"]>

  export type EvaluationResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    bidderId?: boolean
    functionalityScore?: boolean
    qualifies?: boolean
    price?: boolean
    priceScore?: boolean
    bbbeeLevel?: boolean
    bbbeePoints?: boolean
    totalScore?: boolean
    riskScore?: boolean
    complianceRate?: boolean
    exceptionsCount?: boolean
    slaBreached?: boolean
    currentStage?: boolean
    createdAt?: boolean
    hash?: boolean
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationResult"]>

  export type EvaluationResultSelectScalar = {
    id?: boolean
    tenderId?: boolean
    bidderId?: boolean
    functionalityScore?: boolean
    qualifies?: boolean
    price?: boolean
    priceScore?: boolean
    bbbeeLevel?: boolean
    bbbeePoints?: boolean
    totalScore?: boolean
    riskScore?: boolean
    complianceRate?: boolean
    exceptionsCount?: boolean
    slaBreached?: boolean
    currentStage?: boolean
    createdAt?: boolean
    hash?: boolean
  }

  export type EvaluationResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compliance?: boolean | EvaluationResult$complianceArgs<ExtArgs>
    exceptions?: boolean | EvaluationResult$exceptionsArgs<ExtArgs>
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
    tender?: boolean | TenderDefaultArgs<ExtArgs>
    workflowLogs?: boolean | EvaluationResult$workflowLogsArgs<ExtArgs>
    _count?: boolean | EvaluationResultCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EvaluationResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }

  export type $EvaluationResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluationResult"
    objects: {
      compliance: Prisma.$ComplianceItemPayload<ExtArgs>[]
      exceptions: Prisma.$EvaluationExceptionPayload<ExtArgs>[]
      bidder: Prisma.$BidderPayload<ExtArgs>
      tender: Prisma.$TenderPayload<ExtArgs>
      workflowLogs: Prisma.$WorkflowLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenderId: string
      bidderId: string
      functionalityScore: number
      qualifies: boolean
      price: number
      priceScore: number
      bbbeeLevel: number | null
      bbbeePoints: number
      totalScore: number
      riskScore: number | null
      complianceRate: number | null
      exceptionsCount: number
      slaBreached: boolean
      currentStage: string | null
      createdAt: Date
      hash: string
    }, ExtArgs["result"]["evaluationResult"]>
    composites: {}
  }

  type EvaluationResultGetPayload<S extends boolean | null | undefined | EvaluationResultDefaultArgs> = $Result.GetResult<Prisma.$EvaluationResultPayload, S>

  type EvaluationResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationResultFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationResultCountAggregateInputType | true
    }

  export interface EvaluationResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluationResult'], meta: { name: 'EvaluationResult' } }
    /**
     * Find zero or one EvaluationResult that matches the filter.
     * @param {EvaluationResultFindUniqueArgs} args - Arguments to find a EvaluationResult
     * @example
     * // Get one EvaluationResult
     * const evaluationResult = await prisma.evaluationResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationResultFindUniqueArgs>(args: SelectSubset<T, EvaluationResultFindUniqueArgs<ExtArgs>>): Prisma__EvaluationResultClient<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvaluationResult that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvaluationResultFindUniqueOrThrowArgs} args - Arguments to find a EvaluationResult
     * @example
     * // Get one EvaluationResult
     * const evaluationResult = await prisma.evaluationResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationResultFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationResultClient<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvaluationResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationResultFindFirstArgs} args - Arguments to find a EvaluationResult
     * @example
     * // Get one EvaluationResult
     * const evaluationResult = await prisma.evaluationResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationResultFindFirstArgs>(args?: SelectSubset<T, EvaluationResultFindFirstArgs<ExtArgs>>): Prisma__EvaluationResultClient<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvaluationResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationResultFindFirstOrThrowArgs} args - Arguments to find a EvaluationResult
     * @example
     * // Get one EvaluationResult
     * const evaluationResult = await prisma.evaluationResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationResultFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationResultClient<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvaluationResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluationResults
     * const evaluationResults = await prisma.evaluationResult.findMany()
     * 
     * // Get first 10 EvaluationResults
     * const evaluationResults = await prisma.evaluationResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationResultWithIdOnly = await prisma.evaluationResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationResultFindManyArgs>(args?: SelectSubset<T, EvaluationResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvaluationResult.
     * @param {EvaluationResultCreateArgs} args - Arguments to create a EvaluationResult.
     * @example
     * // Create one EvaluationResult
     * const EvaluationResult = await prisma.evaluationResult.create({
     *   data: {
     *     // ... data to create a EvaluationResult
     *   }
     * })
     * 
     */
    create<T extends EvaluationResultCreateArgs>(args: SelectSubset<T, EvaluationResultCreateArgs<ExtArgs>>): Prisma__EvaluationResultClient<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvaluationResults.
     * @param {EvaluationResultCreateManyArgs} args - Arguments to create many EvaluationResults.
     * @example
     * // Create many EvaluationResults
     * const evaluationResult = await prisma.evaluationResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationResultCreateManyArgs>(args?: SelectSubset<T, EvaluationResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvaluationResults and returns the data saved in the database.
     * @param {EvaluationResultCreateManyAndReturnArgs} args - Arguments to create many EvaluationResults.
     * @example
     * // Create many EvaluationResults
     * const evaluationResult = await prisma.evaluationResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvaluationResults and only return the `id`
     * const evaluationResultWithIdOnly = await prisma.evaluationResult.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationResultCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvaluationResult.
     * @param {EvaluationResultDeleteArgs} args - Arguments to delete one EvaluationResult.
     * @example
     * // Delete one EvaluationResult
     * const EvaluationResult = await prisma.evaluationResult.delete({
     *   where: {
     *     // ... filter to delete one EvaluationResult
     *   }
     * })
     * 
     */
    delete<T extends EvaluationResultDeleteArgs>(args: SelectSubset<T, EvaluationResultDeleteArgs<ExtArgs>>): Prisma__EvaluationResultClient<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvaluationResult.
     * @param {EvaluationResultUpdateArgs} args - Arguments to update one EvaluationResult.
     * @example
     * // Update one EvaluationResult
     * const evaluationResult = await prisma.evaluationResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationResultUpdateArgs>(args: SelectSubset<T, EvaluationResultUpdateArgs<ExtArgs>>): Prisma__EvaluationResultClient<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvaluationResults.
     * @param {EvaluationResultDeleteManyArgs} args - Arguments to filter EvaluationResults to delete.
     * @example
     * // Delete a few EvaluationResults
     * const { count } = await prisma.evaluationResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationResultDeleteManyArgs>(args?: SelectSubset<T, EvaluationResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluationResults
     * const evaluationResult = await prisma.evaluationResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationResultUpdateManyArgs>(args: SelectSubset<T, EvaluationResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvaluationResult.
     * @param {EvaluationResultUpsertArgs} args - Arguments to update or create a EvaluationResult.
     * @example
     * // Update or create a EvaluationResult
     * const evaluationResult = await prisma.evaluationResult.upsert({
     *   create: {
     *     // ... data to create a EvaluationResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluationResult we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationResultUpsertArgs>(args: SelectSubset<T, EvaluationResultUpsertArgs<ExtArgs>>): Prisma__EvaluationResultClient<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvaluationResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationResultCountArgs} args - Arguments to filter EvaluationResults to count.
     * @example
     * // Count the number of EvaluationResults
     * const count = await prisma.evaluationResult.count({
     *   where: {
     *     // ... the filter for the EvaluationResults we want to count
     *   }
     * })
    **/
    count<T extends EvaluationResultCountArgs>(
      args?: Subset<T, EvaluationResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluationResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationResultAggregateArgs>(args: Subset<T, EvaluationResultAggregateArgs>): Prisma.PrismaPromise<GetEvaluationResultAggregateType<T>>

    /**
     * Group by EvaluationResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationResultGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluationResult model
   */
  readonly fields: EvaluationResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluationResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    compliance<T extends EvaluationResult$complianceArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationResult$complianceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "findMany"> | Null>
    exceptions<T extends EvaluationResult$exceptionsArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationResult$exceptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationExceptionPayload<ExtArgs>, T, "findMany"> | Null>
    bidder<T extends BidderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BidderDefaultArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tender<T extends TenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenderDefaultArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workflowLogs<T extends EvaluationResult$workflowLogsArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationResult$workflowLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaluationResult model
   */ 
  interface EvaluationResultFieldRefs {
    readonly id: FieldRef<"EvaluationResult", 'String'>
    readonly tenderId: FieldRef<"EvaluationResult", 'String'>
    readonly bidderId: FieldRef<"EvaluationResult", 'String'>
    readonly functionalityScore: FieldRef<"EvaluationResult", 'Float'>
    readonly qualifies: FieldRef<"EvaluationResult", 'Boolean'>
    readonly price: FieldRef<"EvaluationResult", 'Float'>
    readonly priceScore: FieldRef<"EvaluationResult", 'Float'>
    readonly bbbeeLevel: FieldRef<"EvaluationResult", 'Int'>
    readonly bbbeePoints: FieldRef<"EvaluationResult", 'Float'>
    readonly totalScore: FieldRef<"EvaluationResult", 'Float'>
    readonly riskScore: FieldRef<"EvaluationResult", 'Float'>
    readonly complianceRate: FieldRef<"EvaluationResult", 'Float'>
    readonly exceptionsCount: FieldRef<"EvaluationResult", 'Int'>
    readonly slaBreached: FieldRef<"EvaluationResult", 'Boolean'>
    readonly currentStage: FieldRef<"EvaluationResult", 'String'>
    readonly createdAt: FieldRef<"EvaluationResult", 'DateTime'>
    readonly hash: FieldRef<"EvaluationResult", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EvaluationResult findUnique
   */
  export type EvaluationResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationResult to fetch.
     */
    where: EvaluationResultWhereUniqueInput
  }

  /**
   * EvaluationResult findUniqueOrThrow
   */
  export type EvaluationResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationResult to fetch.
     */
    where: EvaluationResultWhereUniqueInput
  }

  /**
   * EvaluationResult findFirst
   */
  export type EvaluationResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationResult to fetch.
     */
    where?: EvaluationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationResults to fetch.
     */
    orderBy?: EvaluationResultOrderByWithRelationInput | EvaluationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationResults.
     */
    cursor?: EvaluationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationResults.
     */
    distinct?: EvaluationResultScalarFieldEnum | EvaluationResultScalarFieldEnum[]
  }

  /**
   * EvaluationResult findFirstOrThrow
   */
  export type EvaluationResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationResult to fetch.
     */
    where?: EvaluationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationResults to fetch.
     */
    orderBy?: EvaluationResultOrderByWithRelationInput | EvaluationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationResults.
     */
    cursor?: EvaluationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationResults.
     */
    distinct?: EvaluationResultScalarFieldEnum | EvaluationResultScalarFieldEnum[]
  }

  /**
   * EvaluationResult findMany
   */
  export type EvaluationResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationResults to fetch.
     */
    where?: EvaluationResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationResults to fetch.
     */
    orderBy?: EvaluationResultOrderByWithRelationInput | EvaluationResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluationResults.
     */
    cursor?: EvaluationResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationResults.
     */
    skip?: number
    distinct?: EvaluationResultScalarFieldEnum | EvaluationResultScalarFieldEnum[]
  }

  /**
   * EvaluationResult create
   */
  export type EvaluationResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaluationResult.
     */
    data: XOR<EvaluationResultCreateInput, EvaluationResultUncheckedCreateInput>
  }

  /**
   * EvaluationResult createMany
   */
  export type EvaluationResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluationResults.
     */
    data: EvaluationResultCreateManyInput | EvaluationResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvaluationResult createManyAndReturn
   */
  export type EvaluationResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvaluationResults.
     */
    data: EvaluationResultCreateManyInput | EvaluationResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvaluationResult update
   */
  export type EvaluationResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaluationResult.
     */
    data: XOR<EvaluationResultUpdateInput, EvaluationResultUncheckedUpdateInput>
    /**
     * Choose, which EvaluationResult to update.
     */
    where: EvaluationResultWhereUniqueInput
  }

  /**
   * EvaluationResult updateMany
   */
  export type EvaluationResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluationResults.
     */
    data: XOR<EvaluationResultUpdateManyMutationInput, EvaluationResultUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationResults to update
     */
    where?: EvaluationResultWhereInput
  }

  /**
   * EvaluationResult upsert
   */
  export type EvaluationResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaluationResult to update in case it exists.
     */
    where: EvaluationResultWhereUniqueInput
    /**
     * In case the EvaluationResult found by the `where` argument doesn't exist, create a new EvaluationResult with this data.
     */
    create: XOR<EvaluationResultCreateInput, EvaluationResultUncheckedCreateInput>
    /**
     * In case the EvaluationResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationResultUpdateInput, EvaluationResultUncheckedUpdateInput>
  }

  /**
   * EvaluationResult delete
   */
  export type EvaluationResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
    /**
     * Filter which EvaluationResult to delete.
     */
    where: EvaluationResultWhereUniqueInput
  }

  /**
   * EvaluationResult deleteMany
   */
  export type EvaluationResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationResults to delete
     */
    where?: EvaluationResultWhereInput
  }

  /**
   * EvaluationResult.compliance
   */
  export type EvaluationResult$complianceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
    where?: ComplianceItemWhereInput
    orderBy?: ComplianceItemOrderByWithRelationInput | ComplianceItemOrderByWithRelationInput[]
    cursor?: ComplianceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceItemScalarFieldEnum | ComplianceItemScalarFieldEnum[]
  }

  /**
   * EvaluationResult.exceptions
   */
  export type EvaluationResult$exceptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionInclude<ExtArgs> | null
    where?: EvaluationExceptionWhereInput
    orderBy?: EvaluationExceptionOrderByWithRelationInput | EvaluationExceptionOrderByWithRelationInput[]
    cursor?: EvaluationExceptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationExceptionScalarFieldEnum | EvaluationExceptionScalarFieldEnum[]
  }

  /**
   * EvaluationResult.workflowLogs
   */
  export type EvaluationResult$workflowLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogInclude<ExtArgs> | null
    where?: WorkflowLogWhereInput
    orderBy?: WorkflowLogOrderByWithRelationInput | WorkflowLogOrderByWithRelationInput[]
    cursor?: WorkflowLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowLogScalarFieldEnum | WorkflowLogScalarFieldEnum[]
  }

  /**
   * EvaluationResult without action
   */
  export type EvaluationResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationResult
     */
    select?: EvaluationResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationResultInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowLog
   */

  export type AggregateWorkflowLog = {
    _count: WorkflowLogCountAggregateOutputType | null
    _avg: WorkflowLogAvgAggregateOutputType | null
    _sum: WorkflowLogSumAggregateOutputType | null
    _min: WorkflowLogMinAggregateOutputType | null
    _max: WorkflowLogMaxAggregateOutputType | null
  }

  export type WorkflowLogAvgAggregateOutputType = {
    daysSpent: number | null
  }

  export type WorkflowLogSumAggregateOutputType = {
    daysSpent: number | null
  }

  export type WorkflowLogMinAggregateOutputType = {
    id: string | null
    evaluationResultId: string | null
    stage: string | null
    daysSpent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowLogMaxAggregateOutputType = {
    id: string | null
    evaluationResultId: string | null
    stage: string | null
    daysSpent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowLogCountAggregateOutputType = {
    id: number
    evaluationResultId: number
    stage: number
    daysSpent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowLogAvgAggregateInputType = {
    daysSpent?: true
  }

  export type WorkflowLogSumAggregateInputType = {
    daysSpent?: true
  }

  export type WorkflowLogMinAggregateInputType = {
    id?: true
    evaluationResultId?: true
    stage?: true
    daysSpent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowLogMaxAggregateInputType = {
    id?: true
    evaluationResultId?: true
    stage?: true
    daysSpent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowLogCountAggregateInputType = {
    id?: true
    evaluationResultId?: true
    stage?: true
    daysSpent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowLog to aggregate.
     */
    where?: WorkflowLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowLogs to fetch.
     */
    orderBy?: WorkflowLogOrderByWithRelationInput | WorkflowLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowLogs
    **/
    _count?: true | WorkflowLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowLogMaxAggregateInputType
  }

  export type GetWorkflowLogAggregateType<T extends WorkflowLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowLog[P]>
      : GetScalarType<T[P], AggregateWorkflowLog[P]>
  }




  export type WorkflowLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowLogWhereInput
    orderBy?: WorkflowLogOrderByWithAggregationInput | WorkflowLogOrderByWithAggregationInput[]
    by: WorkflowLogScalarFieldEnum[] | WorkflowLogScalarFieldEnum
    having?: WorkflowLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowLogCountAggregateInputType | true
    _avg?: WorkflowLogAvgAggregateInputType
    _sum?: WorkflowLogSumAggregateInputType
    _min?: WorkflowLogMinAggregateInputType
    _max?: WorkflowLogMaxAggregateInputType
  }

  export type WorkflowLogGroupByOutputType = {
    id: string
    evaluationResultId: string
    stage: string
    daysSpent: number
    createdAt: Date
    updatedAt: Date
    _count: WorkflowLogCountAggregateOutputType | null
    _avg: WorkflowLogAvgAggregateOutputType | null
    _sum: WorkflowLogSumAggregateOutputType | null
    _min: WorkflowLogMinAggregateOutputType | null
    _max: WorkflowLogMaxAggregateOutputType | null
  }

  type GetWorkflowLogGroupByPayload<T extends WorkflowLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowLogGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowLogGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluationResultId?: boolean
    stage?: boolean
    daysSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowLog"]>

  export type WorkflowLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluationResultId?: boolean
    stage?: boolean
    daysSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowLog"]>

  export type WorkflowLogSelectScalar = {
    id?: boolean
    evaluationResultId?: boolean
    stage?: boolean
    daysSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
  }
  export type WorkflowLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
  }

  export type $WorkflowLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowLog"
    objects: {
      evaluationResult: Prisma.$EvaluationResultPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      evaluationResultId: string
      stage: string
      daysSpent: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflowLog"]>
    composites: {}
  }

  type WorkflowLogGetPayload<S extends boolean | null | undefined | WorkflowLogDefaultArgs> = $Result.GetResult<Prisma.$WorkflowLogPayload, S>

  type WorkflowLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowLogCountAggregateInputType | true
    }

  export interface WorkflowLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowLog'], meta: { name: 'WorkflowLog' } }
    /**
     * Find zero or one WorkflowLog that matches the filter.
     * @param {WorkflowLogFindUniqueArgs} args - Arguments to find a WorkflowLog
     * @example
     * // Get one WorkflowLog
     * const workflowLog = await prisma.workflowLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowLogFindUniqueArgs>(args: SelectSubset<T, WorkflowLogFindUniqueArgs<ExtArgs>>): Prisma__WorkflowLogClient<$Result.GetResult<Prisma.$WorkflowLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowLogFindUniqueOrThrowArgs} args - Arguments to find a WorkflowLog
     * @example
     * // Get one WorkflowLog
     * const workflowLog = await prisma.workflowLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowLogClient<$Result.GetResult<Prisma.$WorkflowLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowLogFindFirstArgs} args - Arguments to find a WorkflowLog
     * @example
     * // Get one WorkflowLog
     * const workflowLog = await prisma.workflowLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowLogFindFirstArgs>(args?: SelectSubset<T, WorkflowLogFindFirstArgs<ExtArgs>>): Prisma__WorkflowLogClient<$Result.GetResult<Prisma.$WorkflowLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowLogFindFirstOrThrowArgs} args - Arguments to find a WorkflowLog
     * @example
     * // Get one WorkflowLog
     * const workflowLog = await prisma.workflowLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowLogClient<$Result.GetResult<Prisma.$WorkflowLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowLogs
     * const workflowLogs = await prisma.workflowLog.findMany()
     * 
     * // Get first 10 WorkflowLogs
     * const workflowLogs = await prisma.workflowLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowLogWithIdOnly = await prisma.workflowLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowLogFindManyArgs>(args?: SelectSubset<T, WorkflowLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowLog.
     * @param {WorkflowLogCreateArgs} args - Arguments to create a WorkflowLog.
     * @example
     * // Create one WorkflowLog
     * const WorkflowLog = await prisma.workflowLog.create({
     *   data: {
     *     // ... data to create a WorkflowLog
     *   }
     * })
     * 
     */
    create<T extends WorkflowLogCreateArgs>(args: SelectSubset<T, WorkflowLogCreateArgs<ExtArgs>>): Prisma__WorkflowLogClient<$Result.GetResult<Prisma.$WorkflowLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowLogs.
     * @param {WorkflowLogCreateManyArgs} args - Arguments to create many WorkflowLogs.
     * @example
     * // Create many WorkflowLogs
     * const workflowLog = await prisma.workflowLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowLogCreateManyArgs>(args?: SelectSubset<T, WorkflowLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowLogs and returns the data saved in the database.
     * @param {WorkflowLogCreateManyAndReturnArgs} args - Arguments to create many WorkflowLogs.
     * @example
     * // Create many WorkflowLogs
     * const workflowLog = await prisma.workflowLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowLogs and only return the `id`
     * const workflowLogWithIdOnly = await prisma.workflowLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowLogCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowLog.
     * @param {WorkflowLogDeleteArgs} args - Arguments to delete one WorkflowLog.
     * @example
     * // Delete one WorkflowLog
     * const WorkflowLog = await prisma.workflowLog.delete({
     *   where: {
     *     // ... filter to delete one WorkflowLog
     *   }
     * })
     * 
     */
    delete<T extends WorkflowLogDeleteArgs>(args: SelectSubset<T, WorkflowLogDeleteArgs<ExtArgs>>): Prisma__WorkflowLogClient<$Result.GetResult<Prisma.$WorkflowLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowLog.
     * @param {WorkflowLogUpdateArgs} args - Arguments to update one WorkflowLog.
     * @example
     * // Update one WorkflowLog
     * const workflowLog = await prisma.workflowLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowLogUpdateArgs>(args: SelectSubset<T, WorkflowLogUpdateArgs<ExtArgs>>): Prisma__WorkflowLogClient<$Result.GetResult<Prisma.$WorkflowLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowLogs.
     * @param {WorkflowLogDeleteManyArgs} args - Arguments to filter WorkflowLogs to delete.
     * @example
     * // Delete a few WorkflowLogs
     * const { count } = await prisma.workflowLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowLogDeleteManyArgs>(args?: SelectSubset<T, WorkflowLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowLogs
     * const workflowLog = await prisma.workflowLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowLogUpdateManyArgs>(args: SelectSubset<T, WorkflowLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowLog.
     * @param {WorkflowLogUpsertArgs} args - Arguments to update or create a WorkflowLog.
     * @example
     * // Update or create a WorkflowLog
     * const workflowLog = await prisma.workflowLog.upsert({
     *   create: {
     *     // ... data to create a WorkflowLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowLog we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowLogUpsertArgs>(args: SelectSubset<T, WorkflowLogUpsertArgs<ExtArgs>>): Prisma__WorkflowLogClient<$Result.GetResult<Prisma.$WorkflowLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowLogCountArgs} args - Arguments to filter WorkflowLogs to count.
     * @example
     * // Count the number of WorkflowLogs
     * const count = await prisma.workflowLog.count({
     *   where: {
     *     // ... the filter for the WorkflowLogs we want to count
     *   }
     * })
    **/
    count<T extends WorkflowLogCountArgs>(
      args?: Subset<T, WorkflowLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowLogAggregateArgs>(args: Subset<T, WorkflowLogAggregateArgs>): Prisma.PrismaPromise<GetWorkflowLogAggregateType<T>>

    /**
     * Group by WorkflowLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowLogGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowLog model
   */
  readonly fields: WorkflowLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluationResult<T extends EvaluationResultDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationResultDefaultArgs<ExtArgs>>): Prisma__EvaluationResultClient<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowLog model
   */ 
  interface WorkflowLogFieldRefs {
    readonly id: FieldRef<"WorkflowLog", 'String'>
    readonly evaluationResultId: FieldRef<"WorkflowLog", 'String'>
    readonly stage: FieldRef<"WorkflowLog", 'String'>
    readonly daysSpent: FieldRef<"WorkflowLog", 'Float'>
    readonly createdAt: FieldRef<"WorkflowLog", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowLog findUnique
   */
  export type WorkflowLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowLog to fetch.
     */
    where: WorkflowLogWhereUniqueInput
  }

  /**
   * WorkflowLog findUniqueOrThrow
   */
  export type WorkflowLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowLog to fetch.
     */
    where: WorkflowLogWhereUniqueInput
  }

  /**
   * WorkflowLog findFirst
   */
  export type WorkflowLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowLog to fetch.
     */
    where?: WorkflowLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowLogs to fetch.
     */
    orderBy?: WorkflowLogOrderByWithRelationInput | WorkflowLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowLogs.
     */
    cursor?: WorkflowLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowLogs.
     */
    distinct?: WorkflowLogScalarFieldEnum | WorkflowLogScalarFieldEnum[]
  }

  /**
   * WorkflowLog findFirstOrThrow
   */
  export type WorkflowLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowLog to fetch.
     */
    where?: WorkflowLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowLogs to fetch.
     */
    orderBy?: WorkflowLogOrderByWithRelationInput | WorkflowLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowLogs.
     */
    cursor?: WorkflowLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowLogs.
     */
    distinct?: WorkflowLogScalarFieldEnum | WorkflowLogScalarFieldEnum[]
  }

  /**
   * WorkflowLog findMany
   */
  export type WorkflowLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowLogs to fetch.
     */
    where?: WorkflowLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowLogs to fetch.
     */
    orderBy?: WorkflowLogOrderByWithRelationInput | WorkflowLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowLogs.
     */
    cursor?: WorkflowLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowLogs.
     */
    skip?: number
    distinct?: WorkflowLogScalarFieldEnum | WorkflowLogScalarFieldEnum[]
  }

  /**
   * WorkflowLog create
   */
  export type WorkflowLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowLog.
     */
    data: XOR<WorkflowLogCreateInput, WorkflowLogUncheckedCreateInput>
  }

  /**
   * WorkflowLog createMany
   */
  export type WorkflowLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowLogs.
     */
    data: WorkflowLogCreateManyInput | WorkflowLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowLog createManyAndReturn
   */
  export type WorkflowLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowLogs.
     */
    data: WorkflowLogCreateManyInput | WorkflowLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowLog update
   */
  export type WorkflowLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowLog.
     */
    data: XOR<WorkflowLogUpdateInput, WorkflowLogUncheckedUpdateInput>
    /**
     * Choose, which WorkflowLog to update.
     */
    where: WorkflowLogWhereUniqueInput
  }

  /**
   * WorkflowLog updateMany
   */
  export type WorkflowLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowLogs.
     */
    data: XOR<WorkflowLogUpdateManyMutationInput, WorkflowLogUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowLogs to update
     */
    where?: WorkflowLogWhereInput
  }

  /**
   * WorkflowLog upsert
   */
  export type WorkflowLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowLog to update in case it exists.
     */
    where: WorkflowLogWhereUniqueInput
    /**
     * In case the WorkflowLog found by the `where` argument doesn't exist, create a new WorkflowLog with this data.
     */
    create: XOR<WorkflowLogCreateInput, WorkflowLogUncheckedCreateInput>
    /**
     * In case the WorkflowLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowLogUpdateInput, WorkflowLogUncheckedUpdateInput>
  }

  /**
   * WorkflowLog delete
   */
  export type WorkflowLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogInclude<ExtArgs> | null
    /**
     * Filter which WorkflowLog to delete.
     */
    where: WorkflowLogWhereUniqueInput
  }

  /**
   * WorkflowLog deleteMany
   */
  export type WorkflowLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowLogs to delete
     */
    where?: WorkflowLogWhereInput
  }

  /**
   * WorkflowLog without action
   */
  export type WorkflowLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowLog
     */
    select?: WorkflowLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowLogInclude<ExtArgs> | null
  }


  /**
   * Model Circular
   */

  export type AggregateCircular = {
    _count: CircularCountAggregateOutputType | null
    _min: CircularMinAggregateOutputType | null
    _max: CircularMaxAggregateOutputType | null
  }

  export type CircularMinAggregateOutputType = {
    id: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CircularMaxAggregateOutputType = {
    id: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CircularCountAggregateOutputType = {
    id: number
    label: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CircularMinAggregateInputType = {
    id?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CircularMaxAggregateInputType = {
    id?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CircularCountAggregateInputType = {
    id?: true
    label?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CircularAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Circular to aggregate.
     */
    where?: CircularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circulars to fetch.
     */
    orderBy?: CircularOrderByWithRelationInput | CircularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CircularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circulars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circulars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Circulars
    **/
    _count?: true | CircularCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CircularMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CircularMaxAggregateInputType
  }

  export type GetCircularAggregateType<T extends CircularAggregateArgs> = {
        [P in keyof T & keyof AggregateCircular]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCircular[P]>
      : GetScalarType<T[P], AggregateCircular[P]>
  }




  export type CircularGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CircularWhereInput
    orderBy?: CircularOrderByWithAggregationInput | CircularOrderByWithAggregationInput[]
    by: CircularScalarFieldEnum[] | CircularScalarFieldEnum
    having?: CircularScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CircularCountAggregateInputType | true
    _min?: CircularMinAggregateInputType
    _max?: CircularMaxAggregateInputType
  }

  export type CircularGroupByOutputType = {
    id: string
    label: string
    createdAt: Date
    updatedAt: Date
    _count: CircularCountAggregateOutputType | null
    _min: CircularMinAggregateOutputType | null
    _max: CircularMaxAggregateOutputType | null
  }

  type GetCircularGroupByPayload<T extends CircularGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CircularGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CircularGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CircularGroupByOutputType[P]>
            : GetScalarType<T[P], CircularGroupByOutputType[P]>
        }
      >
    >


  export type CircularSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rules?: boolean | Circular$rulesArgs<ExtArgs>
    _count?: boolean | CircularCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["circular"]>

  export type CircularSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["circular"]>

  export type CircularSelectScalar = {
    id?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CircularInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rules?: boolean | Circular$rulesArgs<ExtArgs>
    _count?: boolean | CircularCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CircularIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CircularPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Circular"
    objects: {
      rules: Prisma.$ComplianceRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["circular"]>
    composites: {}
  }

  type CircularGetPayload<S extends boolean | null | undefined | CircularDefaultArgs> = $Result.GetResult<Prisma.$CircularPayload, S>

  type CircularCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CircularFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CircularCountAggregateInputType | true
    }

  export interface CircularDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Circular'], meta: { name: 'Circular' } }
    /**
     * Find zero or one Circular that matches the filter.
     * @param {CircularFindUniqueArgs} args - Arguments to find a Circular
     * @example
     * // Get one Circular
     * const circular = await prisma.circular.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CircularFindUniqueArgs>(args: SelectSubset<T, CircularFindUniqueArgs<ExtArgs>>): Prisma__CircularClient<$Result.GetResult<Prisma.$CircularPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Circular that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CircularFindUniqueOrThrowArgs} args - Arguments to find a Circular
     * @example
     * // Get one Circular
     * const circular = await prisma.circular.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CircularFindUniqueOrThrowArgs>(args: SelectSubset<T, CircularFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CircularClient<$Result.GetResult<Prisma.$CircularPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Circular that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircularFindFirstArgs} args - Arguments to find a Circular
     * @example
     * // Get one Circular
     * const circular = await prisma.circular.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CircularFindFirstArgs>(args?: SelectSubset<T, CircularFindFirstArgs<ExtArgs>>): Prisma__CircularClient<$Result.GetResult<Prisma.$CircularPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Circular that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircularFindFirstOrThrowArgs} args - Arguments to find a Circular
     * @example
     * // Get one Circular
     * const circular = await prisma.circular.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CircularFindFirstOrThrowArgs>(args?: SelectSubset<T, CircularFindFirstOrThrowArgs<ExtArgs>>): Prisma__CircularClient<$Result.GetResult<Prisma.$CircularPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Circulars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircularFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Circulars
     * const circulars = await prisma.circular.findMany()
     * 
     * // Get first 10 Circulars
     * const circulars = await prisma.circular.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const circularWithIdOnly = await prisma.circular.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CircularFindManyArgs>(args?: SelectSubset<T, CircularFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircularPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Circular.
     * @param {CircularCreateArgs} args - Arguments to create a Circular.
     * @example
     * // Create one Circular
     * const Circular = await prisma.circular.create({
     *   data: {
     *     // ... data to create a Circular
     *   }
     * })
     * 
     */
    create<T extends CircularCreateArgs>(args: SelectSubset<T, CircularCreateArgs<ExtArgs>>): Prisma__CircularClient<$Result.GetResult<Prisma.$CircularPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Circulars.
     * @param {CircularCreateManyArgs} args - Arguments to create many Circulars.
     * @example
     * // Create many Circulars
     * const circular = await prisma.circular.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CircularCreateManyArgs>(args?: SelectSubset<T, CircularCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Circulars and returns the data saved in the database.
     * @param {CircularCreateManyAndReturnArgs} args - Arguments to create many Circulars.
     * @example
     * // Create many Circulars
     * const circular = await prisma.circular.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Circulars and only return the `id`
     * const circularWithIdOnly = await prisma.circular.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CircularCreateManyAndReturnArgs>(args?: SelectSubset<T, CircularCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircularPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Circular.
     * @param {CircularDeleteArgs} args - Arguments to delete one Circular.
     * @example
     * // Delete one Circular
     * const Circular = await prisma.circular.delete({
     *   where: {
     *     // ... filter to delete one Circular
     *   }
     * })
     * 
     */
    delete<T extends CircularDeleteArgs>(args: SelectSubset<T, CircularDeleteArgs<ExtArgs>>): Prisma__CircularClient<$Result.GetResult<Prisma.$CircularPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Circular.
     * @param {CircularUpdateArgs} args - Arguments to update one Circular.
     * @example
     * // Update one Circular
     * const circular = await prisma.circular.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CircularUpdateArgs>(args: SelectSubset<T, CircularUpdateArgs<ExtArgs>>): Prisma__CircularClient<$Result.GetResult<Prisma.$CircularPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Circulars.
     * @param {CircularDeleteManyArgs} args - Arguments to filter Circulars to delete.
     * @example
     * // Delete a few Circulars
     * const { count } = await prisma.circular.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CircularDeleteManyArgs>(args?: SelectSubset<T, CircularDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Circulars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircularUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Circulars
     * const circular = await prisma.circular.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CircularUpdateManyArgs>(args: SelectSubset<T, CircularUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Circular.
     * @param {CircularUpsertArgs} args - Arguments to update or create a Circular.
     * @example
     * // Update or create a Circular
     * const circular = await prisma.circular.upsert({
     *   create: {
     *     // ... data to create a Circular
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Circular we want to update
     *   }
     * })
     */
    upsert<T extends CircularUpsertArgs>(args: SelectSubset<T, CircularUpsertArgs<ExtArgs>>): Prisma__CircularClient<$Result.GetResult<Prisma.$CircularPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Circulars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircularCountArgs} args - Arguments to filter Circulars to count.
     * @example
     * // Count the number of Circulars
     * const count = await prisma.circular.count({
     *   where: {
     *     // ... the filter for the Circulars we want to count
     *   }
     * })
    **/
    count<T extends CircularCountArgs>(
      args?: Subset<T, CircularCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CircularCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Circular.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircularAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CircularAggregateArgs>(args: Subset<T, CircularAggregateArgs>): Prisma.PrismaPromise<GetCircularAggregateType<T>>

    /**
     * Group by Circular.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircularGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CircularGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CircularGroupByArgs['orderBy'] }
        : { orderBy?: CircularGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CircularGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCircularGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Circular model
   */
  readonly fields: CircularFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Circular.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CircularClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rules<T extends Circular$rulesArgs<ExtArgs> = {}>(args?: Subset<T, Circular$rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Circular model
   */ 
  interface CircularFieldRefs {
    readonly id: FieldRef<"Circular", 'String'>
    readonly label: FieldRef<"Circular", 'String'>
    readonly createdAt: FieldRef<"Circular", 'DateTime'>
    readonly updatedAt: FieldRef<"Circular", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Circular findUnique
   */
  export type CircularFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circular
     */
    select?: CircularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircularInclude<ExtArgs> | null
    /**
     * Filter, which Circular to fetch.
     */
    where: CircularWhereUniqueInput
  }

  /**
   * Circular findUniqueOrThrow
   */
  export type CircularFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circular
     */
    select?: CircularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircularInclude<ExtArgs> | null
    /**
     * Filter, which Circular to fetch.
     */
    where: CircularWhereUniqueInput
  }

  /**
   * Circular findFirst
   */
  export type CircularFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circular
     */
    select?: CircularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircularInclude<ExtArgs> | null
    /**
     * Filter, which Circular to fetch.
     */
    where?: CircularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circulars to fetch.
     */
    orderBy?: CircularOrderByWithRelationInput | CircularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Circulars.
     */
    cursor?: CircularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circulars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circulars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Circulars.
     */
    distinct?: CircularScalarFieldEnum | CircularScalarFieldEnum[]
  }

  /**
   * Circular findFirstOrThrow
   */
  export type CircularFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circular
     */
    select?: CircularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircularInclude<ExtArgs> | null
    /**
     * Filter, which Circular to fetch.
     */
    where?: CircularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circulars to fetch.
     */
    orderBy?: CircularOrderByWithRelationInput | CircularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Circulars.
     */
    cursor?: CircularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circulars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circulars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Circulars.
     */
    distinct?: CircularScalarFieldEnum | CircularScalarFieldEnum[]
  }

  /**
   * Circular findMany
   */
  export type CircularFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circular
     */
    select?: CircularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircularInclude<ExtArgs> | null
    /**
     * Filter, which Circulars to fetch.
     */
    where?: CircularWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circulars to fetch.
     */
    orderBy?: CircularOrderByWithRelationInput | CircularOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Circulars.
     */
    cursor?: CircularWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circulars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circulars.
     */
    skip?: number
    distinct?: CircularScalarFieldEnum | CircularScalarFieldEnum[]
  }

  /**
   * Circular create
   */
  export type CircularCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circular
     */
    select?: CircularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircularInclude<ExtArgs> | null
    /**
     * The data needed to create a Circular.
     */
    data: XOR<CircularCreateInput, CircularUncheckedCreateInput>
  }

  /**
   * Circular createMany
   */
  export type CircularCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Circulars.
     */
    data: CircularCreateManyInput | CircularCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Circular createManyAndReturn
   */
  export type CircularCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circular
     */
    select?: CircularSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Circulars.
     */
    data: CircularCreateManyInput | CircularCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Circular update
   */
  export type CircularUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circular
     */
    select?: CircularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircularInclude<ExtArgs> | null
    /**
     * The data needed to update a Circular.
     */
    data: XOR<CircularUpdateInput, CircularUncheckedUpdateInput>
    /**
     * Choose, which Circular to update.
     */
    where: CircularWhereUniqueInput
  }

  /**
   * Circular updateMany
   */
  export type CircularUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Circulars.
     */
    data: XOR<CircularUpdateManyMutationInput, CircularUncheckedUpdateManyInput>
    /**
     * Filter which Circulars to update
     */
    where?: CircularWhereInput
  }

  /**
   * Circular upsert
   */
  export type CircularUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circular
     */
    select?: CircularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircularInclude<ExtArgs> | null
    /**
     * The filter to search for the Circular to update in case it exists.
     */
    where: CircularWhereUniqueInput
    /**
     * In case the Circular found by the `where` argument doesn't exist, create a new Circular with this data.
     */
    create: XOR<CircularCreateInput, CircularUncheckedCreateInput>
    /**
     * In case the Circular was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CircularUpdateInput, CircularUncheckedUpdateInput>
  }

  /**
   * Circular delete
   */
  export type CircularDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circular
     */
    select?: CircularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircularInclude<ExtArgs> | null
    /**
     * Filter which Circular to delete.
     */
    where: CircularWhereUniqueInput
  }

  /**
   * Circular deleteMany
   */
  export type CircularDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Circulars to delete
     */
    where?: CircularWhereInput
  }

  /**
   * Circular.rules
   */
  export type Circular$rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleInclude<ExtArgs> | null
    where?: ComplianceRuleWhereInput
    orderBy?: ComplianceRuleOrderByWithRelationInput | ComplianceRuleOrderByWithRelationInput[]
    cursor?: ComplianceRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceRuleScalarFieldEnum | ComplianceRuleScalarFieldEnum[]
  }

  /**
   * Circular without action
   */
  export type CircularDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circular
     */
    select?: CircularSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircularInclude<ExtArgs> | null
  }


  /**
   * Model ComplianceRule
   */

  export type AggregateComplianceRule = {
    _count: ComplianceRuleCountAggregateOutputType | null
    _min: ComplianceRuleMinAggregateOutputType | null
    _max: ComplianceRuleMaxAggregateOutputType | null
  }

  export type ComplianceRuleMinAggregateOutputType = {
    id: string | null
    circularId: string | null
    code: string | null
    label: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceRuleMaxAggregateOutputType = {
    id: string | null
    circularId: string | null
    code: string | null
    label: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceRuleCountAggregateOutputType = {
    id: number
    circularId: number
    code: number
    label: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplianceRuleMinAggregateInputType = {
    id?: true
    circularId?: true
    code?: true
    label?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceRuleMaxAggregateInputType = {
    id?: true
    circularId?: true
    code?: true
    label?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceRuleCountAggregateInputType = {
    id?: true
    circularId?: true
    code?: true
    label?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplianceRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceRule to aggregate.
     */
    where?: ComplianceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceRules to fetch.
     */
    orderBy?: ComplianceRuleOrderByWithRelationInput | ComplianceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplianceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplianceRules
    **/
    _count?: true | ComplianceRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplianceRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplianceRuleMaxAggregateInputType
  }

  export type GetComplianceRuleAggregateType<T extends ComplianceRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateComplianceRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplianceRule[P]>
      : GetScalarType<T[P], AggregateComplianceRule[P]>
  }




  export type ComplianceRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceRuleWhereInput
    orderBy?: ComplianceRuleOrderByWithAggregationInput | ComplianceRuleOrderByWithAggregationInput[]
    by: ComplianceRuleScalarFieldEnum[] | ComplianceRuleScalarFieldEnum
    having?: ComplianceRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplianceRuleCountAggregateInputType | true
    _min?: ComplianceRuleMinAggregateInputType
    _max?: ComplianceRuleMaxAggregateInputType
  }

  export type ComplianceRuleGroupByOutputType = {
    id: string
    circularId: string
    code: string
    label: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ComplianceRuleCountAggregateOutputType | null
    _min: ComplianceRuleMinAggregateOutputType | null
    _max: ComplianceRuleMaxAggregateOutputType | null
  }

  type GetComplianceRuleGroupByPayload<T extends ComplianceRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplianceRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplianceRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplianceRuleGroupByOutputType[P]>
            : GetScalarType<T[P], ComplianceRuleGroupByOutputType[P]>
        }
      >
    >


  export type ComplianceRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    circularId?: boolean
    code?: boolean
    label?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | ComplianceRule$itemsArgs<ExtArgs>
    circular?: boolean | CircularDefaultArgs<ExtArgs>
    _count?: boolean | ComplianceRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceRule"]>

  export type ComplianceRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    circularId?: boolean
    code?: boolean
    label?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    circular?: boolean | CircularDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceRule"]>

  export type ComplianceRuleSelectScalar = {
    id?: boolean
    circularId?: boolean
    code?: boolean
    label?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplianceRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ComplianceRule$itemsArgs<ExtArgs>
    circular?: boolean | CircularDefaultArgs<ExtArgs>
    _count?: boolean | ComplianceRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComplianceRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    circular?: boolean | CircularDefaultArgs<ExtArgs>
  }

  export type $ComplianceRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplianceRule"
    objects: {
      items: Prisma.$ComplianceItemPayload<ExtArgs>[]
      circular: Prisma.$CircularPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      circularId: string
      code: string
      label: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complianceRule"]>
    composites: {}
  }

  type ComplianceRuleGetPayload<S extends boolean | null | undefined | ComplianceRuleDefaultArgs> = $Result.GetResult<Prisma.$ComplianceRulePayload, S>

  type ComplianceRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComplianceRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplianceRuleCountAggregateInputType | true
    }

  export interface ComplianceRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplianceRule'], meta: { name: 'ComplianceRule' } }
    /**
     * Find zero or one ComplianceRule that matches the filter.
     * @param {ComplianceRuleFindUniqueArgs} args - Arguments to find a ComplianceRule
     * @example
     * // Get one ComplianceRule
     * const complianceRule = await prisma.complianceRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplianceRuleFindUniqueArgs>(args: SelectSubset<T, ComplianceRuleFindUniqueArgs<ExtArgs>>): Prisma__ComplianceRuleClient<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComplianceRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComplianceRuleFindUniqueOrThrowArgs} args - Arguments to find a ComplianceRule
     * @example
     * // Get one ComplianceRule
     * const complianceRule = await prisma.complianceRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplianceRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplianceRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplianceRuleClient<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComplianceRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceRuleFindFirstArgs} args - Arguments to find a ComplianceRule
     * @example
     * // Get one ComplianceRule
     * const complianceRule = await prisma.complianceRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplianceRuleFindFirstArgs>(args?: SelectSubset<T, ComplianceRuleFindFirstArgs<ExtArgs>>): Prisma__ComplianceRuleClient<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComplianceRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceRuleFindFirstOrThrowArgs} args - Arguments to find a ComplianceRule
     * @example
     * // Get one ComplianceRule
     * const complianceRule = await prisma.complianceRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplianceRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplianceRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplianceRuleClient<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComplianceRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplianceRules
     * const complianceRules = await prisma.complianceRule.findMany()
     * 
     * // Get first 10 ComplianceRules
     * const complianceRules = await prisma.complianceRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complianceRuleWithIdOnly = await prisma.complianceRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplianceRuleFindManyArgs>(args?: SelectSubset<T, ComplianceRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComplianceRule.
     * @param {ComplianceRuleCreateArgs} args - Arguments to create a ComplianceRule.
     * @example
     * // Create one ComplianceRule
     * const ComplianceRule = await prisma.complianceRule.create({
     *   data: {
     *     // ... data to create a ComplianceRule
     *   }
     * })
     * 
     */
    create<T extends ComplianceRuleCreateArgs>(args: SelectSubset<T, ComplianceRuleCreateArgs<ExtArgs>>): Prisma__ComplianceRuleClient<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComplianceRules.
     * @param {ComplianceRuleCreateManyArgs} args - Arguments to create many ComplianceRules.
     * @example
     * // Create many ComplianceRules
     * const complianceRule = await prisma.complianceRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplianceRuleCreateManyArgs>(args?: SelectSubset<T, ComplianceRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplianceRules and returns the data saved in the database.
     * @param {ComplianceRuleCreateManyAndReturnArgs} args - Arguments to create many ComplianceRules.
     * @example
     * // Create many ComplianceRules
     * const complianceRule = await prisma.complianceRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplianceRules and only return the `id`
     * const complianceRuleWithIdOnly = await prisma.complianceRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplianceRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplianceRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComplianceRule.
     * @param {ComplianceRuleDeleteArgs} args - Arguments to delete one ComplianceRule.
     * @example
     * // Delete one ComplianceRule
     * const ComplianceRule = await prisma.complianceRule.delete({
     *   where: {
     *     // ... filter to delete one ComplianceRule
     *   }
     * })
     * 
     */
    delete<T extends ComplianceRuleDeleteArgs>(args: SelectSubset<T, ComplianceRuleDeleteArgs<ExtArgs>>): Prisma__ComplianceRuleClient<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComplianceRule.
     * @param {ComplianceRuleUpdateArgs} args - Arguments to update one ComplianceRule.
     * @example
     * // Update one ComplianceRule
     * const complianceRule = await prisma.complianceRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplianceRuleUpdateArgs>(args: SelectSubset<T, ComplianceRuleUpdateArgs<ExtArgs>>): Prisma__ComplianceRuleClient<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComplianceRules.
     * @param {ComplianceRuleDeleteManyArgs} args - Arguments to filter ComplianceRules to delete.
     * @example
     * // Delete a few ComplianceRules
     * const { count } = await prisma.complianceRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplianceRuleDeleteManyArgs>(args?: SelectSubset<T, ComplianceRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplianceRules
     * const complianceRule = await prisma.complianceRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplianceRuleUpdateManyArgs>(args: SelectSubset<T, ComplianceRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplianceRule.
     * @param {ComplianceRuleUpsertArgs} args - Arguments to update or create a ComplianceRule.
     * @example
     * // Update or create a ComplianceRule
     * const complianceRule = await prisma.complianceRule.upsert({
     *   create: {
     *     // ... data to create a ComplianceRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplianceRule we want to update
     *   }
     * })
     */
    upsert<T extends ComplianceRuleUpsertArgs>(args: SelectSubset<T, ComplianceRuleUpsertArgs<ExtArgs>>): Prisma__ComplianceRuleClient<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComplianceRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceRuleCountArgs} args - Arguments to filter ComplianceRules to count.
     * @example
     * // Count the number of ComplianceRules
     * const count = await prisma.complianceRule.count({
     *   where: {
     *     // ... the filter for the ComplianceRules we want to count
     *   }
     * })
    **/
    count<T extends ComplianceRuleCountArgs>(
      args?: Subset<T, ComplianceRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplianceRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplianceRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplianceRuleAggregateArgs>(args: Subset<T, ComplianceRuleAggregateArgs>): Prisma.PrismaPromise<GetComplianceRuleAggregateType<T>>

    /**
     * Group by ComplianceRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplianceRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplianceRuleGroupByArgs['orderBy'] }
        : { orderBy?: ComplianceRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplianceRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplianceRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplianceRule model
   */
  readonly fields: ComplianceRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplianceRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplianceRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends ComplianceRule$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ComplianceRule$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "findMany"> | Null>
    circular<T extends CircularDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CircularDefaultArgs<ExtArgs>>): Prisma__CircularClient<$Result.GetResult<Prisma.$CircularPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplianceRule model
   */ 
  interface ComplianceRuleFieldRefs {
    readonly id: FieldRef<"ComplianceRule", 'String'>
    readonly circularId: FieldRef<"ComplianceRule", 'String'>
    readonly code: FieldRef<"ComplianceRule", 'String'>
    readonly label: FieldRef<"ComplianceRule", 'String'>
    readonly description: FieldRef<"ComplianceRule", 'String'>
    readonly createdAt: FieldRef<"ComplianceRule", 'DateTime'>
    readonly updatedAt: FieldRef<"ComplianceRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplianceRule findUnique
   */
  export type ComplianceRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceRule to fetch.
     */
    where: ComplianceRuleWhereUniqueInput
  }

  /**
   * ComplianceRule findUniqueOrThrow
   */
  export type ComplianceRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceRule to fetch.
     */
    where: ComplianceRuleWhereUniqueInput
  }

  /**
   * ComplianceRule findFirst
   */
  export type ComplianceRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceRule to fetch.
     */
    where?: ComplianceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceRules to fetch.
     */
    orderBy?: ComplianceRuleOrderByWithRelationInput | ComplianceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceRules.
     */
    cursor?: ComplianceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceRules.
     */
    distinct?: ComplianceRuleScalarFieldEnum | ComplianceRuleScalarFieldEnum[]
  }

  /**
   * ComplianceRule findFirstOrThrow
   */
  export type ComplianceRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceRule to fetch.
     */
    where?: ComplianceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceRules to fetch.
     */
    orderBy?: ComplianceRuleOrderByWithRelationInput | ComplianceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceRules.
     */
    cursor?: ComplianceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceRules.
     */
    distinct?: ComplianceRuleScalarFieldEnum | ComplianceRuleScalarFieldEnum[]
  }

  /**
   * ComplianceRule findMany
   */
  export type ComplianceRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceRules to fetch.
     */
    where?: ComplianceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceRules to fetch.
     */
    orderBy?: ComplianceRuleOrderByWithRelationInput | ComplianceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplianceRules.
     */
    cursor?: ComplianceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceRules.
     */
    skip?: number
    distinct?: ComplianceRuleScalarFieldEnum | ComplianceRuleScalarFieldEnum[]
  }

  /**
   * ComplianceRule create
   */
  export type ComplianceRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplianceRule.
     */
    data: XOR<ComplianceRuleCreateInput, ComplianceRuleUncheckedCreateInput>
  }

  /**
   * ComplianceRule createMany
   */
  export type ComplianceRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplianceRules.
     */
    data: ComplianceRuleCreateManyInput | ComplianceRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplianceRule createManyAndReturn
   */
  export type ComplianceRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComplianceRules.
     */
    data: ComplianceRuleCreateManyInput | ComplianceRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplianceRule update
   */
  export type ComplianceRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplianceRule.
     */
    data: XOR<ComplianceRuleUpdateInput, ComplianceRuleUncheckedUpdateInput>
    /**
     * Choose, which ComplianceRule to update.
     */
    where: ComplianceRuleWhereUniqueInput
  }

  /**
   * ComplianceRule updateMany
   */
  export type ComplianceRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplianceRules.
     */
    data: XOR<ComplianceRuleUpdateManyMutationInput, ComplianceRuleUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceRules to update
     */
    where?: ComplianceRuleWhereInput
  }

  /**
   * ComplianceRule upsert
   */
  export type ComplianceRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplianceRule to update in case it exists.
     */
    where: ComplianceRuleWhereUniqueInput
    /**
     * In case the ComplianceRule found by the `where` argument doesn't exist, create a new ComplianceRule with this data.
     */
    create: XOR<ComplianceRuleCreateInput, ComplianceRuleUncheckedCreateInput>
    /**
     * In case the ComplianceRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplianceRuleUpdateInput, ComplianceRuleUncheckedUpdateInput>
  }

  /**
   * ComplianceRule delete
   */
  export type ComplianceRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleInclude<ExtArgs> | null
    /**
     * Filter which ComplianceRule to delete.
     */
    where: ComplianceRuleWhereUniqueInput
  }

  /**
   * ComplianceRule deleteMany
   */
  export type ComplianceRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceRules to delete
     */
    where?: ComplianceRuleWhereInput
  }

  /**
   * ComplianceRule.items
   */
  export type ComplianceRule$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
    where?: ComplianceItemWhereInput
    orderBy?: ComplianceItemOrderByWithRelationInput | ComplianceItemOrderByWithRelationInput[]
    cursor?: ComplianceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceItemScalarFieldEnum | ComplianceItemScalarFieldEnum[]
  }

  /**
   * ComplianceRule without action
   */
  export type ComplianceRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceRule
     */
    select?: ComplianceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceRuleInclude<ExtArgs> | null
  }


  /**
   * Model ComplianceItem
   */

  export type AggregateComplianceItem = {
    _count: ComplianceItemCountAggregateOutputType | null
    _min: ComplianceItemMinAggregateOutputType | null
    _max: ComplianceItemMaxAggregateOutputType | null
  }

  export type ComplianceItemMinAggregateOutputType = {
    id: string | null
    evaluationResultId: string | null
    ruleId: string | null
    compliant: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceItemMaxAggregateOutputType = {
    id: string | null
    evaluationResultId: string | null
    ruleId: string | null
    compliant: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceItemCountAggregateOutputType = {
    id: number
    evaluationResultId: number
    ruleId: number
    compliant: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplianceItemMinAggregateInputType = {
    id?: true
    evaluationResultId?: true
    ruleId?: true
    compliant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceItemMaxAggregateInputType = {
    id?: true
    evaluationResultId?: true
    ruleId?: true
    compliant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceItemCountAggregateInputType = {
    id?: true
    evaluationResultId?: true
    ruleId?: true
    compliant?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplianceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceItem to aggregate.
     */
    where?: ComplianceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceItems to fetch.
     */
    orderBy?: ComplianceItemOrderByWithRelationInput | ComplianceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplianceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplianceItems
    **/
    _count?: true | ComplianceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplianceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplianceItemMaxAggregateInputType
  }

  export type GetComplianceItemAggregateType<T extends ComplianceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateComplianceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplianceItem[P]>
      : GetScalarType<T[P], AggregateComplianceItem[P]>
  }




  export type ComplianceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceItemWhereInput
    orderBy?: ComplianceItemOrderByWithAggregationInput | ComplianceItemOrderByWithAggregationInput[]
    by: ComplianceItemScalarFieldEnum[] | ComplianceItemScalarFieldEnum
    having?: ComplianceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplianceItemCountAggregateInputType | true
    _min?: ComplianceItemMinAggregateInputType
    _max?: ComplianceItemMaxAggregateInputType
  }

  export type ComplianceItemGroupByOutputType = {
    id: string
    evaluationResultId: string
    ruleId: string
    compliant: boolean
    createdAt: Date
    updatedAt: Date
    _count: ComplianceItemCountAggregateOutputType | null
    _min: ComplianceItemMinAggregateOutputType | null
    _max: ComplianceItemMaxAggregateOutputType | null
  }

  type GetComplianceItemGroupByPayload<T extends ComplianceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplianceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplianceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplianceItemGroupByOutputType[P]>
            : GetScalarType<T[P], ComplianceItemGroupByOutputType[P]>
        }
      >
    >


  export type ComplianceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluationResultId?: boolean
    ruleId?: boolean
    compliant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
    rule?: boolean | ComplianceRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceItem"]>

  export type ComplianceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluationResultId?: boolean
    ruleId?: boolean
    compliant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
    rule?: boolean | ComplianceRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceItem"]>

  export type ComplianceItemSelectScalar = {
    id?: boolean
    evaluationResultId?: boolean
    ruleId?: boolean
    compliant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplianceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
    rule?: boolean | ComplianceRuleDefaultArgs<ExtArgs>
  }
  export type ComplianceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
    rule?: boolean | ComplianceRuleDefaultArgs<ExtArgs>
  }

  export type $ComplianceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplianceItem"
    objects: {
      evaluationResult: Prisma.$EvaluationResultPayload<ExtArgs>
      rule: Prisma.$ComplianceRulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      evaluationResultId: string
      ruleId: string
      compliant: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complianceItem"]>
    composites: {}
  }

  type ComplianceItemGetPayload<S extends boolean | null | undefined | ComplianceItemDefaultArgs> = $Result.GetResult<Prisma.$ComplianceItemPayload, S>

  type ComplianceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComplianceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplianceItemCountAggregateInputType | true
    }

  export interface ComplianceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplianceItem'], meta: { name: 'ComplianceItem' } }
    /**
     * Find zero or one ComplianceItem that matches the filter.
     * @param {ComplianceItemFindUniqueArgs} args - Arguments to find a ComplianceItem
     * @example
     * // Get one ComplianceItem
     * const complianceItem = await prisma.complianceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplianceItemFindUniqueArgs>(args: SelectSubset<T, ComplianceItemFindUniqueArgs<ExtArgs>>): Prisma__ComplianceItemClient<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComplianceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComplianceItemFindUniqueOrThrowArgs} args - Arguments to find a ComplianceItem
     * @example
     * // Get one ComplianceItem
     * const complianceItem = await prisma.complianceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplianceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplianceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplianceItemClient<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComplianceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceItemFindFirstArgs} args - Arguments to find a ComplianceItem
     * @example
     * // Get one ComplianceItem
     * const complianceItem = await prisma.complianceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplianceItemFindFirstArgs>(args?: SelectSubset<T, ComplianceItemFindFirstArgs<ExtArgs>>): Prisma__ComplianceItemClient<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComplianceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceItemFindFirstOrThrowArgs} args - Arguments to find a ComplianceItem
     * @example
     * // Get one ComplianceItem
     * const complianceItem = await prisma.complianceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplianceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplianceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplianceItemClient<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComplianceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplianceItems
     * const complianceItems = await prisma.complianceItem.findMany()
     * 
     * // Get first 10 ComplianceItems
     * const complianceItems = await prisma.complianceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complianceItemWithIdOnly = await prisma.complianceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplianceItemFindManyArgs>(args?: SelectSubset<T, ComplianceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComplianceItem.
     * @param {ComplianceItemCreateArgs} args - Arguments to create a ComplianceItem.
     * @example
     * // Create one ComplianceItem
     * const ComplianceItem = await prisma.complianceItem.create({
     *   data: {
     *     // ... data to create a ComplianceItem
     *   }
     * })
     * 
     */
    create<T extends ComplianceItemCreateArgs>(args: SelectSubset<T, ComplianceItemCreateArgs<ExtArgs>>): Prisma__ComplianceItemClient<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComplianceItems.
     * @param {ComplianceItemCreateManyArgs} args - Arguments to create many ComplianceItems.
     * @example
     * // Create many ComplianceItems
     * const complianceItem = await prisma.complianceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplianceItemCreateManyArgs>(args?: SelectSubset<T, ComplianceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplianceItems and returns the data saved in the database.
     * @param {ComplianceItemCreateManyAndReturnArgs} args - Arguments to create many ComplianceItems.
     * @example
     * // Create many ComplianceItems
     * const complianceItem = await prisma.complianceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplianceItems and only return the `id`
     * const complianceItemWithIdOnly = await prisma.complianceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplianceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplianceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComplianceItem.
     * @param {ComplianceItemDeleteArgs} args - Arguments to delete one ComplianceItem.
     * @example
     * // Delete one ComplianceItem
     * const ComplianceItem = await prisma.complianceItem.delete({
     *   where: {
     *     // ... filter to delete one ComplianceItem
     *   }
     * })
     * 
     */
    delete<T extends ComplianceItemDeleteArgs>(args: SelectSubset<T, ComplianceItemDeleteArgs<ExtArgs>>): Prisma__ComplianceItemClient<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComplianceItem.
     * @param {ComplianceItemUpdateArgs} args - Arguments to update one ComplianceItem.
     * @example
     * // Update one ComplianceItem
     * const complianceItem = await prisma.complianceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplianceItemUpdateArgs>(args: SelectSubset<T, ComplianceItemUpdateArgs<ExtArgs>>): Prisma__ComplianceItemClient<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComplianceItems.
     * @param {ComplianceItemDeleteManyArgs} args - Arguments to filter ComplianceItems to delete.
     * @example
     * // Delete a few ComplianceItems
     * const { count } = await prisma.complianceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplianceItemDeleteManyArgs>(args?: SelectSubset<T, ComplianceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplianceItems
     * const complianceItem = await prisma.complianceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplianceItemUpdateManyArgs>(args: SelectSubset<T, ComplianceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplianceItem.
     * @param {ComplianceItemUpsertArgs} args - Arguments to update or create a ComplianceItem.
     * @example
     * // Update or create a ComplianceItem
     * const complianceItem = await prisma.complianceItem.upsert({
     *   create: {
     *     // ... data to create a ComplianceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplianceItem we want to update
     *   }
     * })
     */
    upsert<T extends ComplianceItemUpsertArgs>(args: SelectSubset<T, ComplianceItemUpsertArgs<ExtArgs>>): Prisma__ComplianceItemClient<$Result.GetResult<Prisma.$ComplianceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComplianceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceItemCountArgs} args - Arguments to filter ComplianceItems to count.
     * @example
     * // Count the number of ComplianceItems
     * const count = await prisma.complianceItem.count({
     *   where: {
     *     // ... the filter for the ComplianceItems we want to count
     *   }
     * })
    **/
    count<T extends ComplianceItemCountArgs>(
      args?: Subset<T, ComplianceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplianceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplianceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplianceItemAggregateArgs>(args: Subset<T, ComplianceItemAggregateArgs>): Prisma.PrismaPromise<GetComplianceItemAggregateType<T>>

    /**
     * Group by ComplianceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplianceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplianceItemGroupByArgs['orderBy'] }
        : { orderBy?: ComplianceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplianceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplianceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplianceItem model
   */
  readonly fields: ComplianceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplianceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplianceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluationResult<T extends EvaluationResultDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationResultDefaultArgs<ExtArgs>>): Prisma__EvaluationResultClient<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rule<T extends ComplianceRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComplianceRuleDefaultArgs<ExtArgs>>): Prisma__ComplianceRuleClient<$Result.GetResult<Prisma.$ComplianceRulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplianceItem model
   */ 
  interface ComplianceItemFieldRefs {
    readonly id: FieldRef<"ComplianceItem", 'String'>
    readonly evaluationResultId: FieldRef<"ComplianceItem", 'String'>
    readonly ruleId: FieldRef<"ComplianceItem", 'String'>
    readonly compliant: FieldRef<"ComplianceItem", 'Boolean'>
    readonly createdAt: FieldRef<"ComplianceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ComplianceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplianceItem findUnique
   */
  export type ComplianceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceItem to fetch.
     */
    where: ComplianceItemWhereUniqueInput
  }

  /**
   * ComplianceItem findUniqueOrThrow
   */
  export type ComplianceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceItem to fetch.
     */
    where: ComplianceItemWhereUniqueInput
  }

  /**
   * ComplianceItem findFirst
   */
  export type ComplianceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceItem to fetch.
     */
    where?: ComplianceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceItems to fetch.
     */
    orderBy?: ComplianceItemOrderByWithRelationInput | ComplianceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceItems.
     */
    cursor?: ComplianceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceItems.
     */
    distinct?: ComplianceItemScalarFieldEnum | ComplianceItemScalarFieldEnum[]
  }

  /**
   * ComplianceItem findFirstOrThrow
   */
  export type ComplianceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceItem to fetch.
     */
    where?: ComplianceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceItems to fetch.
     */
    orderBy?: ComplianceItemOrderByWithRelationInput | ComplianceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceItems.
     */
    cursor?: ComplianceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceItems.
     */
    distinct?: ComplianceItemScalarFieldEnum | ComplianceItemScalarFieldEnum[]
  }

  /**
   * ComplianceItem findMany
   */
  export type ComplianceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceItems to fetch.
     */
    where?: ComplianceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceItems to fetch.
     */
    orderBy?: ComplianceItemOrderByWithRelationInput | ComplianceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplianceItems.
     */
    cursor?: ComplianceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceItems.
     */
    skip?: number
    distinct?: ComplianceItemScalarFieldEnum | ComplianceItemScalarFieldEnum[]
  }

  /**
   * ComplianceItem create
   */
  export type ComplianceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplianceItem.
     */
    data: XOR<ComplianceItemCreateInput, ComplianceItemUncheckedCreateInput>
  }

  /**
   * ComplianceItem createMany
   */
  export type ComplianceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplianceItems.
     */
    data: ComplianceItemCreateManyInput | ComplianceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplianceItem createManyAndReturn
   */
  export type ComplianceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComplianceItems.
     */
    data: ComplianceItemCreateManyInput | ComplianceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplianceItem update
   */
  export type ComplianceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplianceItem.
     */
    data: XOR<ComplianceItemUpdateInput, ComplianceItemUncheckedUpdateInput>
    /**
     * Choose, which ComplianceItem to update.
     */
    where: ComplianceItemWhereUniqueInput
  }

  /**
   * ComplianceItem updateMany
   */
  export type ComplianceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplianceItems.
     */
    data: XOR<ComplianceItemUpdateManyMutationInput, ComplianceItemUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceItems to update
     */
    where?: ComplianceItemWhereInput
  }

  /**
   * ComplianceItem upsert
   */
  export type ComplianceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplianceItem to update in case it exists.
     */
    where: ComplianceItemWhereUniqueInput
    /**
     * In case the ComplianceItem found by the `where` argument doesn't exist, create a new ComplianceItem with this data.
     */
    create: XOR<ComplianceItemCreateInput, ComplianceItemUncheckedCreateInput>
    /**
     * In case the ComplianceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplianceItemUpdateInput, ComplianceItemUncheckedUpdateInput>
  }

  /**
   * ComplianceItem delete
   */
  export type ComplianceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
    /**
     * Filter which ComplianceItem to delete.
     */
    where: ComplianceItemWhereUniqueInput
  }

  /**
   * ComplianceItem deleteMany
   */
  export type ComplianceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceItems to delete
     */
    where?: ComplianceItemWhereInput
  }

  /**
   * ComplianceItem without action
   */
  export type ComplianceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceItem
     */
    select?: ComplianceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceItemInclude<ExtArgs> | null
  }


  /**
   * Model EvaluationException
   */

  export type AggregateEvaluationException = {
    _count: EvaluationExceptionCountAggregateOutputType | null
    _min: EvaluationExceptionMinAggregateOutputType | null
    _max: EvaluationExceptionMaxAggregateOutputType | null
  }

  export type EvaluationExceptionMinAggregateOutputType = {
    id: string | null
    evaluationResultId: string | null
    type: string | null
    reason: string | null
    approved: boolean | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationExceptionMaxAggregateOutputType = {
    id: string | null
    evaluationResultId: string | null
    type: string | null
    reason: string | null
    approved: boolean | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationExceptionCountAggregateOutputType = {
    id: number
    evaluationResultId: number
    type: number
    reason: number
    approved: number
    approvedBy: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvaluationExceptionMinAggregateInputType = {
    id?: true
    evaluationResultId?: true
    type?: true
    reason?: true
    approved?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationExceptionMaxAggregateInputType = {
    id?: true
    evaluationResultId?: true
    type?: true
    reason?: true
    approved?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationExceptionCountAggregateInputType = {
    id?: true
    evaluationResultId?: true
    type?: true
    reason?: true
    approved?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvaluationExceptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationException to aggregate.
     */
    where?: EvaluationExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationExceptions to fetch.
     */
    orderBy?: EvaluationExceptionOrderByWithRelationInput | EvaluationExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationExceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluationExceptions
    **/
    _count?: true | EvaluationExceptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationExceptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationExceptionMaxAggregateInputType
  }

  export type GetEvaluationExceptionAggregateType<T extends EvaluationExceptionAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluationException]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluationException[P]>
      : GetScalarType<T[P], AggregateEvaluationException[P]>
  }




  export type EvaluationExceptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationExceptionWhereInput
    orderBy?: EvaluationExceptionOrderByWithAggregationInput | EvaluationExceptionOrderByWithAggregationInput[]
    by: EvaluationExceptionScalarFieldEnum[] | EvaluationExceptionScalarFieldEnum
    having?: EvaluationExceptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationExceptionCountAggregateInputType | true
    _min?: EvaluationExceptionMinAggregateInputType
    _max?: EvaluationExceptionMaxAggregateInputType
  }

  export type EvaluationExceptionGroupByOutputType = {
    id: string
    evaluationResultId: string
    type: string
    reason: string
    approved: boolean | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EvaluationExceptionCountAggregateOutputType | null
    _min: EvaluationExceptionMinAggregateOutputType | null
    _max: EvaluationExceptionMaxAggregateOutputType | null
  }

  type GetEvaluationExceptionGroupByPayload<T extends EvaluationExceptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationExceptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationExceptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationExceptionGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationExceptionGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationExceptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluationResultId?: boolean
    type?: boolean
    reason?: boolean
    approved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationException"]>

  export type EvaluationExceptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluationResultId?: boolean
    type?: boolean
    reason?: boolean
    approved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationException"]>

  export type EvaluationExceptionSelectScalar = {
    id?: boolean
    evaluationResultId?: boolean
    type?: boolean
    reason?: boolean
    approved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EvaluationExceptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
  }
  export type EvaluationExceptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationResult?: boolean | EvaluationResultDefaultArgs<ExtArgs>
  }

  export type $EvaluationExceptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluationException"
    objects: {
      evaluationResult: Prisma.$EvaluationResultPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      evaluationResultId: string
      type: string
      reason: string
      approved: boolean | null
      approvedBy: string | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evaluationException"]>
    composites: {}
  }

  type EvaluationExceptionGetPayload<S extends boolean | null | undefined | EvaluationExceptionDefaultArgs> = $Result.GetResult<Prisma.$EvaluationExceptionPayload, S>

  type EvaluationExceptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationExceptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationExceptionCountAggregateInputType | true
    }

  export interface EvaluationExceptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluationException'], meta: { name: 'EvaluationException' } }
    /**
     * Find zero or one EvaluationException that matches the filter.
     * @param {EvaluationExceptionFindUniqueArgs} args - Arguments to find a EvaluationException
     * @example
     * // Get one EvaluationException
     * const evaluationException = await prisma.evaluationException.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationExceptionFindUniqueArgs>(args: SelectSubset<T, EvaluationExceptionFindUniqueArgs<ExtArgs>>): Prisma__EvaluationExceptionClient<$Result.GetResult<Prisma.$EvaluationExceptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvaluationException that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvaluationExceptionFindUniqueOrThrowArgs} args - Arguments to find a EvaluationException
     * @example
     * // Get one EvaluationException
     * const evaluationException = await prisma.evaluationException.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationExceptionFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationExceptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationExceptionClient<$Result.GetResult<Prisma.$EvaluationExceptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvaluationException that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationExceptionFindFirstArgs} args - Arguments to find a EvaluationException
     * @example
     * // Get one EvaluationException
     * const evaluationException = await prisma.evaluationException.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationExceptionFindFirstArgs>(args?: SelectSubset<T, EvaluationExceptionFindFirstArgs<ExtArgs>>): Prisma__EvaluationExceptionClient<$Result.GetResult<Prisma.$EvaluationExceptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvaluationException that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationExceptionFindFirstOrThrowArgs} args - Arguments to find a EvaluationException
     * @example
     * // Get one EvaluationException
     * const evaluationException = await prisma.evaluationException.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationExceptionFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationExceptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationExceptionClient<$Result.GetResult<Prisma.$EvaluationExceptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvaluationExceptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationExceptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluationExceptions
     * const evaluationExceptions = await prisma.evaluationException.findMany()
     * 
     * // Get first 10 EvaluationExceptions
     * const evaluationExceptions = await prisma.evaluationException.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationExceptionWithIdOnly = await prisma.evaluationException.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationExceptionFindManyArgs>(args?: SelectSubset<T, EvaluationExceptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationExceptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvaluationException.
     * @param {EvaluationExceptionCreateArgs} args - Arguments to create a EvaluationException.
     * @example
     * // Create one EvaluationException
     * const EvaluationException = await prisma.evaluationException.create({
     *   data: {
     *     // ... data to create a EvaluationException
     *   }
     * })
     * 
     */
    create<T extends EvaluationExceptionCreateArgs>(args: SelectSubset<T, EvaluationExceptionCreateArgs<ExtArgs>>): Prisma__EvaluationExceptionClient<$Result.GetResult<Prisma.$EvaluationExceptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvaluationExceptions.
     * @param {EvaluationExceptionCreateManyArgs} args - Arguments to create many EvaluationExceptions.
     * @example
     * // Create many EvaluationExceptions
     * const evaluationException = await prisma.evaluationException.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationExceptionCreateManyArgs>(args?: SelectSubset<T, EvaluationExceptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvaluationExceptions and returns the data saved in the database.
     * @param {EvaluationExceptionCreateManyAndReturnArgs} args - Arguments to create many EvaluationExceptions.
     * @example
     * // Create many EvaluationExceptions
     * const evaluationException = await prisma.evaluationException.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvaluationExceptions and only return the `id`
     * const evaluationExceptionWithIdOnly = await prisma.evaluationException.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationExceptionCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationExceptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationExceptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvaluationException.
     * @param {EvaluationExceptionDeleteArgs} args - Arguments to delete one EvaluationException.
     * @example
     * // Delete one EvaluationException
     * const EvaluationException = await prisma.evaluationException.delete({
     *   where: {
     *     // ... filter to delete one EvaluationException
     *   }
     * })
     * 
     */
    delete<T extends EvaluationExceptionDeleteArgs>(args: SelectSubset<T, EvaluationExceptionDeleteArgs<ExtArgs>>): Prisma__EvaluationExceptionClient<$Result.GetResult<Prisma.$EvaluationExceptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvaluationException.
     * @param {EvaluationExceptionUpdateArgs} args - Arguments to update one EvaluationException.
     * @example
     * // Update one EvaluationException
     * const evaluationException = await prisma.evaluationException.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationExceptionUpdateArgs>(args: SelectSubset<T, EvaluationExceptionUpdateArgs<ExtArgs>>): Prisma__EvaluationExceptionClient<$Result.GetResult<Prisma.$EvaluationExceptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvaluationExceptions.
     * @param {EvaluationExceptionDeleteManyArgs} args - Arguments to filter EvaluationExceptions to delete.
     * @example
     * // Delete a few EvaluationExceptions
     * const { count } = await prisma.evaluationException.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationExceptionDeleteManyArgs>(args?: SelectSubset<T, EvaluationExceptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationExceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationExceptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluationExceptions
     * const evaluationException = await prisma.evaluationException.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationExceptionUpdateManyArgs>(args: SelectSubset<T, EvaluationExceptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvaluationException.
     * @param {EvaluationExceptionUpsertArgs} args - Arguments to update or create a EvaluationException.
     * @example
     * // Update or create a EvaluationException
     * const evaluationException = await prisma.evaluationException.upsert({
     *   create: {
     *     // ... data to create a EvaluationException
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluationException we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationExceptionUpsertArgs>(args: SelectSubset<T, EvaluationExceptionUpsertArgs<ExtArgs>>): Prisma__EvaluationExceptionClient<$Result.GetResult<Prisma.$EvaluationExceptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvaluationExceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationExceptionCountArgs} args - Arguments to filter EvaluationExceptions to count.
     * @example
     * // Count the number of EvaluationExceptions
     * const count = await prisma.evaluationException.count({
     *   where: {
     *     // ... the filter for the EvaluationExceptions we want to count
     *   }
     * })
    **/
    count<T extends EvaluationExceptionCountArgs>(
      args?: Subset<T, EvaluationExceptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationExceptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluationException.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationExceptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationExceptionAggregateArgs>(args: Subset<T, EvaluationExceptionAggregateArgs>): Prisma.PrismaPromise<GetEvaluationExceptionAggregateType<T>>

    /**
     * Group by EvaluationException.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationExceptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationExceptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationExceptionGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationExceptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationExceptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationExceptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluationException model
   */
  readonly fields: EvaluationExceptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluationException.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationExceptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluationResult<T extends EvaluationResultDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationResultDefaultArgs<ExtArgs>>): Prisma__EvaluationResultClient<$Result.GetResult<Prisma.$EvaluationResultPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaluationException model
   */ 
  interface EvaluationExceptionFieldRefs {
    readonly id: FieldRef<"EvaluationException", 'String'>
    readonly evaluationResultId: FieldRef<"EvaluationException", 'String'>
    readonly type: FieldRef<"EvaluationException", 'String'>
    readonly reason: FieldRef<"EvaluationException", 'String'>
    readonly approved: FieldRef<"EvaluationException", 'Boolean'>
    readonly approvedBy: FieldRef<"EvaluationException", 'String'>
    readonly approvedAt: FieldRef<"EvaluationException", 'DateTime'>
    readonly createdAt: FieldRef<"EvaluationException", 'DateTime'>
    readonly updatedAt: FieldRef<"EvaluationException", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvaluationException findUnique
   */
  export type EvaluationExceptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationException to fetch.
     */
    where: EvaluationExceptionWhereUniqueInput
  }

  /**
   * EvaluationException findUniqueOrThrow
   */
  export type EvaluationExceptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationException to fetch.
     */
    where: EvaluationExceptionWhereUniqueInput
  }

  /**
   * EvaluationException findFirst
   */
  export type EvaluationExceptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationException to fetch.
     */
    where?: EvaluationExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationExceptions to fetch.
     */
    orderBy?: EvaluationExceptionOrderByWithRelationInput | EvaluationExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationExceptions.
     */
    cursor?: EvaluationExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationExceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationExceptions.
     */
    distinct?: EvaluationExceptionScalarFieldEnum | EvaluationExceptionScalarFieldEnum[]
  }

  /**
   * EvaluationException findFirstOrThrow
   */
  export type EvaluationExceptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationException to fetch.
     */
    where?: EvaluationExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationExceptions to fetch.
     */
    orderBy?: EvaluationExceptionOrderByWithRelationInput | EvaluationExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationExceptions.
     */
    cursor?: EvaluationExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationExceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationExceptions.
     */
    distinct?: EvaluationExceptionScalarFieldEnum | EvaluationExceptionScalarFieldEnum[]
  }

  /**
   * EvaluationException findMany
   */
  export type EvaluationExceptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationExceptions to fetch.
     */
    where?: EvaluationExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationExceptions to fetch.
     */
    orderBy?: EvaluationExceptionOrderByWithRelationInput | EvaluationExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluationExceptions.
     */
    cursor?: EvaluationExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationExceptions.
     */
    skip?: number
    distinct?: EvaluationExceptionScalarFieldEnum | EvaluationExceptionScalarFieldEnum[]
  }

  /**
   * EvaluationException create
   */
  export type EvaluationExceptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaluationException.
     */
    data: XOR<EvaluationExceptionCreateInput, EvaluationExceptionUncheckedCreateInput>
  }

  /**
   * EvaluationException createMany
   */
  export type EvaluationExceptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluationExceptions.
     */
    data: EvaluationExceptionCreateManyInput | EvaluationExceptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvaluationException createManyAndReturn
   */
  export type EvaluationExceptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvaluationExceptions.
     */
    data: EvaluationExceptionCreateManyInput | EvaluationExceptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvaluationException update
   */
  export type EvaluationExceptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaluationException.
     */
    data: XOR<EvaluationExceptionUpdateInput, EvaluationExceptionUncheckedUpdateInput>
    /**
     * Choose, which EvaluationException to update.
     */
    where: EvaluationExceptionWhereUniqueInput
  }

  /**
   * EvaluationException updateMany
   */
  export type EvaluationExceptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluationExceptions.
     */
    data: XOR<EvaluationExceptionUpdateManyMutationInput, EvaluationExceptionUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationExceptions to update
     */
    where?: EvaluationExceptionWhereInput
  }

  /**
   * EvaluationException upsert
   */
  export type EvaluationExceptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaluationException to update in case it exists.
     */
    where: EvaluationExceptionWhereUniqueInput
    /**
     * In case the EvaluationException found by the `where` argument doesn't exist, create a new EvaluationException with this data.
     */
    create: XOR<EvaluationExceptionCreateInput, EvaluationExceptionUncheckedCreateInput>
    /**
     * In case the EvaluationException was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationExceptionUpdateInput, EvaluationExceptionUncheckedUpdateInput>
  }

  /**
   * EvaluationException delete
   */
  export type EvaluationExceptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionInclude<ExtArgs> | null
    /**
     * Filter which EvaluationException to delete.
     */
    where: EvaluationExceptionWhereUniqueInput
  }

  /**
   * EvaluationException deleteMany
   */
  export type EvaluationExceptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationExceptions to delete
     */
    where?: EvaluationExceptionWhereInput
  }

  /**
   * EvaluationException without action
   */
  export type EvaluationExceptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationException
     */
    select?: EvaluationExceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationExceptionInclude<ExtArgs> | null
  }


  /**
   * Model EvaluationSignature
   */

  export type AggregateEvaluationSignature = {
    _count: EvaluationSignatureCountAggregateOutputType | null
    _min: EvaluationSignatureMinAggregateOutputType | null
    _max: EvaluationSignatureMaxAggregateOutputType | null
  }

  export type EvaluationSignatureMinAggregateOutputType = {
    id: string | null
    tenderId: string | null
    role: string | null
    name: string | null
    signature: string | null
    comment: string | null
    signedAt: Date | null
  }

  export type EvaluationSignatureMaxAggregateOutputType = {
    id: string | null
    tenderId: string | null
    role: string | null
    name: string | null
    signature: string | null
    comment: string | null
    signedAt: Date | null
  }

  export type EvaluationSignatureCountAggregateOutputType = {
    id: number
    tenderId: number
    role: number
    name: number
    signature: number
    comment: number
    signedAt: number
    _all: number
  }


  export type EvaluationSignatureMinAggregateInputType = {
    id?: true
    tenderId?: true
    role?: true
    name?: true
    signature?: true
    comment?: true
    signedAt?: true
  }

  export type EvaluationSignatureMaxAggregateInputType = {
    id?: true
    tenderId?: true
    role?: true
    name?: true
    signature?: true
    comment?: true
    signedAt?: true
  }

  export type EvaluationSignatureCountAggregateInputType = {
    id?: true
    tenderId?: true
    role?: true
    name?: true
    signature?: true
    comment?: true
    signedAt?: true
    _all?: true
  }

  export type EvaluationSignatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationSignature to aggregate.
     */
    where?: EvaluationSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationSignatures to fetch.
     */
    orderBy?: EvaluationSignatureOrderByWithRelationInput | EvaluationSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluationSignatures
    **/
    _count?: true | EvaluationSignatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationSignatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationSignatureMaxAggregateInputType
  }

  export type GetEvaluationSignatureAggregateType<T extends EvaluationSignatureAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluationSignature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluationSignature[P]>
      : GetScalarType<T[P], AggregateEvaluationSignature[P]>
  }




  export type EvaluationSignatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationSignatureWhereInput
    orderBy?: EvaluationSignatureOrderByWithAggregationInput | EvaluationSignatureOrderByWithAggregationInput[]
    by: EvaluationSignatureScalarFieldEnum[] | EvaluationSignatureScalarFieldEnum
    having?: EvaluationSignatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationSignatureCountAggregateInputType | true
    _min?: EvaluationSignatureMinAggregateInputType
    _max?: EvaluationSignatureMaxAggregateInputType
  }

  export type EvaluationSignatureGroupByOutputType = {
    id: string
    tenderId: string
    role: string
    name: string
    signature: string | null
    comment: string | null
    signedAt: Date
    _count: EvaluationSignatureCountAggregateOutputType | null
    _min: EvaluationSignatureMinAggregateOutputType | null
    _max: EvaluationSignatureMaxAggregateOutputType | null
  }

  type GetEvaluationSignatureGroupByPayload<T extends EvaluationSignatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationSignatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationSignatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationSignatureGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationSignatureGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationSignatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    role?: boolean
    name?: boolean
    signature?: boolean
    comment?: boolean
    signedAt?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationSignature"]>

  export type EvaluationSignatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    role?: boolean
    name?: boolean
    signature?: boolean
    comment?: boolean
    signedAt?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationSignature"]>

  export type EvaluationSignatureSelectScalar = {
    id?: boolean
    tenderId?: boolean
    role?: boolean
    name?: boolean
    signature?: boolean
    comment?: boolean
    signedAt?: boolean
  }

  export type EvaluationSignatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }
  export type EvaluationSignatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }

  export type $EvaluationSignaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluationSignature"
    objects: {
      tender: Prisma.$TenderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenderId: string
      role: string
      name: string
      signature: string | null
      comment: string | null
      signedAt: Date
    }, ExtArgs["result"]["evaluationSignature"]>
    composites: {}
  }

  type EvaluationSignatureGetPayload<S extends boolean | null | undefined | EvaluationSignatureDefaultArgs> = $Result.GetResult<Prisma.$EvaluationSignaturePayload, S>

  type EvaluationSignatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationSignatureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationSignatureCountAggregateInputType | true
    }

  export interface EvaluationSignatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluationSignature'], meta: { name: 'EvaluationSignature' } }
    /**
     * Find zero or one EvaluationSignature that matches the filter.
     * @param {EvaluationSignatureFindUniqueArgs} args - Arguments to find a EvaluationSignature
     * @example
     * // Get one EvaluationSignature
     * const evaluationSignature = await prisma.evaluationSignature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationSignatureFindUniqueArgs>(args: SelectSubset<T, EvaluationSignatureFindUniqueArgs<ExtArgs>>): Prisma__EvaluationSignatureClient<$Result.GetResult<Prisma.$EvaluationSignaturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvaluationSignature that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvaluationSignatureFindUniqueOrThrowArgs} args - Arguments to find a EvaluationSignature
     * @example
     * // Get one EvaluationSignature
     * const evaluationSignature = await prisma.evaluationSignature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationSignatureFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationSignatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationSignatureClient<$Result.GetResult<Prisma.$EvaluationSignaturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvaluationSignature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationSignatureFindFirstArgs} args - Arguments to find a EvaluationSignature
     * @example
     * // Get one EvaluationSignature
     * const evaluationSignature = await prisma.evaluationSignature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationSignatureFindFirstArgs>(args?: SelectSubset<T, EvaluationSignatureFindFirstArgs<ExtArgs>>): Prisma__EvaluationSignatureClient<$Result.GetResult<Prisma.$EvaluationSignaturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvaluationSignature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationSignatureFindFirstOrThrowArgs} args - Arguments to find a EvaluationSignature
     * @example
     * // Get one EvaluationSignature
     * const evaluationSignature = await prisma.evaluationSignature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationSignatureFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationSignatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationSignatureClient<$Result.GetResult<Prisma.$EvaluationSignaturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvaluationSignatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationSignatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluationSignatures
     * const evaluationSignatures = await prisma.evaluationSignature.findMany()
     * 
     * // Get first 10 EvaluationSignatures
     * const evaluationSignatures = await prisma.evaluationSignature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationSignatureWithIdOnly = await prisma.evaluationSignature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationSignatureFindManyArgs>(args?: SelectSubset<T, EvaluationSignatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationSignaturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvaluationSignature.
     * @param {EvaluationSignatureCreateArgs} args - Arguments to create a EvaluationSignature.
     * @example
     * // Create one EvaluationSignature
     * const EvaluationSignature = await prisma.evaluationSignature.create({
     *   data: {
     *     // ... data to create a EvaluationSignature
     *   }
     * })
     * 
     */
    create<T extends EvaluationSignatureCreateArgs>(args: SelectSubset<T, EvaluationSignatureCreateArgs<ExtArgs>>): Prisma__EvaluationSignatureClient<$Result.GetResult<Prisma.$EvaluationSignaturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvaluationSignatures.
     * @param {EvaluationSignatureCreateManyArgs} args - Arguments to create many EvaluationSignatures.
     * @example
     * // Create many EvaluationSignatures
     * const evaluationSignature = await prisma.evaluationSignature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationSignatureCreateManyArgs>(args?: SelectSubset<T, EvaluationSignatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvaluationSignatures and returns the data saved in the database.
     * @param {EvaluationSignatureCreateManyAndReturnArgs} args - Arguments to create many EvaluationSignatures.
     * @example
     * // Create many EvaluationSignatures
     * const evaluationSignature = await prisma.evaluationSignature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvaluationSignatures and only return the `id`
     * const evaluationSignatureWithIdOnly = await prisma.evaluationSignature.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationSignatureCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationSignatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationSignaturePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvaluationSignature.
     * @param {EvaluationSignatureDeleteArgs} args - Arguments to delete one EvaluationSignature.
     * @example
     * // Delete one EvaluationSignature
     * const EvaluationSignature = await prisma.evaluationSignature.delete({
     *   where: {
     *     // ... filter to delete one EvaluationSignature
     *   }
     * })
     * 
     */
    delete<T extends EvaluationSignatureDeleteArgs>(args: SelectSubset<T, EvaluationSignatureDeleteArgs<ExtArgs>>): Prisma__EvaluationSignatureClient<$Result.GetResult<Prisma.$EvaluationSignaturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvaluationSignature.
     * @param {EvaluationSignatureUpdateArgs} args - Arguments to update one EvaluationSignature.
     * @example
     * // Update one EvaluationSignature
     * const evaluationSignature = await prisma.evaluationSignature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationSignatureUpdateArgs>(args: SelectSubset<T, EvaluationSignatureUpdateArgs<ExtArgs>>): Prisma__EvaluationSignatureClient<$Result.GetResult<Prisma.$EvaluationSignaturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvaluationSignatures.
     * @param {EvaluationSignatureDeleteManyArgs} args - Arguments to filter EvaluationSignatures to delete.
     * @example
     * // Delete a few EvaluationSignatures
     * const { count } = await prisma.evaluationSignature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationSignatureDeleteManyArgs>(args?: SelectSubset<T, EvaluationSignatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationSignatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationSignatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluationSignatures
     * const evaluationSignature = await prisma.evaluationSignature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationSignatureUpdateManyArgs>(args: SelectSubset<T, EvaluationSignatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvaluationSignature.
     * @param {EvaluationSignatureUpsertArgs} args - Arguments to update or create a EvaluationSignature.
     * @example
     * // Update or create a EvaluationSignature
     * const evaluationSignature = await prisma.evaluationSignature.upsert({
     *   create: {
     *     // ... data to create a EvaluationSignature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluationSignature we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationSignatureUpsertArgs>(args: SelectSubset<T, EvaluationSignatureUpsertArgs<ExtArgs>>): Prisma__EvaluationSignatureClient<$Result.GetResult<Prisma.$EvaluationSignaturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvaluationSignatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationSignatureCountArgs} args - Arguments to filter EvaluationSignatures to count.
     * @example
     * // Count the number of EvaluationSignatures
     * const count = await prisma.evaluationSignature.count({
     *   where: {
     *     // ... the filter for the EvaluationSignatures we want to count
     *   }
     * })
    **/
    count<T extends EvaluationSignatureCountArgs>(
      args?: Subset<T, EvaluationSignatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationSignatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluationSignature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationSignatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationSignatureAggregateArgs>(args: Subset<T, EvaluationSignatureAggregateArgs>): Prisma.PrismaPromise<GetEvaluationSignatureAggregateType<T>>

    /**
     * Group by EvaluationSignature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationSignatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationSignatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationSignatureGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationSignatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationSignatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationSignatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluationSignature model
   */
  readonly fields: EvaluationSignatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluationSignature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationSignatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tender<T extends TenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenderDefaultArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaluationSignature model
   */ 
  interface EvaluationSignatureFieldRefs {
    readonly id: FieldRef<"EvaluationSignature", 'String'>
    readonly tenderId: FieldRef<"EvaluationSignature", 'String'>
    readonly role: FieldRef<"EvaluationSignature", 'String'>
    readonly name: FieldRef<"EvaluationSignature", 'String'>
    readonly signature: FieldRef<"EvaluationSignature", 'String'>
    readonly comment: FieldRef<"EvaluationSignature", 'String'>
    readonly signedAt: FieldRef<"EvaluationSignature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvaluationSignature findUnique
   */
  export type EvaluationSignatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationSignature to fetch.
     */
    where: EvaluationSignatureWhereUniqueInput
  }

  /**
   * EvaluationSignature findUniqueOrThrow
   */
  export type EvaluationSignatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationSignature to fetch.
     */
    where: EvaluationSignatureWhereUniqueInput
  }

  /**
   * EvaluationSignature findFirst
   */
  export type EvaluationSignatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationSignature to fetch.
     */
    where?: EvaluationSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationSignatures to fetch.
     */
    orderBy?: EvaluationSignatureOrderByWithRelationInput | EvaluationSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationSignatures.
     */
    cursor?: EvaluationSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationSignatures.
     */
    distinct?: EvaluationSignatureScalarFieldEnum | EvaluationSignatureScalarFieldEnum[]
  }

  /**
   * EvaluationSignature findFirstOrThrow
   */
  export type EvaluationSignatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationSignature to fetch.
     */
    where?: EvaluationSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationSignatures to fetch.
     */
    orderBy?: EvaluationSignatureOrderByWithRelationInput | EvaluationSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationSignatures.
     */
    cursor?: EvaluationSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationSignatures.
     */
    distinct?: EvaluationSignatureScalarFieldEnum | EvaluationSignatureScalarFieldEnum[]
  }

  /**
   * EvaluationSignature findMany
   */
  export type EvaluationSignatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationSignatures to fetch.
     */
    where?: EvaluationSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationSignatures to fetch.
     */
    orderBy?: EvaluationSignatureOrderByWithRelationInput | EvaluationSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluationSignatures.
     */
    cursor?: EvaluationSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationSignatures.
     */
    skip?: number
    distinct?: EvaluationSignatureScalarFieldEnum | EvaluationSignatureScalarFieldEnum[]
  }

  /**
   * EvaluationSignature create
   */
  export type EvaluationSignatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaluationSignature.
     */
    data: XOR<EvaluationSignatureCreateInput, EvaluationSignatureUncheckedCreateInput>
  }

  /**
   * EvaluationSignature createMany
   */
  export type EvaluationSignatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluationSignatures.
     */
    data: EvaluationSignatureCreateManyInput | EvaluationSignatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvaluationSignature createManyAndReturn
   */
  export type EvaluationSignatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvaluationSignatures.
     */
    data: EvaluationSignatureCreateManyInput | EvaluationSignatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvaluationSignature update
   */
  export type EvaluationSignatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaluationSignature.
     */
    data: XOR<EvaluationSignatureUpdateInput, EvaluationSignatureUncheckedUpdateInput>
    /**
     * Choose, which EvaluationSignature to update.
     */
    where: EvaluationSignatureWhereUniqueInput
  }

  /**
   * EvaluationSignature updateMany
   */
  export type EvaluationSignatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluationSignatures.
     */
    data: XOR<EvaluationSignatureUpdateManyMutationInput, EvaluationSignatureUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationSignatures to update
     */
    where?: EvaluationSignatureWhereInput
  }

  /**
   * EvaluationSignature upsert
   */
  export type EvaluationSignatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaluationSignature to update in case it exists.
     */
    where: EvaluationSignatureWhereUniqueInput
    /**
     * In case the EvaluationSignature found by the `where` argument doesn't exist, create a new EvaluationSignature with this data.
     */
    create: XOR<EvaluationSignatureCreateInput, EvaluationSignatureUncheckedCreateInput>
    /**
     * In case the EvaluationSignature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationSignatureUpdateInput, EvaluationSignatureUncheckedUpdateInput>
  }

  /**
   * EvaluationSignature delete
   */
  export type EvaluationSignatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureInclude<ExtArgs> | null
    /**
     * Filter which EvaluationSignature to delete.
     */
    where: EvaluationSignatureWhereUniqueInput
  }

  /**
   * EvaluationSignature deleteMany
   */
  export type EvaluationSignatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationSignatures to delete
     */
    where?: EvaluationSignatureWhereInput
  }

  /**
   * EvaluationSignature without action
   */
  export type EvaluationSignatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationSignature
     */
    select?: EvaluationSignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationSignatureInclude<ExtArgs> | null
  }


  /**
   * Model EvaluationDocument
   */

  export type AggregateEvaluationDocument = {
    _count: EvaluationDocumentCountAggregateOutputType | null
    _avg: EvaluationDocumentAvgAggregateOutputType | null
    _sum: EvaluationDocumentSumAggregateOutputType | null
    _min: EvaluationDocumentMinAggregateOutputType | null
    _max: EvaluationDocumentMaxAggregateOutputType | null
  }

  export type EvaluationDocumentAvgAggregateOutputType = {
    runNumber: number | null
  }

  export type EvaluationDocumentSumAggregateOutputType = {
    runNumber: number | null
  }

  export type EvaluationDocumentMinAggregateOutputType = {
    id: string | null
    tenderId: string | null
    runNumber: number | null
    fileUrl: string | null
    hash: string | null
    createdAt: Date | null
  }

  export type EvaluationDocumentMaxAggregateOutputType = {
    id: string | null
    tenderId: string | null
    runNumber: number | null
    fileUrl: string | null
    hash: string | null
    createdAt: Date | null
  }

  export type EvaluationDocumentCountAggregateOutputType = {
    id: number
    tenderId: number
    runNumber: number
    fileUrl: number
    hash: number
    createdAt: number
    _all: number
  }


  export type EvaluationDocumentAvgAggregateInputType = {
    runNumber?: true
  }

  export type EvaluationDocumentSumAggregateInputType = {
    runNumber?: true
  }

  export type EvaluationDocumentMinAggregateInputType = {
    id?: true
    tenderId?: true
    runNumber?: true
    fileUrl?: true
    hash?: true
    createdAt?: true
  }

  export type EvaluationDocumentMaxAggregateInputType = {
    id?: true
    tenderId?: true
    runNumber?: true
    fileUrl?: true
    hash?: true
    createdAt?: true
  }

  export type EvaluationDocumentCountAggregateInputType = {
    id?: true
    tenderId?: true
    runNumber?: true
    fileUrl?: true
    hash?: true
    createdAt?: true
    _all?: true
  }

  export type EvaluationDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationDocument to aggregate.
     */
    where?: EvaluationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationDocuments to fetch.
     */
    orderBy?: EvaluationDocumentOrderByWithRelationInput | EvaluationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluationDocuments
    **/
    _count?: true | EvaluationDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationDocumentMaxAggregateInputType
  }

  export type GetEvaluationDocumentAggregateType<T extends EvaluationDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluationDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluationDocument[P]>
      : GetScalarType<T[P], AggregateEvaluationDocument[P]>
  }




  export type EvaluationDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationDocumentWhereInput
    orderBy?: EvaluationDocumentOrderByWithAggregationInput | EvaluationDocumentOrderByWithAggregationInput[]
    by: EvaluationDocumentScalarFieldEnum[] | EvaluationDocumentScalarFieldEnum
    having?: EvaluationDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationDocumentCountAggregateInputType | true
    _avg?: EvaluationDocumentAvgAggregateInputType
    _sum?: EvaluationDocumentSumAggregateInputType
    _min?: EvaluationDocumentMinAggregateInputType
    _max?: EvaluationDocumentMaxAggregateInputType
  }

  export type EvaluationDocumentGroupByOutputType = {
    id: string
    tenderId: string
    runNumber: number
    fileUrl: string
    hash: string
    createdAt: Date
    _count: EvaluationDocumentCountAggregateOutputType | null
    _avg: EvaluationDocumentAvgAggregateOutputType | null
    _sum: EvaluationDocumentSumAggregateOutputType | null
    _min: EvaluationDocumentMinAggregateOutputType | null
    _max: EvaluationDocumentMaxAggregateOutputType | null
  }

  type GetEvaluationDocumentGroupByPayload<T extends EvaluationDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationDocumentGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    runNumber?: boolean
    fileUrl?: boolean
    hash?: boolean
    createdAt?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationDocument"]>

  export type EvaluationDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    runNumber?: boolean
    fileUrl?: boolean
    hash?: boolean
    createdAt?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationDocument"]>

  export type EvaluationDocumentSelectScalar = {
    id?: boolean
    tenderId?: boolean
    runNumber?: boolean
    fileUrl?: boolean
    hash?: boolean
    createdAt?: boolean
  }

  export type EvaluationDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }
  export type EvaluationDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }

  export type $EvaluationDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluationDocument"
    objects: {
      tender: Prisma.$TenderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenderId: string
      runNumber: number
      fileUrl: string
      hash: string
      createdAt: Date
    }, ExtArgs["result"]["evaluationDocument"]>
    composites: {}
  }

  type EvaluationDocumentGetPayload<S extends boolean | null | undefined | EvaluationDocumentDefaultArgs> = $Result.GetResult<Prisma.$EvaluationDocumentPayload, S>

  type EvaluationDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationDocumentCountAggregateInputType | true
    }

  export interface EvaluationDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluationDocument'], meta: { name: 'EvaluationDocument' } }
    /**
     * Find zero or one EvaluationDocument that matches the filter.
     * @param {EvaluationDocumentFindUniqueArgs} args - Arguments to find a EvaluationDocument
     * @example
     * // Get one EvaluationDocument
     * const evaluationDocument = await prisma.evaluationDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationDocumentFindUniqueArgs>(args: SelectSubset<T, EvaluationDocumentFindUniqueArgs<ExtArgs>>): Prisma__EvaluationDocumentClient<$Result.GetResult<Prisma.$EvaluationDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvaluationDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvaluationDocumentFindUniqueOrThrowArgs} args - Arguments to find a EvaluationDocument
     * @example
     * // Get one EvaluationDocument
     * const evaluationDocument = await prisma.evaluationDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationDocumentClient<$Result.GetResult<Prisma.$EvaluationDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvaluationDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationDocumentFindFirstArgs} args - Arguments to find a EvaluationDocument
     * @example
     * // Get one EvaluationDocument
     * const evaluationDocument = await prisma.evaluationDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationDocumentFindFirstArgs>(args?: SelectSubset<T, EvaluationDocumentFindFirstArgs<ExtArgs>>): Prisma__EvaluationDocumentClient<$Result.GetResult<Prisma.$EvaluationDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvaluationDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationDocumentFindFirstOrThrowArgs} args - Arguments to find a EvaluationDocument
     * @example
     * // Get one EvaluationDocument
     * const evaluationDocument = await prisma.evaluationDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationDocumentClient<$Result.GetResult<Prisma.$EvaluationDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvaluationDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluationDocuments
     * const evaluationDocuments = await prisma.evaluationDocument.findMany()
     * 
     * // Get first 10 EvaluationDocuments
     * const evaluationDocuments = await prisma.evaluationDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationDocumentWithIdOnly = await prisma.evaluationDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationDocumentFindManyArgs>(args?: SelectSubset<T, EvaluationDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvaluationDocument.
     * @param {EvaluationDocumentCreateArgs} args - Arguments to create a EvaluationDocument.
     * @example
     * // Create one EvaluationDocument
     * const EvaluationDocument = await prisma.evaluationDocument.create({
     *   data: {
     *     // ... data to create a EvaluationDocument
     *   }
     * })
     * 
     */
    create<T extends EvaluationDocumentCreateArgs>(args: SelectSubset<T, EvaluationDocumentCreateArgs<ExtArgs>>): Prisma__EvaluationDocumentClient<$Result.GetResult<Prisma.$EvaluationDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvaluationDocuments.
     * @param {EvaluationDocumentCreateManyArgs} args - Arguments to create many EvaluationDocuments.
     * @example
     * // Create many EvaluationDocuments
     * const evaluationDocument = await prisma.evaluationDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationDocumentCreateManyArgs>(args?: SelectSubset<T, EvaluationDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvaluationDocuments and returns the data saved in the database.
     * @param {EvaluationDocumentCreateManyAndReturnArgs} args - Arguments to create many EvaluationDocuments.
     * @example
     * // Create many EvaluationDocuments
     * const evaluationDocument = await prisma.evaluationDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvaluationDocuments and only return the `id`
     * const evaluationDocumentWithIdOnly = await prisma.evaluationDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvaluationDocument.
     * @param {EvaluationDocumentDeleteArgs} args - Arguments to delete one EvaluationDocument.
     * @example
     * // Delete one EvaluationDocument
     * const EvaluationDocument = await prisma.evaluationDocument.delete({
     *   where: {
     *     // ... filter to delete one EvaluationDocument
     *   }
     * })
     * 
     */
    delete<T extends EvaluationDocumentDeleteArgs>(args: SelectSubset<T, EvaluationDocumentDeleteArgs<ExtArgs>>): Prisma__EvaluationDocumentClient<$Result.GetResult<Prisma.$EvaluationDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvaluationDocument.
     * @param {EvaluationDocumentUpdateArgs} args - Arguments to update one EvaluationDocument.
     * @example
     * // Update one EvaluationDocument
     * const evaluationDocument = await prisma.evaluationDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationDocumentUpdateArgs>(args: SelectSubset<T, EvaluationDocumentUpdateArgs<ExtArgs>>): Prisma__EvaluationDocumentClient<$Result.GetResult<Prisma.$EvaluationDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvaluationDocuments.
     * @param {EvaluationDocumentDeleteManyArgs} args - Arguments to filter EvaluationDocuments to delete.
     * @example
     * // Delete a few EvaluationDocuments
     * const { count } = await prisma.evaluationDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationDocumentDeleteManyArgs>(args?: SelectSubset<T, EvaluationDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluationDocuments
     * const evaluationDocument = await prisma.evaluationDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationDocumentUpdateManyArgs>(args: SelectSubset<T, EvaluationDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvaluationDocument.
     * @param {EvaluationDocumentUpsertArgs} args - Arguments to update or create a EvaluationDocument.
     * @example
     * // Update or create a EvaluationDocument
     * const evaluationDocument = await prisma.evaluationDocument.upsert({
     *   create: {
     *     // ... data to create a EvaluationDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluationDocument we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationDocumentUpsertArgs>(args: SelectSubset<T, EvaluationDocumentUpsertArgs<ExtArgs>>): Prisma__EvaluationDocumentClient<$Result.GetResult<Prisma.$EvaluationDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvaluationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationDocumentCountArgs} args - Arguments to filter EvaluationDocuments to count.
     * @example
     * // Count the number of EvaluationDocuments
     * const count = await prisma.evaluationDocument.count({
     *   where: {
     *     // ... the filter for the EvaluationDocuments we want to count
     *   }
     * })
    **/
    count<T extends EvaluationDocumentCountArgs>(
      args?: Subset<T, EvaluationDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationDocumentAggregateArgs>(args: Subset<T, EvaluationDocumentAggregateArgs>): Prisma.PrismaPromise<GetEvaluationDocumentAggregateType<T>>

    /**
     * Group by EvaluationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationDocumentGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluationDocument model
   */
  readonly fields: EvaluationDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluationDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tender<T extends TenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenderDefaultArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaluationDocument model
   */ 
  interface EvaluationDocumentFieldRefs {
    readonly id: FieldRef<"EvaluationDocument", 'String'>
    readonly tenderId: FieldRef<"EvaluationDocument", 'String'>
    readonly runNumber: FieldRef<"EvaluationDocument", 'Int'>
    readonly fileUrl: FieldRef<"EvaluationDocument", 'String'>
    readonly hash: FieldRef<"EvaluationDocument", 'String'>
    readonly createdAt: FieldRef<"EvaluationDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvaluationDocument findUnique
   */
  export type EvaluationDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationDocument to fetch.
     */
    where: EvaluationDocumentWhereUniqueInput
  }

  /**
   * EvaluationDocument findUniqueOrThrow
   */
  export type EvaluationDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationDocument to fetch.
     */
    where: EvaluationDocumentWhereUniqueInput
  }

  /**
   * EvaluationDocument findFirst
   */
  export type EvaluationDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationDocument to fetch.
     */
    where?: EvaluationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationDocuments to fetch.
     */
    orderBy?: EvaluationDocumentOrderByWithRelationInput | EvaluationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationDocuments.
     */
    cursor?: EvaluationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationDocuments.
     */
    distinct?: EvaluationDocumentScalarFieldEnum | EvaluationDocumentScalarFieldEnum[]
  }

  /**
   * EvaluationDocument findFirstOrThrow
   */
  export type EvaluationDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationDocument to fetch.
     */
    where?: EvaluationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationDocuments to fetch.
     */
    orderBy?: EvaluationDocumentOrderByWithRelationInput | EvaluationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationDocuments.
     */
    cursor?: EvaluationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationDocuments.
     */
    distinct?: EvaluationDocumentScalarFieldEnum | EvaluationDocumentScalarFieldEnum[]
  }

  /**
   * EvaluationDocument findMany
   */
  export type EvaluationDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationDocuments to fetch.
     */
    where?: EvaluationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationDocuments to fetch.
     */
    orderBy?: EvaluationDocumentOrderByWithRelationInput | EvaluationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluationDocuments.
     */
    cursor?: EvaluationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationDocuments.
     */
    skip?: number
    distinct?: EvaluationDocumentScalarFieldEnum | EvaluationDocumentScalarFieldEnum[]
  }

  /**
   * EvaluationDocument create
   */
  export type EvaluationDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaluationDocument.
     */
    data: XOR<EvaluationDocumentCreateInput, EvaluationDocumentUncheckedCreateInput>
  }

  /**
   * EvaluationDocument createMany
   */
  export type EvaluationDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluationDocuments.
     */
    data: EvaluationDocumentCreateManyInput | EvaluationDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvaluationDocument createManyAndReturn
   */
  export type EvaluationDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvaluationDocuments.
     */
    data: EvaluationDocumentCreateManyInput | EvaluationDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvaluationDocument update
   */
  export type EvaluationDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaluationDocument.
     */
    data: XOR<EvaluationDocumentUpdateInput, EvaluationDocumentUncheckedUpdateInput>
    /**
     * Choose, which EvaluationDocument to update.
     */
    where: EvaluationDocumentWhereUniqueInput
  }

  /**
   * EvaluationDocument updateMany
   */
  export type EvaluationDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluationDocuments.
     */
    data: XOR<EvaluationDocumentUpdateManyMutationInput, EvaluationDocumentUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationDocuments to update
     */
    where?: EvaluationDocumentWhereInput
  }

  /**
   * EvaluationDocument upsert
   */
  export type EvaluationDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaluationDocument to update in case it exists.
     */
    where: EvaluationDocumentWhereUniqueInput
    /**
     * In case the EvaluationDocument found by the `where` argument doesn't exist, create a new EvaluationDocument with this data.
     */
    create: XOR<EvaluationDocumentCreateInput, EvaluationDocumentUncheckedCreateInput>
    /**
     * In case the EvaluationDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationDocumentUpdateInput, EvaluationDocumentUncheckedUpdateInput>
  }

  /**
   * EvaluationDocument delete
   */
  export type EvaluationDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentInclude<ExtArgs> | null
    /**
     * Filter which EvaluationDocument to delete.
     */
    where: EvaluationDocumentWhereUniqueInput
  }

  /**
   * EvaluationDocument deleteMany
   */
  export type EvaluationDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationDocuments to delete
     */
    where?: EvaluationDocumentWhereInput
  }

  /**
   * EvaluationDocument without action
   */
  export type EvaluationDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationDocument
     */
    select?: EvaluationDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationDocumentInclude<ExtArgs> | null
  }


  /**
   * Model AnalyticsAccessLog
   */

  export type AggregateAnalyticsAccessLog = {
    _count: AnalyticsAccessLogCountAggregateOutputType | null
    _min: AnalyticsAccessLogMinAggregateOutputType | null
    _max: AnalyticsAccessLogMaxAggregateOutputType | null
  }

  export type AnalyticsAccessLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    role: string | null
    endpoint: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AnalyticsAccessLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    role: string | null
    endpoint: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AnalyticsAccessLogCountAggregateOutputType = {
    id: number
    userId: number
    role: number
    endpoint: number
    ip: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AnalyticsAccessLogMinAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    endpoint?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type AnalyticsAccessLogMaxAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    endpoint?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type AnalyticsAccessLogCountAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    endpoint?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsAccessLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsAccessLog to aggregate.
     */
    where?: AnalyticsAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAccessLogs to fetch.
     */
    orderBy?: AnalyticsAccessLogOrderByWithRelationInput | AnalyticsAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsAccessLogs
    **/
    _count?: true | AnalyticsAccessLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsAccessLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsAccessLogMaxAggregateInputType
  }

  export type GetAnalyticsAccessLogAggregateType<T extends AnalyticsAccessLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsAccessLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsAccessLog[P]>
      : GetScalarType<T[P], AggregateAnalyticsAccessLog[P]>
  }




  export type AnalyticsAccessLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsAccessLogWhereInput
    orderBy?: AnalyticsAccessLogOrderByWithAggregationInput | AnalyticsAccessLogOrderByWithAggregationInput[]
    by: AnalyticsAccessLogScalarFieldEnum[] | AnalyticsAccessLogScalarFieldEnum
    having?: AnalyticsAccessLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsAccessLogCountAggregateInputType | true
    _min?: AnalyticsAccessLogMinAggregateInputType
    _max?: AnalyticsAccessLogMaxAggregateInputType
  }

  export type AnalyticsAccessLogGroupByOutputType = {
    id: string
    userId: string
    role: string
    endpoint: string
    ip: string | null
    userAgent: string | null
    createdAt: Date
    _count: AnalyticsAccessLogCountAggregateOutputType | null
    _min: AnalyticsAccessLogMinAggregateOutputType | null
    _max: AnalyticsAccessLogMaxAggregateOutputType | null
  }

  type GetAnalyticsAccessLogGroupByPayload<T extends AnalyticsAccessLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsAccessLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsAccessLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsAccessLogGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsAccessLogGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsAccessLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    endpoint?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsAccessLog"]>

  export type AnalyticsAccessLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    endpoint?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsAccessLog"]>

  export type AnalyticsAccessLogSelectScalar = {
    id?: boolean
    userId?: boolean
    role?: boolean
    endpoint?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AnalyticsAccessLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnalyticsAccessLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnalyticsAccessLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsAccessLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      role: string
      endpoint: string
      ip: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["analyticsAccessLog"]>
    composites: {}
  }

  type AnalyticsAccessLogGetPayload<S extends boolean | null | undefined | AnalyticsAccessLogDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsAccessLogPayload, S>

  type AnalyticsAccessLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnalyticsAccessLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalyticsAccessLogCountAggregateInputType | true
    }

  export interface AnalyticsAccessLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsAccessLog'], meta: { name: 'AnalyticsAccessLog' } }
    /**
     * Find zero or one AnalyticsAccessLog that matches the filter.
     * @param {AnalyticsAccessLogFindUniqueArgs} args - Arguments to find a AnalyticsAccessLog
     * @example
     * // Get one AnalyticsAccessLog
     * const analyticsAccessLog = await prisma.analyticsAccessLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsAccessLogFindUniqueArgs>(args: SelectSubset<T, AnalyticsAccessLogFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsAccessLogClient<$Result.GetResult<Prisma.$AnalyticsAccessLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnalyticsAccessLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnalyticsAccessLogFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsAccessLog
     * @example
     * // Get one AnalyticsAccessLog
     * const analyticsAccessLog = await prisma.analyticsAccessLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsAccessLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsAccessLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsAccessLogClient<$Result.GetResult<Prisma.$AnalyticsAccessLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnalyticsAccessLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAccessLogFindFirstArgs} args - Arguments to find a AnalyticsAccessLog
     * @example
     * // Get one AnalyticsAccessLog
     * const analyticsAccessLog = await prisma.analyticsAccessLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsAccessLogFindFirstArgs>(args?: SelectSubset<T, AnalyticsAccessLogFindFirstArgs<ExtArgs>>): Prisma__AnalyticsAccessLogClient<$Result.GetResult<Prisma.$AnalyticsAccessLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnalyticsAccessLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAccessLogFindFirstOrThrowArgs} args - Arguments to find a AnalyticsAccessLog
     * @example
     * // Get one AnalyticsAccessLog
     * const analyticsAccessLog = await prisma.analyticsAccessLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsAccessLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsAccessLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsAccessLogClient<$Result.GetResult<Prisma.$AnalyticsAccessLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnalyticsAccessLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAccessLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsAccessLogs
     * const analyticsAccessLogs = await prisma.analyticsAccessLog.findMany()
     * 
     * // Get first 10 AnalyticsAccessLogs
     * const analyticsAccessLogs = await prisma.analyticsAccessLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsAccessLogWithIdOnly = await prisma.analyticsAccessLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsAccessLogFindManyArgs>(args?: SelectSubset<T, AnalyticsAccessLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsAccessLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnalyticsAccessLog.
     * @param {AnalyticsAccessLogCreateArgs} args - Arguments to create a AnalyticsAccessLog.
     * @example
     * // Create one AnalyticsAccessLog
     * const AnalyticsAccessLog = await prisma.analyticsAccessLog.create({
     *   data: {
     *     // ... data to create a AnalyticsAccessLog
     *   }
     * })
     * 
     */
    create<T extends AnalyticsAccessLogCreateArgs>(args: SelectSubset<T, AnalyticsAccessLogCreateArgs<ExtArgs>>): Prisma__AnalyticsAccessLogClient<$Result.GetResult<Prisma.$AnalyticsAccessLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnalyticsAccessLogs.
     * @param {AnalyticsAccessLogCreateManyArgs} args - Arguments to create many AnalyticsAccessLogs.
     * @example
     * // Create many AnalyticsAccessLogs
     * const analyticsAccessLog = await prisma.analyticsAccessLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsAccessLogCreateManyArgs>(args?: SelectSubset<T, AnalyticsAccessLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsAccessLogs and returns the data saved in the database.
     * @param {AnalyticsAccessLogCreateManyAndReturnArgs} args - Arguments to create many AnalyticsAccessLogs.
     * @example
     * // Create many AnalyticsAccessLogs
     * const analyticsAccessLog = await prisma.analyticsAccessLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsAccessLogs and only return the `id`
     * const analyticsAccessLogWithIdOnly = await prisma.analyticsAccessLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsAccessLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsAccessLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsAccessLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnalyticsAccessLog.
     * @param {AnalyticsAccessLogDeleteArgs} args - Arguments to delete one AnalyticsAccessLog.
     * @example
     * // Delete one AnalyticsAccessLog
     * const AnalyticsAccessLog = await prisma.analyticsAccessLog.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsAccessLog
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsAccessLogDeleteArgs>(args: SelectSubset<T, AnalyticsAccessLogDeleteArgs<ExtArgs>>): Prisma__AnalyticsAccessLogClient<$Result.GetResult<Prisma.$AnalyticsAccessLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnalyticsAccessLog.
     * @param {AnalyticsAccessLogUpdateArgs} args - Arguments to update one AnalyticsAccessLog.
     * @example
     * // Update one AnalyticsAccessLog
     * const analyticsAccessLog = await prisma.analyticsAccessLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsAccessLogUpdateArgs>(args: SelectSubset<T, AnalyticsAccessLogUpdateArgs<ExtArgs>>): Prisma__AnalyticsAccessLogClient<$Result.GetResult<Prisma.$AnalyticsAccessLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnalyticsAccessLogs.
     * @param {AnalyticsAccessLogDeleteManyArgs} args - Arguments to filter AnalyticsAccessLogs to delete.
     * @example
     * // Delete a few AnalyticsAccessLogs
     * const { count } = await prisma.analyticsAccessLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsAccessLogDeleteManyArgs>(args?: SelectSubset<T, AnalyticsAccessLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAccessLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsAccessLogs
     * const analyticsAccessLog = await prisma.analyticsAccessLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsAccessLogUpdateManyArgs>(args: SelectSubset<T, AnalyticsAccessLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalyticsAccessLog.
     * @param {AnalyticsAccessLogUpsertArgs} args - Arguments to update or create a AnalyticsAccessLog.
     * @example
     * // Update or create a AnalyticsAccessLog
     * const analyticsAccessLog = await prisma.analyticsAccessLog.upsert({
     *   create: {
     *     // ... data to create a AnalyticsAccessLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsAccessLog we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsAccessLogUpsertArgs>(args: SelectSubset<T, AnalyticsAccessLogUpsertArgs<ExtArgs>>): Prisma__AnalyticsAccessLogClient<$Result.GetResult<Prisma.$AnalyticsAccessLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnalyticsAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAccessLogCountArgs} args - Arguments to filter AnalyticsAccessLogs to count.
     * @example
     * // Count the number of AnalyticsAccessLogs
     * const count = await prisma.analyticsAccessLog.count({
     *   where: {
     *     // ... the filter for the AnalyticsAccessLogs we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsAccessLogCountArgs>(
      args?: Subset<T, AnalyticsAccessLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsAccessLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAccessLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsAccessLogAggregateArgs>(args: Subset<T, AnalyticsAccessLogAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsAccessLogAggregateType<T>>

    /**
     * Group by AnalyticsAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAccessLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsAccessLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsAccessLogGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsAccessLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsAccessLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsAccessLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsAccessLog model
   */
  readonly fields: AnalyticsAccessLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsAccessLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsAccessLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsAccessLog model
   */ 
  interface AnalyticsAccessLogFieldRefs {
    readonly id: FieldRef<"AnalyticsAccessLog", 'String'>
    readonly userId: FieldRef<"AnalyticsAccessLog", 'String'>
    readonly role: FieldRef<"AnalyticsAccessLog", 'String'>
    readonly endpoint: FieldRef<"AnalyticsAccessLog", 'String'>
    readonly ip: FieldRef<"AnalyticsAccessLog", 'String'>
    readonly userAgent: FieldRef<"AnalyticsAccessLog", 'String'>
    readonly createdAt: FieldRef<"AnalyticsAccessLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsAccessLog findUnique
   */
  export type AnalyticsAccessLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsAccessLog to fetch.
     */
    where: AnalyticsAccessLogWhereUniqueInput
  }

  /**
   * AnalyticsAccessLog findUniqueOrThrow
   */
  export type AnalyticsAccessLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsAccessLog to fetch.
     */
    where: AnalyticsAccessLogWhereUniqueInput
  }

  /**
   * AnalyticsAccessLog findFirst
   */
  export type AnalyticsAccessLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsAccessLog to fetch.
     */
    where?: AnalyticsAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAccessLogs to fetch.
     */
    orderBy?: AnalyticsAccessLogOrderByWithRelationInput | AnalyticsAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsAccessLogs.
     */
    cursor?: AnalyticsAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsAccessLogs.
     */
    distinct?: AnalyticsAccessLogScalarFieldEnum | AnalyticsAccessLogScalarFieldEnum[]
  }

  /**
   * AnalyticsAccessLog findFirstOrThrow
   */
  export type AnalyticsAccessLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsAccessLog to fetch.
     */
    where?: AnalyticsAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAccessLogs to fetch.
     */
    orderBy?: AnalyticsAccessLogOrderByWithRelationInput | AnalyticsAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsAccessLogs.
     */
    cursor?: AnalyticsAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsAccessLogs.
     */
    distinct?: AnalyticsAccessLogScalarFieldEnum | AnalyticsAccessLogScalarFieldEnum[]
  }

  /**
   * AnalyticsAccessLog findMany
   */
  export type AnalyticsAccessLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsAccessLogs to fetch.
     */
    where?: AnalyticsAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAccessLogs to fetch.
     */
    orderBy?: AnalyticsAccessLogOrderByWithRelationInput | AnalyticsAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsAccessLogs.
     */
    cursor?: AnalyticsAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAccessLogs.
     */
    skip?: number
    distinct?: AnalyticsAccessLogScalarFieldEnum | AnalyticsAccessLogScalarFieldEnum[]
  }

  /**
   * AnalyticsAccessLog create
   */
  export type AnalyticsAccessLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsAccessLog.
     */
    data: XOR<AnalyticsAccessLogCreateInput, AnalyticsAccessLogUncheckedCreateInput>
  }

  /**
   * AnalyticsAccessLog createMany
   */
  export type AnalyticsAccessLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsAccessLogs.
     */
    data: AnalyticsAccessLogCreateManyInput | AnalyticsAccessLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsAccessLog createManyAndReturn
   */
  export type AnalyticsAccessLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnalyticsAccessLogs.
     */
    data: AnalyticsAccessLogCreateManyInput | AnalyticsAccessLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsAccessLog update
   */
  export type AnalyticsAccessLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsAccessLog.
     */
    data: XOR<AnalyticsAccessLogUpdateInput, AnalyticsAccessLogUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsAccessLog to update.
     */
    where: AnalyticsAccessLogWhereUniqueInput
  }

  /**
   * AnalyticsAccessLog updateMany
   */
  export type AnalyticsAccessLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsAccessLogs.
     */
    data: XOR<AnalyticsAccessLogUpdateManyMutationInput, AnalyticsAccessLogUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsAccessLogs to update
     */
    where?: AnalyticsAccessLogWhereInput
  }

  /**
   * AnalyticsAccessLog upsert
   */
  export type AnalyticsAccessLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsAccessLog to update in case it exists.
     */
    where: AnalyticsAccessLogWhereUniqueInput
    /**
     * In case the AnalyticsAccessLog found by the `where` argument doesn't exist, create a new AnalyticsAccessLog with this data.
     */
    create: XOR<AnalyticsAccessLogCreateInput, AnalyticsAccessLogUncheckedCreateInput>
    /**
     * In case the AnalyticsAccessLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsAccessLogUpdateInput, AnalyticsAccessLogUncheckedUpdateInput>
  }

  /**
   * AnalyticsAccessLog delete
   */
  export type AnalyticsAccessLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogInclude<ExtArgs> | null
    /**
     * Filter which AnalyticsAccessLog to delete.
     */
    where: AnalyticsAccessLogWhereUniqueInput
  }

  /**
   * AnalyticsAccessLog deleteMany
   */
  export type AnalyticsAccessLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsAccessLogs to delete
     */
    where?: AnalyticsAccessLogWhereInput
  }

  /**
   * AnalyticsAccessLog without action
   */
  export type AnalyticsAccessLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAccessLog
     */
    select?: AnalyticsAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsAccessLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    message: string
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      message: string
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationRule
   */

  export type AggregateNotificationRule = {
    _count: NotificationRuleCountAggregateOutputType | null
    _min: NotificationRuleMinAggregateOutputType | null
    _max: NotificationRuleMaxAggregateOutputType | null
  }

  export type NotificationRuleMinAggregateOutputType = {
    id: string | null
    trigger: string | null
    role: string | null
    enabled: boolean | null
    ownerId: string | null
  }

  export type NotificationRuleMaxAggregateOutputType = {
    id: string | null
    trigger: string | null
    role: string | null
    enabled: boolean | null
    ownerId: string | null
  }

  export type NotificationRuleCountAggregateOutputType = {
    id: number
    trigger: number
    role: number
    enabled: number
    ownerId: number
    _all: number
  }


  export type NotificationRuleMinAggregateInputType = {
    id?: true
    trigger?: true
    role?: true
    enabled?: true
    ownerId?: true
  }

  export type NotificationRuleMaxAggregateInputType = {
    id?: true
    trigger?: true
    role?: true
    enabled?: true
    ownerId?: true
  }

  export type NotificationRuleCountAggregateInputType = {
    id?: true
    trigger?: true
    role?: true
    enabled?: true
    ownerId?: true
    _all?: true
  }

  export type NotificationRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRule to aggregate.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationRules
    **/
    _count?: true | NotificationRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationRuleMaxAggregateInputType
  }

  export type GetNotificationRuleAggregateType<T extends NotificationRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationRule[P]>
      : GetScalarType<T[P], AggregateNotificationRule[P]>
  }




  export type NotificationRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRuleWhereInput
    orderBy?: NotificationRuleOrderByWithAggregationInput | NotificationRuleOrderByWithAggregationInput[]
    by: NotificationRuleScalarFieldEnum[] | NotificationRuleScalarFieldEnum
    having?: NotificationRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationRuleCountAggregateInputType | true
    _min?: NotificationRuleMinAggregateInputType
    _max?: NotificationRuleMaxAggregateInputType
  }

  export type NotificationRuleGroupByOutputType = {
    id: string
    trigger: string
    role: string
    enabled: boolean
    ownerId: string | null
    _count: NotificationRuleCountAggregateOutputType | null
    _min: NotificationRuleMinAggregateOutputType | null
    _max: NotificationRuleMaxAggregateOutputType | null
  }

  type GetNotificationRuleGroupByPayload<T extends NotificationRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationRuleGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationRuleGroupByOutputType[P]>
        }
      >
    >


  export type NotificationRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trigger?: boolean
    role?: boolean
    enabled?: boolean
    ownerId?: boolean
    owner?: boolean | NotificationRule$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRule"]>

  export type NotificationRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trigger?: boolean
    role?: boolean
    enabled?: boolean
    ownerId?: boolean
    owner?: boolean | NotificationRule$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRule"]>

  export type NotificationRuleSelectScalar = {
    id?: boolean
    trigger?: boolean
    role?: boolean
    enabled?: boolean
    ownerId?: boolean
  }

  export type NotificationRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | NotificationRule$ownerArgs<ExtArgs>
  }
  export type NotificationRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | NotificationRule$ownerArgs<ExtArgs>
  }

  export type $NotificationRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationRule"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trigger: string
      role: string
      enabled: boolean
      ownerId: string | null
    }, ExtArgs["result"]["notificationRule"]>
    composites: {}
  }

  type NotificationRuleGetPayload<S extends boolean | null | undefined | NotificationRuleDefaultArgs> = $Result.GetResult<Prisma.$NotificationRulePayload, S>

  type NotificationRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationRuleCountAggregateInputType | true
    }

  export interface NotificationRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationRule'], meta: { name: 'NotificationRule' } }
    /**
     * Find zero or one NotificationRule that matches the filter.
     * @param {NotificationRuleFindUniqueArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationRuleFindUniqueArgs>(args: SelectSubset<T, NotificationRuleFindUniqueArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationRuleFindUniqueOrThrowArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleFindFirstArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationRuleFindFirstArgs>(args?: SelectSubset<T, NotificationRuleFindFirstArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleFindFirstOrThrowArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationRules
     * const notificationRules = await prisma.notificationRule.findMany()
     * 
     * // Get first 10 NotificationRules
     * const notificationRules = await prisma.notificationRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationRuleWithIdOnly = await prisma.notificationRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationRuleFindManyArgs>(args?: SelectSubset<T, NotificationRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationRule.
     * @param {NotificationRuleCreateArgs} args - Arguments to create a NotificationRule.
     * @example
     * // Create one NotificationRule
     * const NotificationRule = await prisma.notificationRule.create({
     *   data: {
     *     // ... data to create a NotificationRule
     *   }
     * })
     * 
     */
    create<T extends NotificationRuleCreateArgs>(args: SelectSubset<T, NotificationRuleCreateArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationRules.
     * @param {NotificationRuleCreateManyArgs} args - Arguments to create many NotificationRules.
     * @example
     * // Create many NotificationRules
     * const notificationRule = await prisma.notificationRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationRuleCreateManyArgs>(args?: SelectSubset<T, NotificationRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationRules and returns the data saved in the database.
     * @param {NotificationRuleCreateManyAndReturnArgs} args - Arguments to create many NotificationRules.
     * @example
     * // Create many NotificationRules
     * const notificationRule = await prisma.notificationRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationRules and only return the `id`
     * const notificationRuleWithIdOnly = await prisma.notificationRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationRule.
     * @param {NotificationRuleDeleteArgs} args - Arguments to delete one NotificationRule.
     * @example
     * // Delete one NotificationRule
     * const NotificationRule = await prisma.notificationRule.delete({
     *   where: {
     *     // ... filter to delete one NotificationRule
     *   }
     * })
     * 
     */
    delete<T extends NotificationRuleDeleteArgs>(args: SelectSubset<T, NotificationRuleDeleteArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationRule.
     * @param {NotificationRuleUpdateArgs} args - Arguments to update one NotificationRule.
     * @example
     * // Update one NotificationRule
     * const notificationRule = await prisma.notificationRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationRuleUpdateArgs>(args: SelectSubset<T, NotificationRuleUpdateArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationRules.
     * @param {NotificationRuleDeleteManyArgs} args - Arguments to filter NotificationRules to delete.
     * @example
     * // Delete a few NotificationRules
     * const { count } = await prisma.notificationRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationRuleDeleteManyArgs>(args?: SelectSubset<T, NotificationRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationRules
     * const notificationRule = await prisma.notificationRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationRuleUpdateManyArgs>(args: SelectSubset<T, NotificationRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationRule.
     * @param {NotificationRuleUpsertArgs} args - Arguments to update or create a NotificationRule.
     * @example
     * // Update or create a NotificationRule
     * const notificationRule = await prisma.notificationRule.upsert({
     *   create: {
     *     // ... data to create a NotificationRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationRule we want to update
     *   }
     * })
     */
    upsert<T extends NotificationRuleUpsertArgs>(args: SelectSubset<T, NotificationRuleUpsertArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleCountArgs} args - Arguments to filter NotificationRules to count.
     * @example
     * // Count the number of NotificationRules
     * const count = await prisma.notificationRule.count({
     *   where: {
     *     // ... the filter for the NotificationRules we want to count
     *   }
     * })
    **/
    count<T extends NotificationRuleCountArgs>(
      args?: Subset<T, NotificationRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationRuleAggregateArgs>(args: Subset<T, NotificationRuleAggregateArgs>): Prisma.PrismaPromise<GetNotificationRuleAggregateType<T>>

    /**
     * Group by NotificationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationRuleGroupByArgs['orderBy'] }
        : { orderBy?: NotificationRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationRule model
   */
  readonly fields: NotificationRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends NotificationRule$ownerArgs<ExtArgs> = {}>(args?: Subset<T, NotificationRule$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationRule model
   */ 
  interface NotificationRuleFieldRefs {
    readonly id: FieldRef<"NotificationRule", 'String'>
    readonly trigger: FieldRef<"NotificationRule", 'String'>
    readonly role: FieldRef<"NotificationRule", 'String'>
    readonly enabled: FieldRef<"NotificationRule", 'Boolean'>
    readonly ownerId: FieldRef<"NotificationRule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NotificationRule findUnique
   */
  export type NotificationRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule findUniqueOrThrow
   */
  export type NotificationRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule findFirst
   */
  export type NotificationRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationRules.
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationRules.
     */
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * NotificationRule findFirstOrThrow
   */
  export type NotificationRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationRules.
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationRules.
     */
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * NotificationRule findMany
   */
  export type NotificationRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRules to fetch.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationRules.
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * NotificationRule create
   */
  export type NotificationRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationRule.
     */
    data: XOR<NotificationRuleCreateInput, NotificationRuleUncheckedCreateInput>
  }

  /**
   * NotificationRule createMany
   */
  export type NotificationRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationRules.
     */
    data: NotificationRuleCreateManyInput | NotificationRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationRule createManyAndReturn
   */
  export type NotificationRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationRules.
     */
    data: NotificationRuleCreateManyInput | NotificationRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationRule update
   */
  export type NotificationRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationRule.
     */
    data: XOR<NotificationRuleUpdateInput, NotificationRuleUncheckedUpdateInput>
    /**
     * Choose, which NotificationRule to update.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule updateMany
   */
  export type NotificationRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationRules.
     */
    data: XOR<NotificationRuleUpdateManyMutationInput, NotificationRuleUncheckedUpdateManyInput>
    /**
     * Filter which NotificationRules to update
     */
    where?: NotificationRuleWhereInput
  }

  /**
   * NotificationRule upsert
   */
  export type NotificationRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationRule to update in case it exists.
     */
    where: NotificationRuleWhereUniqueInput
    /**
     * In case the NotificationRule found by the `where` argument doesn't exist, create a new NotificationRule with this data.
     */
    create: XOR<NotificationRuleCreateInput, NotificationRuleUncheckedCreateInput>
    /**
     * In case the NotificationRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationRuleUpdateInput, NotificationRuleUncheckedUpdateInput>
  }

  /**
   * NotificationRule delete
   */
  export type NotificationRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter which NotificationRule to delete.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule deleteMany
   */
  export type NotificationRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRules to delete
     */
    where?: NotificationRuleWhereInput
  }

  /**
   * NotificationRule.owner
   */
  export type NotificationRule$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NotificationRule without action
   */
  export type NotificationRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
  }


  /**
   * Model TenderTimelineEvent
   */

  export type AggregateTenderTimelineEvent = {
    _count: TenderTimelineEventCountAggregateOutputType | null
    _min: TenderTimelineEventMinAggregateOutputType | null
    _max: TenderTimelineEventMaxAggregateOutputType | null
  }

  export type TenderTimelineEventMinAggregateOutputType = {
    id: string | null
    tenderId: string | null
    type: string | null
    label: string | null
    createdAt: Date | null
  }

  export type TenderTimelineEventMaxAggregateOutputType = {
    id: string | null
    tenderId: string | null
    type: string | null
    label: string | null
    createdAt: Date | null
  }

  export type TenderTimelineEventCountAggregateOutputType = {
    id: number
    tenderId: number
    type: number
    label: number
    createdAt: number
    _all: number
  }


  export type TenderTimelineEventMinAggregateInputType = {
    id?: true
    tenderId?: true
    type?: true
    label?: true
    createdAt?: true
  }

  export type TenderTimelineEventMaxAggregateInputType = {
    id?: true
    tenderId?: true
    type?: true
    label?: true
    createdAt?: true
  }

  export type TenderTimelineEventCountAggregateInputType = {
    id?: true
    tenderId?: true
    type?: true
    label?: true
    createdAt?: true
    _all?: true
  }

  export type TenderTimelineEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenderTimelineEvent to aggregate.
     */
    where?: TenderTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderTimelineEvents to fetch.
     */
    orderBy?: TenderTimelineEventOrderByWithRelationInput | TenderTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenderTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderTimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenderTimelineEvents
    **/
    _count?: true | TenderTimelineEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenderTimelineEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenderTimelineEventMaxAggregateInputType
  }

  export type GetTenderTimelineEventAggregateType<T extends TenderTimelineEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTenderTimelineEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenderTimelineEvent[P]>
      : GetScalarType<T[P], AggregateTenderTimelineEvent[P]>
  }




  export type TenderTimelineEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenderTimelineEventWhereInput
    orderBy?: TenderTimelineEventOrderByWithAggregationInput | TenderTimelineEventOrderByWithAggregationInput[]
    by: TenderTimelineEventScalarFieldEnum[] | TenderTimelineEventScalarFieldEnum
    having?: TenderTimelineEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenderTimelineEventCountAggregateInputType | true
    _min?: TenderTimelineEventMinAggregateInputType
    _max?: TenderTimelineEventMaxAggregateInputType
  }

  export type TenderTimelineEventGroupByOutputType = {
    id: string
    tenderId: string
    type: string
    label: string
    createdAt: Date
    _count: TenderTimelineEventCountAggregateOutputType | null
    _min: TenderTimelineEventMinAggregateOutputType | null
    _max: TenderTimelineEventMaxAggregateOutputType | null
  }

  type GetTenderTimelineEventGroupByPayload<T extends TenderTimelineEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenderTimelineEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenderTimelineEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenderTimelineEventGroupByOutputType[P]>
            : GetScalarType<T[P], TenderTimelineEventGroupByOutputType[P]>
        }
      >
    >


  export type TenderTimelineEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    type?: boolean
    label?: boolean
    createdAt?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenderTimelineEvent"]>

  export type TenderTimelineEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenderId?: boolean
    type?: boolean
    label?: boolean
    createdAt?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenderTimelineEvent"]>

  export type TenderTimelineEventSelectScalar = {
    id?: boolean
    tenderId?: boolean
    type?: boolean
    label?: boolean
    createdAt?: boolean
  }

  export type TenderTimelineEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }
  export type TenderTimelineEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }

  export type $TenderTimelineEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenderTimelineEvent"
    objects: {
      tender: Prisma.$TenderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenderId: string
      type: string
      label: string
      createdAt: Date
    }, ExtArgs["result"]["tenderTimelineEvent"]>
    composites: {}
  }

  type TenderTimelineEventGetPayload<S extends boolean | null | undefined | TenderTimelineEventDefaultArgs> = $Result.GetResult<Prisma.$TenderTimelineEventPayload, S>

  type TenderTimelineEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenderTimelineEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenderTimelineEventCountAggregateInputType | true
    }

  export interface TenderTimelineEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenderTimelineEvent'], meta: { name: 'TenderTimelineEvent' } }
    /**
     * Find zero or one TenderTimelineEvent that matches the filter.
     * @param {TenderTimelineEventFindUniqueArgs} args - Arguments to find a TenderTimelineEvent
     * @example
     * // Get one TenderTimelineEvent
     * const tenderTimelineEvent = await prisma.tenderTimelineEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenderTimelineEventFindUniqueArgs>(args: SelectSubset<T, TenderTimelineEventFindUniqueArgs<ExtArgs>>): Prisma__TenderTimelineEventClient<$Result.GetResult<Prisma.$TenderTimelineEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TenderTimelineEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenderTimelineEventFindUniqueOrThrowArgs} args - Arguments to find a TenderTimelineEvent
     * @example
     * // Get one TenderTimelineEvent
     * const tenderTimelineEvent = await prisma.tenderTimelineEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenderTimelineEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TenderTimelineEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenderTimelineEventClient<$Result.GetResult<Prisma.$TenderTimelineEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TenderTimelineEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderTimelineEventFindFirstArgs} args - Arguments to find a TenderTimelineEvent
     * @example
     * // Get one TenderTimelineEvent
     * const tenderTimelineEvent = await prisma.tenderTimelineEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenderTimelineEventFindFirstArgs>(args?: SelectSubset<T, TenderTimelineEventFindFirstArgs<ExtArgs>>): Prisma__TenderTimelineEventClient<$Result.GetResult<Prisma.$TenderTimelineEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TenderTimelineEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderTimelineEventFindFirstOrThrowArgs} args - Arguments to find a TenderTimelineEvent
     * @example
     * // Get one TenderTimelineEvent
     * const tenderTimelineEvent = await prisma.tenderTimelineEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenderTimelineEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TenderTimelineEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenderTimelineEventClient<$Result.GetResult<Prisma.$TenderTimelineEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TenderTimelineEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderTimelineEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenderTimelineEvents
     * const tenderTimelineEvents = await prisma.tenderTimelineEvent.findMany()
     * 
     * // Get first 10 TenderTimelineEvents
     * const tenderTimelineEvents = await prisma.tenderTimelineEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenderTimelineEventWithIdOnly = await prisma.tenderTimelineEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenderTimelineEventFindManyArgs>(args?: SelectSubset<T, TenderTimelineEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderTimelineEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TenderTimelineEvent.
     * @param {TenderTimelineEventCreateArgs} args - Arguments to create a TenderTimelineEvent.
     * @example
     * // Create one TenderTimelineEvent
     * const TenderTimelineEvent = await prisma.tenderTimelineEvent.create({
     *   data: {
     *     // ... data to create a TenderTimelineEvent
     *   }
     * })
     * 
     */
    create<T extends TenderTimelineEventCreateArgs>(args: SelectSubset<T, TenderTimelineEventCreateArgs<ExtArgs>>): Prisma__TenderTimelineEventClient<$Result.GetResult<Prisma.$TenderTimelineEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TenderTimelineEvents.
     * @param {TenderTimelineEventCreateManyArgs} args - Arguments to create many TenderTimelineEvents.
     * @example
     * // Create many TenderTimelineEvents
     * const tenderTimelineEvent = await prisma.tenderTimelineEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenderTimelineEventCreateManyArgs>(args?: SelectSubset<T, TenderTimelineEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenderTimelineEvents and returns the data saved in the database.
     * @param {TenderTimelineEventCreateManyAndReturnArgs} args - Arguments to create many TenderTimelineEvents.
     * @example
     * // Create many TenderTimelineEvents
     * const tenderTimelineEvent = await prisma.tenderTimelineEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenderTimelineEvents and only return the `id`
     * const tenderTimelineEventWithIdOnly = await prisma.tenderTimelineEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenderTimelineEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TenderTimelineEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderTimelineEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TenderTimelineEvent.
     * @param {TenderTimelineEventDeleteArgs} args - Arguments to delete one TenderTimelineEvent.
     * @example
     * // Delete one TenderTimelineEvent
     * const TenderTimelineEvent = await prisma.tenderTimelineEvent.delete({
     *   where: {
     *     // ... filter to delete one TenderTimelineEvent
     *   }
     * })
     * 
     */
    delete<T extends TenderTimelineEventDeleteArgs>(args: SelectSubset<T, TenderTimelineEventDeleteArgs<ExtArgs>>): Prisma__TenderTimelineEventClient<$Result.GetResult<Prisma.$TenderTimelineEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TenderTimelineEvent.
     * @param {TenderTimelineEventUpdateArgs} args - Arguments to update one TenderTimelineEvent.
     * @example
     * // Update one TenderTimelineEvent
     * const tenderTimelineEvent = await prisma.tenderTimelineEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenderTimelineEventUpdateArgs>(args: SelectSubset<T, TenderTimelineEventUpdateArgs<ExtArgs>>): Prisma__TenderTimelineEventClient<$Result.GetResult<Prisma.$TenderTimelineEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TenderTimelineEvents.
     * @param {TenderTimelineEventDeleteManyArgs} args - Arguments to filter TenderTimelineEvents to delete.
     * @example
     * // Delete a few TenderTimelineEvents
     * const { count } = await prisma.tenderTimelineEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenderTimelineEventDeleteManyArgs>(args?: SelectSubset<T, TenderTimelineEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenderTimelineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderTimelineEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenderTimelineEvents
     * const tenderTimelineEvent = await prisma.tenderTimelineEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenderTimelineEventUpdateManyArgs>(args: SelectSubset<T, TenderTimelineEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TenderTimelineEvent.
     * @param {TenderTimelineEventUpsertArgs} args - Arguments to update or create a TenderTimelineEvent.
     * @example
     * // Update or create a TenderTimelineEvent
     * const tenderTimelineEvent = await prisma.tenderTimelineEvent.upsert({
     *   create: {
     *     // ... data to create a TenderTimelineEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenderTimelineEvent we want to update
     *   }
     * })
     */
    upsert<T extends TenderTimelineEventUpsertArgs>(args: SelectSubset<T, TenderTimelineEventUpsertArgs<ExtArgs>>): Prisma__TenderTimelineEventClient<$Result.GetResult<Prisma.$TenderTimelineEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TenderTimelineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderTimelineEventCountArgs} args - Arguments to filter TenderTimelineEvents to count.
     * @example
     * // Count the number of TenderTimelineEvents
     * const count = await prisma.tenderTimelineEvent.count({
     *   where: {
     *     // ... the filter for the TenderTimelineEvents we want to count
     *   }
     * })
    **/
    count<T extends TenderTimelineEventCountArgs>(
      args?: Subset<T, TenderTimelineEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenderTimelineEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenderTimelineEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderTimelineEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenderTimelineEventAggregateArgs>(args: Subset<T, TenderTimelineEventAggregateArgs>): Prisma.PrismaPromise<GetTenderTimelineEventAggregateType<T>>

    /**
     * Group by TenderTimelineEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderTimelineEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenderTimelineEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenderTimelineEventGroupByArgs['orderBy'] }
        : { orderBy?: TenderTimelineEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenderTimelineEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenderTimelineEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenderTimelineEvent model
   */
  readonly fields: TenderTimelineEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenderTimelineEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenderTimelineEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tender<T extends TenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenderDefaultArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenderTimelineEvent model
   */ 
  interface TenderTimelineEventFieldRefs {
    readonly id: FieldRef<"TenderTimelineEvent", 'String'>
    readonly tenderId: FieldRef<"TenderTimelineEvent", 'String'>
    readonly type: FieldRef<"TenderTimelineEvent", 'String'>
    readonly label: FieldRef<"TenderTimelineEvent", 'String'>
    readonly createdAt: FieldRef<"TenderTimelineEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenderTimelineEvent findUnique
   */
  export type TenderTimelineEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TenderTimelineEvent to fetch.
     */
    where: TenderTimelineEventWhereUniqueInput
  }

  /**
   * TenderTimelineEvent findUniqueOrThrow
   */
  export type TenderTimelineEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TenderTimelineEvent to fetch.
     */
    where: TenderTimelineEventWhereUniqueInput
  }

  /**
   * TenderTimelineEvent findFirst
   */
  export type TenderTimelineEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TenderTimelineEvent to fetch.
     */
    where?: TenderTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderTimelineEvents to fetch.
     */
    orderBy?: TenderTimelineEventOrderByWithRelationInput | TenderTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenderTimelineEvents.
     */
    cursor?: TenderTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderTimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenderTimelineEvents.
     */
    distinct?: TenderTimelineEventScalarFieldEnum | TenderTimelineEventScalarFieldEnum[]
  }

  /**
   * TenderTimelineEvent findFirstOrThrow
   */
  export type TenderTimelineEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TenderTimelineEvent to fetch.
     */
    where?: TenderTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderTimelineEvents to fetch.
     */
    orderBy?: TenderTimelineEventOrderByWithRelationInput | TenderTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenderTimelineEvents.
     */
    cursor?: TenderTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderTimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenderTimelineEvents.
     */
    distinct?: TenderTimelineEventScalarFieldEnum | TenderTimelineEventScalarFieldEnum[]
  }

  /**
   * TenderTimelineEvent findMany
   */
  export type TenderTimelineEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which TenderTimelineEvents to fetch.
     */
    where?: TenderTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderTimelineEvents to fetch.
     */
    orderBy?: TenderTimelineEventOrderByWithRelationInput | TenderTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenderTimelineEvents.
     */
    cursor?: TenderTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderTimelineEvents.
     */
    skip?: number
    distinct?: TenderTimelineEventScalarFieldEnum | TenderTimelineEventScalarFieldEnum[]
  }

  /**
   * TenderTimelineEvent create
   */
  export type TenderTimelineEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventInclude<ExtArgs> | null
    /**
     * The data needed to create a TenderTimelineEvent.
     */
    data: XOR<TenderTimelineEventCreateInput, TenderTimelineEventUncheckedCreateInput>
  }

  /**
   * TenderTimelineEvent createMany
   */
  export type TenderTimelineEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenderTimelineEvents.
     */
    data: TenderTimelineEventCreateManyInput | TenderTimelineEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenderTimelineEvent createManyAndReturn
   */
  export type TenderTimelineEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TenderTimelineEvents.
     */
    data: TenderTimelineEventCreateManyInput | TenderTimelineEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenderTimelineEvent update
   */
  export type TenderTimelineEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventInclude<ExtArgs> | null
    /**
     * The data needed to update a TenderTimelineEvent.
     */
    data: XOR<TenderTimelineEventUpdateInput, TenderTimelineEventUncheckedUpdateInput>
    /**
     * Choose, which TenderTimelineEvent to update.
     */
    where: TenderTimelineEventWhereUniqueInput
  }

  /**
   * TenderTimelineEvent updateMany
   */
  export type TenderTimelineEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenderTimelineEvents.
     */
    data: XOR<TenderTimelineEventUpdateManyMutationInput, TenderTimelineEventUncheckedUpdateManyInput>
    /**
     * Filter which TenderTimelineEvents to update
     */
    where?: TenderTimelineEventWhereInput
  }

  /**
   * TenderTimelineEvent upsert
   */
  export type TenderTimelineEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventInclude<ExtArgs> | null
    /**
     * The filter to search for the TenderTimelineEvent to update in case it exists.
     */
    where: TenderTimelineEventWhereUniqueInput
    /**
     * In case the TenderTimelineEvent found by the `where` argument doesn't exist, create a new TenderTimelineEvent with this data.
     */
    create: XOR<TenderTimelineEventCreateInput, TenderTimelineEventUncheckedCreateInput>
    /**
     * In case the TenderTimelineEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenderTimelineEventUpdateInput, TenderTimelineEventUncheckedUpdateInput>
  }

  /**
   * TenderTimelineEvent delete
   */
  export type TenderTimelineEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventInclude<ExtArgs> | null
    /**
     * Filter which TenderTimelineEvent to delete.
     */
    where: TenderTimelineEventWhereUniqueInput
  }

  /**
   * TenderTimelineEvent deleteMany
   */
  export type TenderTimelineEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenderTimelineEvents to delete
     */
    where?: TenderTimelineEventWhereInput
  }

  /**
   * TenderTimelineEvent without action
   */
  export type TenderTimelineEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderTimelineEvent
     */
    select?: TenderTimelineEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderTimelineEventInclude<ExtArgs> | null
  }


  /**
   * Model TenderInsights
   */

  export type AggregateTenderInsights = {
    _count: TenderInsightsCountAggregateOutputType | null
    _min: TenderInsightsMinAggregateOutputType | null
    _max: TenderInsightsMaxAggregateOutputType | null
  }

  export type TenderInsightsMinAggregateOutputType = {
    tenderId: string | null
  }

  export type TenderInsightsMaxAggregateOutputType = {
    tenderId: string | null
  }

  export type TenderInsightsCountAggregateOutputType = {
    tenderId: number
    payload: number
    _all: number
  }


  export type TenderInsightsMinAggregateInputType = {
    tenderId?: true
  }

  export type TenderInsightsMaxAggregateInputType = {
    tenderId?: true
  }

  export type TenderInsightsCountAggregateInputType = {
    tenderId?: true
    payload?: true
    _all?: true
  }

  export type TenderInsightsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenderInsights to aggregate.
     */
    where?: TenderInsightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderInsights to fetch.
     */
    orderBy?: TenderInsightsOrderByWithRelationInput | TenderInsightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenderInsightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenderInsights
    **/
    _count?: true | TenderInsightsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenderInsightsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenderInsightsMaxAggregateInputType
  }

  export type GetTenderInsightsAggregateType<T extends TenderInsightsAggregateArgs> = {
        [P in keyof T & keyof AggregateTenderInsights]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenderInsights[P]>
      : GetScalarType<T[P], AggregateTenderInsights[P]>
  }




  export type TenderInsightsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenderInsightsWhereInput
    orderBy?: TenderInsightsOrderByWithAggregationInput | TenderInsightsOrderByWithAggregationInput[]
    by: TenderInsightsScalarFieldEnum[] | TenderInsightsScalarFieldEnum
    having?: TenderInsightsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenderInsightsCountAggregateInputType | true
    _min?: TenderInsightsMinAggregateInputType
    _max?: TenderInsightsMaxAggregateInputType
  }

  export type TenderInsightsGroupByOutputType = {
    tenderId: string
    payload: JsonValue
    _count: TenderInsightsCountAggregateOutputType | null
    _min: TenderInsightsMinAggregateOutputType | null
    _max: TenderInsightsMaxAggregateOutputType | null
  }

  type GetTenderInsightsGroupByPayload<T extends TenderInsightsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenderInsightsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenderInsightsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenderInsightsGroupByOutputType[P]>
            : GetScalarType<T[P], TenderInsightsGroupByOutputType[P]>
        }
      >
    >


  export type TenderInsightsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenderId?: boolean
    payload?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenderInsights"]>

  export type TenderInsightsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenderId?: boolean
    payload?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenderInsights"]>

  export type TenderInsightsSelectScalar = {
    tenderId?: boolean
    payload?: boolean
  }

  export type TenderInsightsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }
  export type TenderInsightsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }

  export type $TenderInsightsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenderInsights"
    objects: {
      tender: Prisma.$TenderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tenderId: string
      payload: Prisma.JsonValue
    }, ExtArgs["result"]["tenderInsights"]>
    composites: {}
  }

  type TenderInsightsGetPayload<S extends boolean | null | undefined | TenderInsightsDefaultArgs> = $Result.GetResult<Prisma.$TenderInsightsPayload, S>

  type TenderInsightsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenderInsightsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenderInsightsCountAggregateInputType | true
    }

  export interface TenderInsightsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenderInsights'], meta: { name: 'TenderInsights' } }
    /**
     * Find zero or one TenderInsights that matches the filter.
     * @param {TenderInsightsFindUniqueArgs} args - Arguments to find a TenderInsights
     * @example
     * // Get one TenderInsights
     * const tenderInsights = await prisma.tenderInsights.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenderInsightsFindUniqueArgs>(args: SelectSubset<T, TenderInsightsFindUniqueArgs<ExtArgs>>): Prisma__TenderInsightsClient<$Result.GetResult<Prisma.$TenderInsightsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TenderInsights that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenderInsightsFindUniqueOrThrowArgs} args - Arguments to find a TenderInsights
     * @example
     * // Get one TenderInsights
     * const tenderInsights = await prisma.tenderInsights.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenderInsightsFindUniqueOrThrowArgs>(args: SelectSubset<T, TenderInsightsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenderInsightsClient<$Result.GetResult<Prisma.$TenderInsightsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TenderInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderInsightsFindFirstArgs} args - Arguments to find a TenderInsights
     * @example
     * // Get one TenderInsights
     * const tenderInsights = await prisma.tenderInsights.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenderInsightsFindFirstArgs>(args?: SelectSubset<T, TenderInsightsFindFirstArgs<ExtArgs>>): Prisma__TenderInsightsClient<$Result.GetResult<Prisma.$TenderInsightsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TenderInsights that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderInsightsFindFirstOrThrowArgs} args - Arguments to find a TenderInsights
     * @example
     * // Get one TenderInsights
     * const tenderInsights = await prisma.tenderInsights.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenderInsightsFindFirstOrThrowArgs>(args?: SelectSubset<T, TenderInsightsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenderInsightsClient<$Result.GetResult<Prisma.$TenderInsightsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TenderInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderInsightsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenderInsights
     * const tenderInsights = await prisma.tenderInsights.findMany()
     * 
     * // Get first 10 TenderInsights
     * const tenderInsights = await prisma.tenderInsights.findMany({ take: 10 })
     * 
     * // Only select the `tenderId`
     * const tenderInsightsWithTenderIdOnly = await prisma.tenderInsights.findMany({ select: { tenderId: true } })
     * 
     */
    findMany<T extends TenderInsightsFindManyArgs>(args?: SelectSubset<T, TenderInsightsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderInsightsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TenderInsights.
     * @param {TenderInsightsCreateArgs} args - Arguments to create a TenderInsights.
     * @example
     * // Create one TenderInsights
     * const TenderInsights = await prisma.tenderInsights.create({
     *   data: {
     *     // ... data to create a TenderInsights
     *   }
     * })
     * 
     */
    create<T extends TenderInsightsCreateArgs>(args: SelectSubset<T, TenderInsightsCreateArgs<ExtArgs>>): Prisma__TenderInsightsClient<$Result.GetResult<Prisma.$TenderInsightsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TenderInsights.
     * @param {TenderInsightsCreateManyArgs} args - Arguments to create many TenderInsights.
     * @example
     * // Create many TenderInsights
     * const tenderInsights = await prisma.tenderInsights.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenderInsightsCreateManyArgs>(args?: SelectSubset<T, TenderInsightsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenderInsights and returns the data saved in the database.
     * @param {TenderInsightsCreateManyAndReturnArgs} args - Arguments to create many TenderInsights.
     * @example
     * // Create many TenderInsights
     * const tenderInsights = await prisma.tenderInsights.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenderInsights and only return the `tenderId`
     * const tenderInsightsWithTenderIdOnly = await prisma.tenderInsights.createManyAndReturn({ 
     *   select: { tenderId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenderInsightsCreateManyAndReturnArgs>(args?: SelectSubset<T, TenderInsightsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderInsightsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TenderInsights.
     * @param {TenderInsightsDeleteArgs} args - Arguments to delete one TenderInsights.
     * @example
     * // Delete one TenderInsights
     * const TenderInsights = await prisma.tenderInsights.delete({
     *   where: {
     *     // ... filter to delete one TenderInsights
     *   }
     * })
     * 
     */
    delete<T extends TenderInsightsDeleteArgs>(args: SelectSubset<T, TenderInsightsDeleteArgs<ExtArgs>>): Prisma__TenderInsightsClient<$Result.GetResult<Prisma.$TenderInsightsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TenderInsights.
     * @param {TenderInsightsUpdateArgs} args - Arguments to update one TenderInsights.
     * @example
     * // Update one TenderInsights
     * const tenderInsights = await prisma.tenderInsights.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenderInsightsUpdateArgs>(args: SelectSubset<T, TenderInsightsUpdateArgs<ExtArgs>>): Prisma__TenderInsightsClient<$Result.GetResult<Prisma.$TenderInsightsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TenderInsights.
     * @param {TenderInsightsDeleteManyArgs} args - Arguments to filter TenderInsights to delete.
     * @example
     * // Delete a few TenderInsights
     * const { count } = await prisma.tenderInsights.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenderInsightsDeleteManyArgs>(args?: SelectSubset<T, TenderInsightsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenderInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderInsightsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenderInsights
     * const tenderInsights = await prisma.tenderInsights.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenderInsightsUpdateManyArgs>(args: SelectSubset<T, TenderInsightsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TenderInsights.
     * @param {TenderInsightsUpsertArgs} args - Arguments to update or create a TenderInsights.
     * @example
     * // Update or create a TenderInsights
     * const tenderInsights = await prisma.tenderInsights.upsert({
     *   create: {
     *     // ... data to create a TenderInsights
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenderInsights we want to update
     *   }
     * })
     */
    upsert<T extends TenderInsightsUpsertArgs>(args: SelectSubset<T, TenderInsightsUpsertArgs<ExtArgs>>): Prisma__TenderInsightsClient<$Result.GetResult<Prisma.$TenderInsightsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TenderInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderInsightsCountArgs} args - Arguments to filter TenderInsights to count.
     * @example
     * // Count the number of TenderInsights
     * const count = await prisma.tenderInsights.count({
     *   where: {
     *     // ... the filter for the TenderInsights we want to count
     *   }
     * })
    **/
    count<T extends TenderInsightsCountArgs>(
      args?: Subset<T, TenderInsightsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenderInsightsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenderInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderInsightsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenderInsightsAggregateArgs>(args: Subset<T, TenderInsightsAggregateArgs>): Prisma.PrismaPromise<GetTenderInsightsAggregateType<T>>

    /**
     * Group by TenderInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderInsightsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenderInsightsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenderInsightsGroupByArgs['orderBy'] }
        : { orderBy?: TenderInsightsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenderInsightsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenderInsightsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenderInsights model
   */
  readonly fields: TenderInsightsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenderInsights.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenderInsightsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tender<T extends TenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenderDefaultArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenderInsights model
   */ 
  interface TenderInsightsFieldRefs {
    readonly tenderId: FieldRef<"TenderInsights", 'String'>
    readonly payload: FieldRef<"TenderInsights", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * TenderInsights findUnique
   */
  export type TenderInsightsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsInclude<ExtArgs> | null
    /**
     * Filter, which TenderInsights to fetch.
     */
    where: TenderInsightsWhereUniqueInput
  }

  /**
   * TenderInsights findUniqueOrThrow
   */
  export type TenderInsightsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsInclude<ExtArgs> | null
    /**
     * Filter, which TenderInsights to fetch.
     */
    where: TenderInsightsWhereUniqueInput
  }

  /**
   * TenderInsights findFirst
   */
  export type TenderInsightsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsInclude<ExtArgs> | null
    /**
     * Filter, which TenderInsights to fetch.
     */
    where?: TenderInsightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderInsights to fetch.
     */
    orderBy?: TenderInsightsOrderByWithRelationInput | TenderInsightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenderInsights.
     */
    cursor?: TenderInsightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenderInsights.
     */
    distinct?: TenderInsightsScalarFieldEnum | TenderInsightsScalarFieldEnum[]
  }

  /**
   * TenderInsights findFirstOrThrow
   */
  export type TenderInsightsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsInclude<ExtArgs> | null
    /**
     * Filter, which TenderInsights to fetch.
     */
    where?: TenderInsightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderInsights to fetch.
     */
    orderBy?: TenderInsightsOrderByWithRelationInput | TenderInsightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenderInsights.
     */
    cursor?: TenderInsightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenderInsights.
     */
    distinct?: TenderInsightsScalarFieldEnum | TenderInsightsScalarFieldEnum[]
  }

  /**
   * TenderInsights findMany
   */
  export type TenderInsightsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsInclude<ExtArgs> | null
    /**
     * Filter, which TenderInsights to fetch.
     */
    where?: TenderInsightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderInsights to fetch.
     */
    orderBy?: TenderInsightsOrderByWithRelationInput | TenderInsightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenderInsights.
     */
    cursor?: TenderInsightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderInsights.
     */
    skip?: number
    distinct?: TenderInsightsScalarFieldEnum | TenderInsightsScalarFieldEnum[]
  }

  /**
   * TenderInsights create
   */
  export type TenderInsightsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsInclude<ExtArgs> | null
    /**
     * The data needed to create a TenderInsights.
     */
    data: XOR<TenderInsightsCreateInput, TenderInsightsUncheckedCreateInput>
  }

  /**
   * TenderInsights createMany
   */
  export type TenderInsightsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenderInsights.
     */
    data: TenderInsightsCreateManyInput | TenderInsightsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenderInsights createManyAndReturn
   */
  export type TenderInsightsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TenderInsights.
     */
    data: TenderInsightsCreateManyInput | TenderInsightsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenderInsights update
   */
  export type TenderInsightsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsInclude<ExtArgs> | null
    /**
     * The data needed to update a TenderInsights.
     */
    data: XOR<TenderInsightsUpdateInput, TenderInsightsUncheckedUpdateInput>
    /**
     * Choose, which TenderInsights to update.
     */
    where: TenderInsightsWhereUniqueInput
  }

  /**
   * TenderInsights updateMany
   */
  export type TenderInsightsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenderInsights.
     */
    data: XOR<TenderInsightsUpdateManyMutationInput, TenderInsightsUncheckedUpdateManyInput>
    /**
     * Filter which TenderInsights to update
     */
    where?: TenderInsightsWhereInput
  }

  /**
   * TenderInsights upsert
   */
  export type TenderInsightsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsInclude<ExtArgs> | null
    /**
     * The filter to search for the TenderInsights to update in case it exists.
     */
    where: TenderInsightsWhereUniqueInput
    /**
     * In case the TenderInsights found by the `where` argument doesn't exist, create a new TenderInsights with this data.
     */
    create: XOR<TenderInsightsCreateInput, TenderInsightsUncheckedCreateInput>
    /**
     * In case the TenderInsights was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenderInsightsUpdateInput, TenderInsightsUncheckedUpdateInput>
  }

  /**
   * TenderInsights delete
   */
  export type TenderInsightsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsInclude<ExtArgs> | null
    /**
     * Filter which TenderInsights to delete.
     */
    where: TenderInsightsWhereUniqueInput
  }

  /**
   * TenderInsights deleteMany
   */
  export type TenderInsightsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenderInsights to delete
     */
    where?: TenderInsightsWhereInput
  }

  /**
   * TenderInsights without action
   */
  export type TenderInsightsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderInsights
     */
    select?: TenderInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderInsightsInclude<ExtArgs> | null
  }


  /**
   * Model TenderHeatmap
   */

  export type AggregateTenderHeatmap = {
    _count: TenderHeatmapCountAggregateOutputType | null
    _min: TenderHeatmapMinAggregateOutputType | null
    _max: TenderHeatmapMaxAggregateOutputType | null
  }

  export type TenderHeatmapMinAggregateOutputType = {
    tenderId: string | null
  }

  export type TenderHeatmapMaxAggregateOutputType = {
    tenderId: string | null
  }

  export type TenderHeatmapCountAggregateOutputType = {
    tenderId: number
    cells: number
    _all: number
  }


  export type TenderHeatmapMinAggregateInputType = {
    tenderId?: true
  }

  export type TenderHeatmapMaxAggregateInputType = {
    tenderId?: true
  }

  export type TenderHeatmapCountAggregateInputType = {
    tenderId?: true
    cells?: true
    _all?: true
  }

  export type TenderHeatmapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenderHeatmap to aggregate.
     */
    where?: TenderHeatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderHeatmaps to fetch.
     */
    orderBy?: TenderHeatmapOrderByWithRelationInput | TenderHeatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenderHeatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderHeatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderHeatmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenderHeatmaps
    **/
    _count?: true | TenderHeatmapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenderHeatmapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenderHeatmapMaxAggregateInputType
  }

  export type GetTenderHeatmapAggregateType<T extends TenderHeatmapAggregateArgs> = {
        [P in keyof T & keyof AggregateTenderHeatmap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenderHeatmap[P]>
      : GetScalarType<T[P], AggregateTenderHeatmap[P]>
  }




  export type TenderHeatmapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenderHeatmapWhereInput
    orderBy?: TenderHeatmapOrderByWithAggregationInput | TenderHeatmapOrderByWithAggregationInput[]
    by: TenderHeatmapScalarFieldEnum[] | TenderHeatmapScalarFieldEnum
    having?: TenderHeatmapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenderHeatmapCountAggregateInputType | true
    _min?: TenderHeatmapMinAggregateInputType
    _max?: TenderHeatmapMaxAggregateInputType
  }

  export type TenderHeatmapGroupByOutputType = {
    tenderId: string
    cells: JsonValue
    _count: TenderHeatmapCountAggregateOutputType | null
    _min: TenderHeatmapMinAggregateOutputType | null
    _max: TenderHeatmapMaxAggregateOutputType | null
  }

  type GetTenderHeatmapGroupByPayload<T extends TenderHeatmapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenderHeatmapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenderHeatmapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenderHeatmapGroupByOutputType[P]>
            : GetScalarType<T[P], TenderHeatmapGroupByOutputType[P]>
        }
      >
    >


  export type TenderHeatmapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenderId?: boolean
    cells?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenderHeatmap"]>

  export type TenderHeatmapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenderId?: boolean
    cells?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenderHeatmap"]>

  export type TenderHeatmapSelectScalar = {
    tenderId?: boolean
    cells?: boolean
  }

  export type TenderHeatmapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }
  export type TenderHeatmapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }

  export type $TenderHeatmapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenderHeatmap"
    objects: {
      tender: Prisma.$TenderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tenderId: string
      cells: Prisma.JsonValue
    }, ExtArgs["result"]["tenderHeatmap"]>
    composites: {}
  }

  type TenderHeatmapGetPayload<S extends boolean | null | undefined | TenderHeatmapDefaultArgs> = $Result.GetResult<Prisma.$TenderHeatmapPayload, S>

  type TenderHeatmapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenderHeatmapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenderHeatmapCountAggregateInputType | true
    }

  export interface TenderHeatmapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenderHeatmap'], meta: { name: 'TenderHeatmap' } }
    /**
     * Find zero or one TenderHeatmap that matches the filter.
     * @param {TenderHeatmapFindUniqueArgs} args - Arguments to find a TenderHeatmap
     * @example
     * // Get one TenderHeatmap
     * const tenderHeatmap = await prisma.tenderHeatmap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenderHeatmapFindUniqueArgs>(args: SelectSubset<T, TenderHeatmapFindUniqueArgs<ExtArgs>>): Prisma__TenderHeatmapClient<$Result.GetResult<Prisma.$TenderHeatmapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TenderHeatmap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenderHeatmapFindUniqueOrThrowArgs} args - Arguments to find a TenderHeatmap
     * @example
     * // Get one TenderHeatmap
     * const tenderHeatmap = await prisma.tenderHeatmap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenderHeatmapFindUniqueOrThrowArgs>(args: SelectSubset<T, TenderHeatmapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenderHeatmapClient<$Result.GetResult<Prisma.$TenderHeatmapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TenderHeatmap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderHeatmapFindFirstArgs} args - Arguments to find a TenderHeatmap
     * @example
     * // Get one TenderHeatmap
     * const tenderHeatmap = await prisma.tenderHeatmap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenderHeatmapFindFirstArgs>(args?: SelectSubset<T, TenderHeatmapFindFirstArgs<ExtArgs>>): Prisma__TenderHeatmapClient<$Result.GetResult<Prisma.$TenderHeatmapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TenderHeatmap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderHeatmapFindFirstOrThrowArgs} args - Arguments to find a TenderHeatmap
     * @example
     * // Get one TenderHeatmap
     * const tenderHeatmap = await prisma.tenderHeatmap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenderHeatmapFindFirstOrThrowArgs>(args?: SelectSubset<T, TenderHeatmapFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenderHeatmapClient<$Result.GetResult<Prisma.$TenderHeatmapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TenderHeatmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderHeatmapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenderHeatmaps
     * const tenderHeatmaps = await prisma.tenderHeatmap.findMany()
     * 
     * // Get first 10 TenderHeatmaps
     * const tenderHeatmaps = await prisma.tenderHeatmap.findMany({ take: 10 })
     * 
     * // Only select the `tenderId`
     * const tenderHeatmapWithTenderIdOnly = await prisma.tenderHeatmap.findMany({ select: { tenderId: true } })
     * 
     */
    findMany<T extends TenderHeatmapFindManyArgs>(args?: SelectSubset<T, TenderHeatmapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderHeatmapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TenderHeatmap.
     * @param {TenderHeatmapCreateArgs} args - Arguments to create a TenderHeatmap.
     * @example
     * // Create one TenderHeatmap
     * const TenderHeatmap = await prisma.tenderHeatmap.create({
     *   data: {
     *     // ... data to create a TenderHeatmap
     *   }
     * })
     * 
     */
    create<T extends TenderHeatmapCreateArgs>(args: SelectSubset<T, TenderHeatmapCreateArgs<ExtArgs>>): Prisma__TenderHeatmapClient<$Result.GetResult<Prisma.$TenderHeatmapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TenderHeatmaps.
     * @param {TenderHeatmapCreateManyArgs} args - Arguments to create many TenderHeatmaps.
     * @example
     * // Create many TenderHeatmaps
     * const tenderHeatmap = await prisma.tenderHeatmap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenderHeatmapCreateManyArgs>(args?: SelectSubset<T, TenderHeatmapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenderHeatmaps and returns the data saved in the database.
     * @param {TenderHeatmapCreateManyAndReturnArgs} args - Arguments to create many TenderHeatmaps.
     * @example
     * // Create many TenderHeatmaps
     * const tenderHeatmap = await prisma.tenderHeatmap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenderHeatmaps and only return the `tenderId`
     * const tenderHeatmapWithTenderIdOnly = await prisma.tenderHeatmap.createManyAndReturn({ 
     *   select: { tenderId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenderHeatmapCreateManyAndReturnArgs>(args?: SelectSubset<T, TenderHeatmapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderHeatmapPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TenderHeatmap.
     * @param {TenderHeatmapDeleteArgs} args - Arguments to delete one TenderHeatmap.
     * @example
     * // Delete one TenderHeatmap
     * const TenderHeatmap = await prisma.tenderHeatmap.delete({
     *   where: {
     *     // ... filter to delete one TenderHeatmap
     *   }
     * })
     * 
     */
    delete<T extends TenderHeatmapDeleteArgs>(args: SelectSubset<T, TenderHeatmapDeleteArgs<ExtArgs>>): Prisma__TenderHeatmapClient<$Result.GetResult<Prisma.$TenderHeatmapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TenderHeatmap.
     * @param {TenderHeatmapUpdateArgs} args - Arguments to update one TenderHeatmap.
     * @example
     * // Update one TenderHeatmap
     * const tenderHeatmap = await prisma.tenderHeatmap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenderHeatmapUpdateArgs>(args: SelectSubset<T, TenderHeatmapUpdateArgs<ExtArgs>>): Prisma__TenderHeatmapClient<$Result.GetResult<Prisma.$TenderHeatmapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TenderHeatmaps.
     * @param {TenderHeatmapDeleteManyArgs} args - Arguments to filter TenderHeatmaps to delete.
     * @example
     * // Delete a few TenderHeatmaps
     * const { count } = await prisma.tenderHeatmap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenderHeatmapDeleteManyArgs>(args?: SelectSubset<T, TenderHeatmapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenderHeatmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderHeatmapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenderHeatmaps
     * const tenderHeatmap = await prisma.tenderHeatmap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenderHeatmapUpdateManyArgs>(args: SelectSubset<T, TenderHeatmapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TenderHeatmap.
     * @param {TenderHeatmapUpsertArgs} args - Arguments to update or create a TenderHeatmap.
     * @example
     * // Update or create a TenderHeatmap
     * const tenderHeatmap = await prisma.tenderHeatmap.upsert({
     *   create: {
     *     // ... data to create a TenderHeatmap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenderHeatmap we want to update
     *   }
     * })
     */
    upsert<T extends TenderHeatmapUpsertArgs>(args: SelectSubset<T, TenderHeatmapUpsertArgs<ExtArgs>>): Prisma__TenderHeatmapClient<$Result.GetResult<Prisma.$TenderHeatmapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TenderHeatmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderHeatmapCountArgs} args - Arguments to filter TenderHeatmaps to count.
     * @example
     * // Count the number of TenderHeatmaps
     * const count = await prisma.tenderHeatmap.count({
     *   where: {
     *     // ... the filter for the TenderHeatmaps we want to count
     *   }
     * })
    **/
    count<T extends TenderHeatmapCountArgs>(
      args?: Subset<T, TenderHeatmapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenderHeatmapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenderHeatmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderHeatmapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenderHeatmapAggregateArgs>(args: Subset<T, TenderHeatmapAggregateArgs>): Prisma.PrismaPromise<GetTenderHeatmapAggregateType<T>>

    /**
     * Group by TenderHeatmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderHeatmapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenderHeatmapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenderHeatmapGroupByArgs['orderBy'] }
        : { orderBy?: TenderHeatmapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenderHeatmapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenderHeatmapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenderHeatmap model
   */
  readonly fields: TenderHeatmapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenderHeatmap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenderHeatmapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tender<T extends TenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenderDefaultArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenderHeatmap model
   */ 
  interface TenderHeatmapFieldRefs {
    readonly tenderId: FieldRef<"TenderHeatmap", 'String'>
    readonly cells: FieldRef<"TenderHeatmap", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * TenderHeatmap findUnique
   */
  export type TenderHeatmapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapInclude<ExtArgs> | null
    /**
     * Filter, which TenderHeatmap to fetch.
     */
    where: TenderHeatmapWhereUniqueInput
  }

  /**
   * TenderHeatmap findUniqueOrThrow
   */
  export type TenderHeatmapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapInclude<ExtArgs> | null
    /**
     * Filter, which TenderHeatmap to fetch.
     */
    where: TenderHeatmapWhereUniqueInput
  }

  /**
   * TenderHeatmap findFirst
   */
  export type TenderHeatmapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapInclude<ExtArgs> | null
    /**
     * Filter, which TenderHeatmap to fetch.
     */
    where?: TenderHeatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderHeatmaps to fetch.
     */
    orderBy?: TenderHeatmapOrderByWithRelationInput | TenderHeatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenderHeatmaps.
     */
    cursor?: TenderHeatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderHeatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderHeatmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenderHeatmaps.
     */
    distinct?: TenderHeatmapScalarFieldEnum | TenderHeatmapScalarFieldEnum[]
  }

  /**
   * TenderHeatmap findFirstOrThrow
   */
  export type TenderHeatmapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapInclude<ExtArgs> | null
    /**
     * Filter, which TenderHeatmap to fetch.
     */
    where?: TenderHeatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderHeatmaps to fetch.
     */
    orderBy?: TenderHeatmapOrderByWithRelationInput | TenderHeatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenderHeatmaps.
     */
    cursor?: TenderHeatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderHeatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderHeatmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenderHeatmaps.
     */
    distinct?: TenderHeatmapScalarFieldEnum | TenderHeatmapScalarFieldEnum[]
  }

  /**
   * TenderHeatmap findMany
   */
  export type TenderHeatmapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapInclude<ExtArgs> | null
    /**
     * Filter, which TenderHeatmaps to fetch.
     */
    where?: TenderHeatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderHeatmaps to fetch.
     */
    orderBy?: TenderHeatmapOrderByWithRelationInput | TenderHeatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenderHeatmaps.
     */
    cursor?: TenderHeatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderHeatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderHeatmaps.
     */
    skip?: number
    distinct?: TenderHeatmapScalarFieldEnum | TenderHeatmapScalarFieldEnum[]
  }

  /**
   * TenderHeatmap create
   */
  export type TenderHeatmapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapInclude<ExtArgs> | null
    /**
     * The data needed to create a TenderHeatmap.
     */
    data: XOR<TenderHeatmapCreateInput, TenderHeatmapUncheckedCreateInput>
  }

  /**
   * TenderHeatmap createMany
   */
  export type TenderHeatmapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenderHeatmaps.
     */
    data: TenderHeatmapCreateManyInput | TenderHeatmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenderHeatmap createManyAndReturn
   */
  export type TenderHeatmapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TenderHeatmaps.
     */
    data: TenderHeatmapCreateManyInput | TenderHeatmapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenderHeatmap update
   */
  export type TenderHeatmapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapInclude<ExtArgs> | null
    /**
     * The data needed to update a TenderHeatmap.
     */
    data: XOR<TenderHeatmapUpdateInput, TenderHeatmapUncheckedUpdateInput>
    /**
     * Choose, which TenderHeatmap to update.
     */
    where: TenderHeatmapWhereUniqueInput
  }

  /**
   * TenderHeatmap updateMany
   */
  export type TenderHeatmapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenderHeatmaps.
     */
    data: XOR<TenderHeatmapUpdateManyMutationInput, TenderHeatmapUncheckedUpdateManyInput>
    /**
     * Filter which TenderHeatmaps to update
     */
    where?: TenderHeatmapWhereInput
  }

  /**
   * TenderHeatmap upsert
   */
  export type TenderHeatmapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapInclude<ExtArgs> | null
    /**
     * The filter to search for the TenderHeatmap to update in case it exists.
     */
    where: TenderHeatmapWhereUniqueInput
    /**
     * In case the TenderHeatmap found by the `where` argument doesn't exist, create a new TenderHeatmap with this data.
     */
    create: XOR<TenderHeatmapCreateInput, TenderHeatmapUncheckedCreateInput>
    /**
     * In case the TenderHeatmap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenderHeatmapUpdateInput, TenderHeatmapUncheckedUpdateInput>
  }

  /**
   * TenderHeatmap delete
   */
  export type TenderHeatmapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapInclude<ExtArgs> | null
    /**
     * Filter which TenderHeatmap to delete.
     */
    where: TenderHeatmapWhereUniqueInput
  }

  /**
   * TenderHeatmap deleteMany
   */
  export type TenderHeatmapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenderHeatmaps to delete
     */
    where?: TenderHeatmapWhereInput
  }

  /**
   * TenderHeatmap without action
   */
  export type TenderHeatmapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderHeatmap
     */
    select?: TenderHeatmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderHeatmapInclude<ExtArgs> | null
  }


  /**
   * Model BidderIntelligence
   */

  export type AggregateBidderIntelligence = {
    _count: BidderIntelligenceCountAggregateOutputType | null
    _min: BidderIntelligenceMinAggregateOutputType | null
    _max: BidderIntelligenceMaxAggregateOutputType | null
  }

  export type BidderIntelligenceMinAggregateOutputType = {
    bidderId: string | null
  }

  export type BidderIntelligenceMaxAggregateOutputType = {
    bidderId: string | null
  }

  export type BidderIntelligenceCountAggregateOutputType = {
    bidderId: number
    timeline: number
    _all: number
  }


  export type BidderIntelligenceMinAggregateInputType = {
    bidderId?: true
  }

  export type BidderIntelligenceMaxAggregateInputType = {
    bidderId?: true
  }

  export type BidderIntelligenceCountAggregateInputType = {
    bidderId?: true
    timeline?: true
    _all?: true
  }

  export type BidderIntelligenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BidderIntelligence to aggregate.
     */
    where?: BidderIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderIntelligences to fetch.
     */
    orderBy?: BidderIntelligenceOrderByWithRelationInput | BidderIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidderIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderIntelligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BidderIntelligences
    **/
    _count?: true | BidderIntelligenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidderIntelligenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidderIntelligenceMaxAggregateInputType
  }

  export type GetBidderIntelligenceAggregateType<T extends BidderIntelligenceAggregateArgs> = {
        [P in keyof T & keyof AggregateBidderIntelligence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBidderIntelligence[P]>
      : GetScalarType<T[P], AggregateBidderIntelligence[P]>
  }




  export type BidderIntelligenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidderIntelligenceWhereInput
    orderBy?: BidderIntelligenceOrderByWithAggregationInput | BidderIntelligenceOrderByWithAggregationInput[]
    by: BidderIntelligenceScalarFieldEnum[] | BidderIntelligenceScalarFieldEnum
    having?: BidderIntelligenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidderIntelligenceCountAggregateInputType | true
    _min?: BidderIntelligenceMinAggregateInputType
    _max?: BidderIntelligenceMaxAggregateInputType
  }

  export type BidderIntelligenceGroupByOutputType = {
    bidderId: string
    timeline: JsonValue
    _count: BidderIntelligenceCountAggregateOutputType | null
    _min: BidderIntelligenceMinAggregateOutputType | null
    _max: BidderIntelligenceMaxAggregateOutputType | null
  }

  type GetBidderIntelligenceGroupByPayload<T extends BidderIntelligenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BidderIntelligenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidderIntelligenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidderIntelligenceGroupByOutputType[P]>
            : GetScalarType<T[P], BidderIntelligenceGroupByOutputType[P]>
        }
      >
    >


  export type BidderIntelligenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bidderId?: boolean
    timeline?: boolean
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bidderIntelligence"]>

  export type BidderIntelligenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bidderId?: boolean
    timeline?: boolean
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bidderIntelligence"]>

  export type BidderIntelligenceSelectScalar = {
    bidderId?: boolean
    timeline?: boolean
  }

  export type BidderIntelligenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }
  export type BidderIntelligenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }

  export type $BidderIntelligencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BidderIntelligence"
    objects: {
      bidder: Prisma.$BidderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bidderId: string
      timeline: Prisma.JsonValue
    }, ExtArgs["result"]["bidderIntelligence"]>
    composites: {}
  }

  type BidderIntelligenceGetPayload<S extends boolean | null | undefined | BidderIntelligenceDefaultArgs> = $Result.GetResult<Prisma.$BidderIntelligencePayload, S>

  type BidderIntelligenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BidderIntelligenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BidderIntelligenceCountAggregateInputType | true
    }

  export interface BidderIntelligenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BidderIntelligence'], meta: { name: 'BidderIntelligence' } }
    /**
     * Find zero or one BidderIntelligence that matches the filter.
     * @param {BidderIntelligenceFindUniqueArgs} args - Arguments to find a BidderIntelligence
     * @example
     * // Get one BidderIntelligence
     * const bidderIntelligence = await prisma.bidderIntelligence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BidderIntelligenceFindUniqueArgs>(args: SelectSubset<T, BidderIntelligenceFindUniqueArgs<ExtArgs>>): Prisma__BidderIntelligenceClient<$Result.GetResult<Prisma.$BidderIntelligencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BidderIntelligence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BidderIntelligenceFindUniqueOrThrowArgs} args - Arguments to find a BidderIntelligence
     * @example
     * // Get one BidderIntelligence
     * const bidderIntelligence = await prisma.bidderIntelligence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BidderIntelligenceFindUniqueOrThrowArgs>(args: SelectSubset<T, BidderIntelligenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BidderIntelligenceClient<$Result.GetResult<Prisma.$BidderIntelligencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BidderIntelligence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderIntelligenceFindFirstArgs} args - Arguments to find a BidderIntelligence
     * @example
     * // Get one BidderIntelligence
     * const bidderIntelligence = await prisma.bidderIntelligence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BidderIntelligenceFindFirstArgs>(args?: SelectSubset<T, BidderIntelligenceFindFirstArgs<ExtArgs>>): Prisma__BidderIntelligenceClient<$Result.GetResult<Prisma.$BidderIntelligencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BidderIntelligence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderIntelligenceFindFirstOrThrowArgs} args - Arguments to find a BidderIntelligence
     * @example
     * // Get one BidderIntelligence
     * const bidderIntelligence = await prisma.bidderIntelligence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BidderIntelligenceFindFirstOrThrowArgs>(args?: SelectSubset<T, BidderIntelligenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BidderIntelligenceClient<$Result.GetResult<Prisma.$BidderIntelligencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BidderIntelligences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderIntelligenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BidderIntelligences
     * const bidderIntelligences = await prisma.bidderIntelligence.findMany()
     * 
     * // Get first 10 BidderIntelligences
     * const bidderIntelligences = await prisma.bidderIntelligence.findMany({ take: 10 })
     * 
     * // Only select the `bidderId`
     * const bidderIntelligenceWithBidderIdOnly = await prisma.bidderIntelligence.findMany({ select: { bidderId: true } })
     * 
     */
    findMany<T extends BidderIntelligenceFindManyArgs>(args?: SelectSubset<T, BidderIntelligenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidderIntelligencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BidderIntelligence.
     * @param {BidderIntelligenceCreateArgs} args - Arguments to create a BidderIntelligence.
     * @example
     * // Create one BidderIntelligence
     * const BidderIntelligence = await prisma.bidderIntelligence.create({
     *   data: {
     *     // ... data to create a BidderIntelligence
     *   }
     * })
     * 
     */
    create<T extends BidderIntelligenceCreateArgs>(args: SelectSubset<T, BidderIntelligenceCreateArgs<ExtArgs>>): Prisma__BidderIntelligenceClient<$Result.GetResult<Prisma.$BidderIntelligencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BidderIntelligences.
     * @param {BidderIntelligenceCreateManyArgs} args - Arguments to create many BidderIntelligences.
     * @example
     * // Create many BidderIntelligences
     * const bidderIntelligence = await prisma.bidderIntelligence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BidderIntelligenceCreateManyArgs>(args?: SelectSubset<T, BidderIntelligenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BidderIntelligences and returns the data saved in the database.
     * @param {BidderIntelligenceCreateManyAndReturnArgs} args - Arguments to create many BidderIntelligences.
     * @example
     * // Create many BidderIntelligences
     * const bidderIntelligence = await prisma.bidderIntelligence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BidderIntelligences and only return the `bidderId`
     * const bidderIntelligenceWithBidderIdOnly = await prisma.bidderIntelligence.createManyAndReturn({ 
     *   select: { bidderId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BidderIntelligenceCreateManyAndReturnArgs>(args?: SelectSubset<T, BidderIntelligenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidderIntelligencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BidderIntelligence.
     * @param {BidderIntelligenceDeleteArgs} args - Arguments to delete one BidderIntelligence.
     * @example
     * // Delete one BidderIntelligence
     * const BidderIntelligence = await prisma.bidderIntelligence.delete({
     *   where: {
     *     // ... filter to delete one BidderIntelligence
     *   }
     * })
     * 
     */
    delete<T extends BidderIntelligenceDeleteArgs>(args: SelectSubset<T, BidderIntelligenceDeleteArgs<ExtArgs>>): Prisma__BidderIntelligenceClient<$Result.GetResult<Prisma.$BidderIntelligencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BidderIntelligence.
     * @param {BidderIntelligenceUpdateArgs} args - Arguments to update one BidderIntelligence.
     * @example
     * // Update one BidderIntelligence
     * const bidderIntelligence = await prisma.bidderIntelligence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BidderIntelligenceUpdateArgs>(args: SelectSubset<T, BidderIntelligenceUpdateArgs<ExtArgs>>): Prisma__BidderIntelligenceClient<$Result.GetResult<Prisma.$BidderIntelligencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BidderIntelligences.
     * @param {BidderIntelligenceDeleteManyArgs} args - Arguments to filter BidderIntelligences to delete.
     * @example
     * // Delete a few BidderIntelligences
     * const { count } = await prisma.bidderIntelligence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BidderIntelligenceDeleteManyArgs>(args?: SelectSubset<T, BidderIntelligenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BidderIntelligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderIntelligenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BidderIntelligences
     * const bidderIntelligence = await prisma.bidderIntelligence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BidderIntelligenceUpdateManyArgs>(args: SelectSubset<T, BidderIntelligenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BidderIntelligence.
     * @param {BidderIntelligenceUpsertArgs} args - Arguments to update or create a BidderIntelligence.
     * @example
     * // Update or create a BidderIntelligence
     * const bidderIntelligence = await prisma.bidderIntelligence.upsert({
     *   create: {
     *     // ... data to create a BidderIntelligence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BidderIntelligence we want to update
     *   }
     * })
     */
    upsert<T extends BidderIntelligenceUpsertArgs>(args: SelectSubset<T, BidderIntelligenceUpsertArgs<ExtArgs>>): Prisma__BidderIntelligenceClient<$Result.GetResult<Prisma.$BidderIntelligencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BidderIntelligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderIntelligenceCountArgs} args - Arguments to filter BidderIntelligences to count.
     * @example
     * // Count the number of BidderIntelligences
     * const count = await prisma.bidderIntelligence.count({
     *   where: {
     *     // ... the filter for the BidderIntelligences we want to count
     *   }
     * })
    **/
    count<T extends BidderIntelligenceCountArgs>(
      args?: Subset<T, BidderIntelligenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidderIntelligenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BidderIntelligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderIntelligenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidderIntelligenceAggregateArgs>(args: Subset<T, BidderIntelligenceAggregateArgs>): Prisma.PrismaPromise<GetBidderIntelligenceAggregateType<T>>

    /**
     * Group by BidderIntelligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderIntelligenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidderIntelligenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidderIntelligenceGroupByArgs['orderBy'] }
        : { orderBy?: BidderIntelligenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidderIntelligenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidderIntelligenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BidderIntelligence model
   */
  readonly fields: BidderIntelligenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BidderIntelligence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BidderIntelligenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bidder<T extends BidderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BidderDefaultArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BidderIntelligence model
   */ 
  interface BidderIntelligenceFieldRefs {
    readonly bidderId: FieldRef<"BidderIntelligence", 'String'>
    readonly timeline: FieldRef<"BidderIntelligence", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * BidderIntelligence findUnique
   */
  export type BidderIntelligenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceInclude<ExtArgs> | null
    /**
     * Filter, which BidderIntelligence to fetch.
     */
    where: BidderIntelligenceWhereUniqueInput
  }

  /**
   * BidderIntelligence findUniqueOrThrow
   */
  export type BidderIntelligenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceInclude<ExtArgs> | null
    /**
     * Filter, which BidderIntelligence to fetch.
     */
    where: BidderIntelligenceWhereUniqueInput
  }

  /**
   * BidderIntelligence findFirst
   */
  export type BidderIntelligenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceInclude<ExtArgs> | null
    /**
     * Filter, which BidderIntelligence to fetch.
     */
    where?: BidderIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderIntelligences to fetch.
     */
    orderBy?: BidderIntelligenceOrderByWithRelationInput | BidderIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidderIntelligences.
     */
    cursor?: BidderIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderIntelligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidderIntelligences.
     */
    distinct?: BidderIntelligenceScalarFieldEnum | BidderIntelligenceScalarFieldEnum[]
  }

  /**
   * BidderIntelligence findFirstOrThrow
   */
  export type BidderIntelligenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceInclude<ExtArgs> | null
    /**
     * Filter, which BidderIntelligence to fetch.
     */
    where?: BidderIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderIntelligences to fetch.
     */
    orderBy?: BidderIntelligenceOrderByWithRelationInput | BidderIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidderIntelligences.
     */
    cursor?: BidderIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderIntelligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidderIntelligences.
     */
    distinct?: BidderIntelligenceScalarFieldEnum | BidderIntelligenceScalarFieldEnum[]
  }

  /**
   * BidderIntelligence findMany
   */
  export type BidderIntelligenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceInclude<ExtArgs> | null
    /**
     * Filter, which BidderIntelligences to fetch.
     */
    where?: BidderIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderIntelligences to fetch.
     */
    orderBy?: BidderIntelligenceOrderByWithRelationInput | BidderIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BidderIntelligences.
     */
    cursor?: BidderIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderIntelligences.
     */
    skip?: number
    distinct?: BidderIntelligenceScalarFieldEnum | BidderIntelligenceScalarFieldEnum[]
  }

  /**
   * BidderIntelligence create
   */
  export type BidderIntelligenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceInclude<ExtArgs> | null
    /**
     * The data needed to create a BidderIntelligence.
     */
    data: XOR<BidderIntelligenceCreateInput, BidderIntelligenceUncheckedCreateInput>
  }

  /**
   * BidderIntelligence createMany
   */
  export type BidderIntelligenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BidderIntelligences.
     */
    data: BidderIntelligenceCreateManyInput | BidderIntelligenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BidderIntelligence createManyAndReturn
   */
  export type BidderIntelligenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BidderIntelligences.
     */
    data: BidderIntelligenceCreateManyInput | BidderIntelligenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BidderIntelligence update
   */
  export type BidderIntelligenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceInclude<ExtArgs> | null
    /**
     * The data needed to update a BidderIntelligence.
     */
    data: XOR<BidderIntelligenceUpdateInput, BidderIntelligenceUncheckedUpdateInput>
    /**
     * Choose, which BidderIntelligence to update.
     */
    where: BidderIntelligenceWhereUniqueInput
  }

  /**
   * BidderIntelligence updateMany
   */
  export type BidderIntelligenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BidderIntelligences.
     */
    data: XOR<BidderIntelligenceUpdateManyMutationInput, BidderIntelligenceUncheckedUpdateManyInput>
    /**
     * Filter which BidderIntelligences to update
     */
    where?: BidderIntelligenceWhereInput
  }

  /**
   * BidderIntelligence upsert
   */
  export type BidderIntelligenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceInclude<ExtArgs> | null
    /**
     * The filter to search for the BidderIntelligence to update in case it exists.
     */
    where: BidderIntelligenceWhereUniqueInput
    /**
     * In case the BidderIntelligence found by the `where` argument doesn't exist, create a new BidderIntelligence with this data.
     */
    create: XOR<BidderIntelligenceCreateInput, BidderIntelligenceUncheckedCreateInput>
    /**
     * In case the BidderIntelligence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidderIntelligenceUpdateInput, BidderIntelligenceUncheckedUpdateInput>
  }

  /**
   * BidderIntelligence delete
   */
  export type BidderIntelligenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceInclude<ExtArgs> | null
    /**
     * Filter which BidderIntelligence to delete.
     */
    where: BidderIntelligenceWhereUniqueInput
  }

  /**
   * BidderIntelligence deleteMany
   */
  export type BidderIntelligenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BidderIntelligences to delete
     */
    where?: BidderIntelligenceWhereInput
  }

  /**
   * BidderIntelligence without action
   */
  export type BidderIntelligenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderIntelligence
     */
    select?: BidderIntelligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderIntelligenceInclude<ExtArgs> | null
  }


  /**
   * Model BidderRiskProfile
   */

  export type AggregateBidderRiskProfile = {
    _count: BidderRiskProfileCountAggregateOutputType | null
    _min: BidderRiskProfileMinAggregateOutputType | null
    _max: BidderRiskProfileMaxAggregateOutputType | null
  }

  export type BidderRiskProfileMinAggregateOutputType = {
    bidderId: string | null
  }

  export type BidderRiskProfileMaxAggregateOutputType = {
    bidderId: string | null
  }

  export type BidderRiskProfileCountAggregateOutputType = {
    bidderId: number
    profile: number
    _all: number
  }


  export type BidderRiskProfileMinAggregateInputType = {
    bidderId?: true
  }

  export type BidderRiskProfileMaxAggregateInputType = {
    bidderId?: true
  }

  export type BidderRiskProfileCountAggregateInputType = {
    bidderId?: true
    profile?: true
    _all?: true
  }

  export type BidderRiskProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BidderRiskProfile to aggregate.
     */
    where?: BidderRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderRiskProfiles to fetch.
     */
    orderBy?: BidderRiskProfileOrderByWithRelationInput | BidderRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidderRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderRiskProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BidderRiskProfiles
    **/
    _count?: true | BidderRiskProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidderRiskProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidderRiskProfileMaxAggregateInputType
  }

  export type GetBidderRiskProfileAggregateType<T extends BidderRiskProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateBidderRiskProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBidderRiskProfile[P]>
      : GetScalarType<T[P], AggregateBidderRiskProfile[P]>
  }




  export type BidderRiskProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidderRiskProfileWhereInput
    orderBy?: BidderRiskProfileOrderByWithAggregationInput | BidderRiskProfileOrderByWithAggregationInput[]
    by: BidderRiskProfileScalarFieldEnum[] | BidderRiskProfileScalarFieldEnum
    having?: BidderRiskProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidderRiskProfileCountAggregateInputType | true
    _min?: BidderRiskProfileMinAggregateInputType
    _max?: BidderRiskProfileMaxAggregateInputType
  }

  export type BidderRiskProfileGroupByOutputType = {
    bidderId: string
    profile: JsonValue
    _count: BidderRiskProfileCountAggregateOutputType | null
    _min: BidderRiskProfileMinAggregateOutputType | null
    _max: BidderRiskProfileMaxAggregateOutputType | null
  }

  type GetBidderRiskProfileGroupByPayload<T extends BidderRiskProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BidderRiskProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidderRiskProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidderRiskProfileGroupByOutputType[P]>
            : GetScalarType<T[P], BidderRiskProfileGroupByOutputType[P]>
        }
      >
    >


  export type BidderRiskProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bidderId?: boolean
    profile?: boolean
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bidderRiskProfile"]>

  export type BidderRiskProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bidderId?: boolean
    profile?: boolean
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bidderRiskProfile"]>

  export type BidderRiskProfileSelectScalar = {
    bidderId?: boolean
    profile?: boolean
  }

  export type BidderRiskProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }
  export type BidderRiskProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | BidderDefaultArgs<ExtArgs>
  }

  export type $BidderRiskProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BidderRiskProfile"
    objects: {
      bidder: Prisma.$BidderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bidderId: string
      profile: Prisma.JsonValue
    }, ExtArgs["result"]["bidderRiskProfile"]>
    composites: {}
  }

  type BidderRiskProfileGetPayload<S extends boolean | null | undefined | BidderRiskProfileDefaultArgs> = $Result.GetResult<Prisma.$BidderRiskProfilePayload, S>

  type BidderRiskProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BidderRiskProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BidderRiskProfileCountAggregateInputType | true
    }

  export interface BidderRiskProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BidderRiskProfile'], meta: { name: 'BidderRiskProfile' } }
    /**
     * Find zero or one BidderRiskProfile that matches the filter.
     * @param {BidderRiskProfileFindUniqueArgs} args - Arguments to find a BidderRiskProfile
     * @example
     * // Get one BidderRiskProfile
     * const bidderRiskProfile = await prisma.bidderRiskProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BidderRiskProfileFindUniqueArgs>(args: SelectSubset<T, BidderRiskProfileFindUniqueArgs<ExtArgs>>): Prisma__BidderRiskProfileClient<$Result.GetResult<Prisma.$BidderRiskProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BidderRiskProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BidderRiskProfileFindUniqueOrThrowArgs} args - Arguments to find a BidderRiskProfile
     * @example
     * // Get one BidderRiskProfile
     * const bidderRiskProfile = await prisma.bidderRiskProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BidderRiskProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, BidderRiskProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BidderRiskProfileClient<$Result.GetResult<Prisma.$BidderRiskProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BidderRiskProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderRiskProfileFindFirstArgs} args - Arguments to find a BidderRiskProfile
     * @example
     * // Get one BidderRiskProfile
     * const bidderRiskProfile = await prisma.bidderRiskProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BidderRiskProfileFindFirstArgs>(args?: SelectSubset<T, BidderRiskProfileFindFirstArgs<ExtArgs>>): Prisma__BidderRiskProfileClient<$Result.GetResult<Prisma.$BidderRiskProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BidderRiskProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderRiskProfileFindFirstOrThrowArgs} args - Arguments to find a BidderRiskProfile
     * @example
     * // Get one BidderRiskProfile
     * const bidderRiskProfile = await prisma.bidderRiskProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BidderRiskProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, BidderRiskProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__BidderRiskProfileClient<$Result.GetResult<Prisma.$BidderRiskProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BidderRiskProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderRiskProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BidderRiskProfiles
     * const bidderRiskProfiles = await prisma.bidderRiskProfile.findMany()
     * 
     * // Get first 10 BidderRiskProfiles
     * const bidderRiskProfiles = await prisma.bidderRiskProfile.findMany({ take: 10 })
     * 
     * // Only select the `bidderId`
     * const bidderRiskProfileWithBidderIdOnly = await prisma.bidderRiskProfile.findMany({ select: { bidderId: true } })
     * 
     */
    findMany<T extends BidderRiskProfileFindManyArgs>(args?: SelectSubset<T, BidderRiskProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidderRiskProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BidderRiskProfile.
     * @param {BidderRiskProfileCreateArgs} args - Arguments to create a BidderRiskProfile.
     * @example
     * // Create one BidderRiskProfile
     * const BidderRiskProfile = await prisma.bidderRiskProfile.create({
     *   data: {
     *     // ... data to create a BidderRiskProfile
     *   }
     * })
     * 
     */
    create<T extends BidderRiskProfileCreateArgs>(args: SelectSubset<T, BidderRiskProfileCreateArgs<ExtArgs>>): Prisma__BidderRiskProfileClient<$Result.GetResult<Prisma.$BidderRiskProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BidderRiskProfiles.
     * @param {BidderRiskProfileCreateManyArgs} args - Arguments to create many BidderRiskProfiles.
     * @example
     * // Create many BidderRiskProfiles
     * const bidderRiskProfile = await prisma.bidderRiskProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BidderRiskProfileCreateManyArgs>(args?: SelectSubset<T, BidderRiskProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BidderRiskProfiles and returns the data saved in the database.
     * @param {BidderRiskProfileCreateManyAndReturnArgs} args - Arguments to create many BidderRiskProfiles.
     * @example
     * // Create many BidderRiskProfiles
     * const bidderRiskProfile = await prisma.bidderRiskProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BidderRiskProfiles and only return the `bidderId`
     * const bidderRiskProfileWithBidderIdOnly = await prisma.bidderRiskProfile.createManyAndReturn({ 
     *   select: { bidderId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BidderRiskProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, BidderRiskProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidderRiskProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BidderRiskProfile.
     * @param {BidderRiskProfileDeleteArgs} args - Arguments to delete one BidderRiskProfile.
     * @example
     * // Delete one BidderRiskProfile
     * const BidderRiskProfile = await prisma.bidderRiskProfile.delete({
     *   where: {
     *     // ... filter to delete one BidderRiskProfile
     *   }
     * })
     * 
     */
    delete<T extends BidderRiskProfileDeleteArgs>(args: SelectSubset<T, BidderRiskProfileDeleteArgs<ExtArgs>>): Prisma__BidderRiskProfileClient<$Result.GetResult<Prisma.$BidderRiskProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BidderRiskProfile.
     * @param {BidderRiskProfileUpdateArgs} args - Arguments to update one BidderRiskProfile.
     * @example
     * // Update one BidderRiskProfile
     * const bidderRiskProfile = await prisma.bidderRiskProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BidderRiskProfileUpdateArgs>(args: SelectSubset<T, BidderRiskProfileUpdateArgs<ExtArgs>>): Prisma__BidderRiskProfileClient<$Result.GetResult<Prisma.$BidderRiskProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BidderRiskProfiles.
     * @param {BidderRiskProfileDeleteManyArgs} args - Arguments to filter BidderRiskProfiles to delete.
     * @example
     * // Delete a few BidderRiskProfiles
     * const { count } = await prisma.bidderRiskProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BidderRiskProfileDeleteManyArgs>(args?: SelectSubset<T, BidderRiskProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BidderRiskProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderRiskProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BidderRiskProfiles
     * const bidderRiskProfile = await prisma.bidderRiskProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BidderRiskProfileUpdateManyArgs>(args: SelectSubset<T, BidderRiskProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BidderRiskProfile.
     * @param {BidderRiskProfileUpsertArgs} args - Arguments to update or create a BidderRiskProfile.
     * @example
     * // Update or create a BidderRiskProfile
     * const bidderRiskProfile = await prisma.bidderRiskProfile.upsert({
     *   create: {
     *     // ... data to create a BidderRiskProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BidderRiskProfile we want to update
     *   }
     * })
     */
    upsert<T extends BidderRiskProfileUpsertArgs>(args: SelectSubset<T, BidderRiskProfileUpsertArgs<ExtArgs>>): Prisma__BidderRiskProfileClient<$Result.GetResult<Prisma.$BidderRiskProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BidderRiskProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderRiskProfileCountArgs} args - Arguments to filter BidderRiskProfiles to count.
     * @example
     * // Count the number of BidderRiskProfiles
     * const count = await prisma.bidderRiskProfile.count({
     *   where: {
     *     // ... the filter for the BidderRiskProfiles we want to count
     *   }
     * })
    **/
    count<T extends BidderRiskProfileCountArgs>(
      args?: Subset<T, BidderRiskProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidderRiskProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BidderRiskProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderRiskProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidderRiskProfileAggregateArgs>(args: Subset<T, BidderRiskProfileAggregateArgs>): Prisma.PrismaPromise<GetBidderRiskProfileAggregateType<T>>

    /**
     * Group by BidderRiskProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidderRiskProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidderRiskProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidderRiskProfileGroupByArgs['orderBy'] }
        : { orderBy?: BidderRiskProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidderRiskProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidderRiskProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BidderRiskProfile model
   */
  readonly fields: BidderRiskProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BidderRiskProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BidderRiskProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bidder<T extends BidderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BidderDefaultArgs<ExtArgs>>): Prisma__BidderClient<$Result.GetResult<Prisma.$BidderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BidderRiskProfile model
   */ 
  interface BidderRiskProfileFieldRefs {
    readonly bidderId: FieldRef<"BidderRiskProfile", 'String'>
    readonly profile: FieldRef<"BidderRiskProfile", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * BidderRiskProfile findUnique
   */
  export type BidderRiskProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which BidderRiskProfile to fetch.
     */
    where: BidderRiskProfileWhereUniqueInput
  }

  /**
   * BidderRiskProfile findUniqueOrThrow
   */
  export type BidderRiskProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which BidderRiskProfile to fetch.
     */
    where: BidderRiskProfileWhereUniqueInput
  }

  /**
   * BidderRiskProfile findFirst
   */
  export type BidderRiskProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which BidderRiskProfile to fetch.
     */
    where?: BidderRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderRiskProfiles to fetch.
     */
    orderBy?: BidderRiskProfileOrderByWithRelationInput | BidderRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidderRiskProfiles.
     */
    cursor?: BidderRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderRiskProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidderRiskProfiles.
     */
    distinct?: BidderRiskProfileScalarFieldEnum | BidderRiskProfileScalarFieldEnum[]
  }

  /**
   * BidderRiskProfile findFirstOrThrow
   */
  export type BidderRiskProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which BidderRiskProfile to fetch.
     */
    where?: BidderRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderRiskProfiles to fetch.
     */
    orderBy?: BidderRiskProfileOrderByWithRelationInput | BidderRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidderRiskProfiles.
     */
    cursor?: BidderRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderRiskProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidderRiskProfiles.
     */
    distinct?: BidderRiskProfileScalarFieldEnum | BidderRiskProfileScalarFieldEnum[]
  }

  /**
   * BidderRiskProfile findMany
   */
  export type BidderRiskProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileInclude<ExtArgs> | null
    /**
     * Filter, which BidderRiskProfiles to fetch.
     */
    where?: BidderRiskProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidderRiskProfiles to fetch.
     */
    orderBy?: BidderRiskProfileOrderByWithRelationInput | BidderRiskProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BidderRiskProfiles.
     */
    cursor?: BidderRiskProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidderRiskProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidderRiskProfiles.
     */
    skip?: number
    distinct?: BidderRiskProfileScalarFieldEnum | BidderRiskProfileScalarFieldEnum[]
  }

  /**
   * BidderRiskProfile create
   */
  export type BidderRiskProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a BidderRiskProfile.
     */
    data: XOR<BidderRiskProfileCreateInput, BidderRiskProfileUncheckedCreateInput>
  }

  /**
   * BidderRiskProfile createMany
   */
  export type BidderRiskProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BidderRiskProfiles.
     */
    data: BidderRiskProfileCreateManyInput | BidderRiskProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BidderRiskProfile createManyAndReturn
   */
  export type BidderRiskProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BidderRiskProfiles.
     */
    data: BidderRiskProfileCreateManyInput | BidderRiskProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BidderRiskProfile update
   */
  export type BidderRiskProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a BidderRiskProfile.
     */
    data: XOR<BidderRiskProfileUpdateInput, BidderRiskProfileUncheckedUpdateInput>
    /**
     * Choose, which BidderRiskProfile to update.
     */
    where: BidderRiskProfileWhereUniqueInput
  }

  /**
   * BidderRiskProfile updateMany
   */
  export type BidderRiskProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BidderRiskProfiles.
     */
    data: XOR<BidderRiskProfileUpdateManyMutationInput, BidderRiskProfileUncheckedUpdateManyInput>
    /**
     * Filter which BidderRiskProfiles to update
     */
    where?: BidderRiskProfileWhereInput
  }

  /**
   * BidderRiskProfile upsert
   */
  export type BidderRiskProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the BidderRiskProfile to update in case it exists.
     */
    where: BidderRiskProfileWhereUniqueInput
    /**
     * In case the BidderRiskProfile found by the `where` argument doesn't exist, create a new BidderRiskProfile with this data.
     */
    create: XOR<BidderRiskProfileCreateInput, BidderRiskProfileUncheckedCreateInput>
    /**
     * In case the BidderRiskProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidderRiskProfileUpdateInput, BidderRiskProfileUncheckedUpdateInput>
  }

  /**
   * BidderRiskProfile delete
   */
  export type BidderRiskProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileInclude<ExtArgs> | null
    /**
     * Filter which BidderRiskProfile to delete.
     */
    where: BidderRiskProfileWhereUniqueInput
  }

  /**
   * BidderRiskProfile deleteMany
   */
  export type BidderRiskProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BidderRiskProfiles to delete
     */
    where?: BidderRiskProfileWhereInput
  }

  /**
   * BidderRiskProfile without action
   */
  export type BidderRiskProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidderRiskProfile
     */
    select?: BidderRiskProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidderRiskProfileInclude<ExtArgs> | null
  }


  /**
   * Model TenderComplianceDashboard
   */

  export type AggregateTenderComplianceDashboard = {
    _count: TenderComplianceDashboardCountAggregateOutputType | null
    _min: TenderComplianceDashboardMinAggregateOutputType | null
    _max: TenderComplianceDashboardMaxAggregateOutputType | null
  }

  export type TenderComplianceDashboardMinAggregateOutputType = {
    tenderId: string | null
  }

  export type TenderComplianceDashboardMaxAggregateOutputType = {
    tenderId: string | null
  }

  export type TenderComplianceDashboardCountAggregateOutputType = {
    tenderId: number
    payload: number
    _all: number
  }


  export type TenderComplianceDashboardMinAggregateInputType = {
    tenderId?: true
  }

  export type TenderComplianceDashboardMaxAggregateInputType = {
    tenderId?: true
  }

  export type TenderComplianceDashboardCountAggregateInputType = {
    tenderId?: true
    payload?: true
    _all?: true
  }

  export type TenderComplianceDashboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenderComplianceDashboard to aggregate.
     */
    where?: TenderComplianceDashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderComplianceDashboards to fetch.
     */
    orderBy?: TenderComplianceDashboardOrderByWithRelationInput | TenderComplianceDashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenderComplianceDashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderComplianceDashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderComplianceDashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenderComplianceDashboards
    **/
    _count?: true | TenderComplianceDashboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenderComplianceDashboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenderComplianceDashboardMaxAggregateInputType
  }

  export type GetTenderComplianceDashboardAggregateType<T extends TenderComplianceDashboardAggregateArgs> = {
        [P in keyof T & keyof AggregateTenderComplianceDashboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenderComplianceDashboard[P]>
      : GetScalarType<T[P], AggregateTenderComplianceDashboard[P]>
  }




  export type TenderComplianceDashboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenderComplianceDashboardWhereInput
    orderBy?: TenderComplianceDashboardOrderByWithAggregationInput | TenderComplianceDashboardOrderByWithAggregationInput[]
    by: TenderComplianceDashboardScalarFieldEnum[] | TenderComplianceDashboardScalarFieldEnum
    having?: TenderComplianceDashboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenderComplianceDashboardCountAggregateInputType | true
    _min?: TenderComplianceDashboardMinAggregateInputType
    _max?: TenderComplianceDashboardMaxAggregateInputType
  }

  export type TenderComplianceDashboardGroupByOutputType = {
    tenderId: string
    payload: JsonValue
    _count: TenderComplianceDashboardCountAggregateOutputType | null
    _min: TenderComplianceDashboardMinAggregateOutputType | null
    _max: TenderComplianceDashboardMaxAggregateOutputType | null
  }

  type GetTenderComplianceDashboardGroupByPayload<T extends TenderComplianceDashboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenderComplianceDashboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenderComplianceDashboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenderComplianceDashboardGroupByOutputType[P]>
            : GetScalarType<T[P], TenderComplianceDashboardGroupByOutputType[P]>
        }
      >
    >


  export type TenderComplianceDashboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenderId?: boolean
    payload?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenderComplianceDashboard"]>

  export type TenderComplianceDashboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tenderId?: boolean
    payload?: boolean
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenderComplianceDashboard"]>

  export type TenderComplianceDashboardSelectScalar = {
    tenderId?: boolean
    payload?: boolean
  }

  export type TenderComplianceDashboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }
  export type TenderComplianceDashboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tender?: boolean | TenderDefaultArgs<ExtArgs>
  }

  export type $TenderComplianceDashboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenderComplianceDashboard"
    objects: {
      tender: Prisma.$TenderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tenderId: string
      payload: Prisma.JsonValue
    }, ExtArgs["result"]["tenderComplianceDashboard"]>
    composites: {}
  }

  type TenderComplianceDashboardGetPayload<S extends boolean | null | undefined | TenderComplianceDashboardDefaultArgs> = $Result.GetResult<Prisma.$TenderComplianceDashboardPayload, S>

  type TenderComplianceDashboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenderComplianceDashboardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenderComplianceDashboardCountAggregateInputType | true
    }

  export interface TenderComplianceDashboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenderComplianceDashboard'], meta: { name: 'TenderComplianceDashboard' } }
    /**
     * Find zero or one TenderComplianceDashboard that matches the filter.
     * @param {TenderComplianceDashboardFindUniqueArgs} args - Arguments to find a TenderComplianceDashboard
     * @example
     * // Get one TenderComplianceDashboard
     * const tenderComplianceDashboard = await prisma.tenderComplianceDashboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenderComplianceDashboardFindUniqueArgs>(args: SelectSubset<T, TenderComplianceDashboardFindUniqueArgs<ExtArgs>>): Prisma__TenderComplianceDashboardClient<$Result.GetResult<Prisma.$TenderComplianceDashboardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TenderComplianceDashboard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenderComplianceDashboardFindUniqueOrThrowArgs} args - Arguments to find a TenderComplianceDashboard
     * @example
     * // Get one TenderComplianceDashboard
     * const tenderComplianceDashboard = await prisma.tenderComplianceDashboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenderComplianceDashboardFindUniqueOrThrowArgs>(args: SelectSubset<T, TenderComplianceDashboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenderComplianceDashboardClient<$Result.GetResult<Prisma.$TenderComplianceDashboardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TenderComplianceDashboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderComplianceDashboardFindFirstArgs} args - Arguments to find a TenderComplianceDashboard
     * @example
     * // Get one TenderComplianceDashboard
     * const tenderComplianceDashboard = await prisma.tenderComplianceDashboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenderComplianceDashboardFindFirstArgs>(args?: SelectSubset<T, TenderComplianceDashboardFindFirstArgs<ExtArgs>>): Prisma__TenderComplianceDashboardClient<$Result.GetResult<Prisma.$TenderComplianceDashboardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TenderComplianceDashboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderComplianceDashboardFindFirstOrThrowArgs} args - Arguments to find a TenderComplianceDashboard
     * @example
     * // Get one TenderComplianceDashboard
     * const tenderComplianceDashboard = await prisma.tenderComplianceDashboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenderComplianceDashboardFindFirstOrThrowArgs>(args?: SelectSubset<T, TenderComplianceDashboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenderComplianceDashboardClient<$Result.GetResult<Prisma.$TenderComplianceDashboardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TenderComplianceDashboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderComplianceDashboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenderComplianceDashboards
     * const tenderComplianceDashboards = await prisma.tenderComplianceDashboard.findMany()
     * 
     * // Get first 10 TenderComplianceDashboards
     * const tenderComplianceDashboards = await prisma.tenderComplianceDashboard.findMany({ take: 10 })
     * 
     * // Only select the `tenderId`
     * const tenderComplianceDashboardWithTenderIdOnly = await prisma.tenderComplianceDashboard.findMany({ select: { tenderId: true } })
     * 
     */
    findMany<T extends TenderComplianceDashboardFindManyArgs>(args?: SelectSubset<T, TenderComplianceDashboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderComplianceDashboardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TenderComplianceDashboard.
     * @param {TenderComplianceDashboardCreateArgs} args - Arguments to create a TenderComplianceDashboard.
     * @example
     * // Create one TenderComplianceDashboard
     * const TenderComplianceDashboard = await prisma.tenderComplianceDashboard.create({
     *   data: {
     *     // ... data to create a TenderComplianceDashboard
     *   }
     * })
     * 
     */
    create<T extends TenderComplianceDashboardCreateArgs>(args: SelectSubset<T, TenderComplianceDashboardCreateArgs<ExtArgs>>): Prisma__TenderComplianceDashboardClient<$Result.GetResult<Prisma.$TenderComplianceDashboardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TenderComplianceDashboards.
     * @param {TenderComplianceDashboardCreateManyArgs} args - Arguments to create many TenderComplianceDashboards.
     * @example
     * // Create many TenderComplianceDashboards
     * const tenderComplianceDashboard = await prisma.tenderComplianceDashboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenderComplianceDashboardCreateManyArgs>(args?: SelectSubset<T, TenderComplianceDashboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenderComplianceDashboards and returns the data saved in the database.
     * @param {TenderComplianceDashboardCreateManyAndReturnArgs} args - Arguments to create many TenderComplianceDashboards.
     * @example
     * // Create many TenderComplianceDashboards
     * const tenderComplianceDashboard = await prisma.tenderComplianceDashboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenderComplianceDashboards and only return the `tenderId`
     * const tenderComplianceDashboardWithTenderIdOnly = await prisma.tenderComplianceDashboard.createManyAndReturn({ 
     *   select: { tenderId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenderComplianceDashboardCreateManyAndReturnArgs>(args?: SelectSubset<T, TenderComplianceDashboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenderComplianceDashboardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TenderComplianceDashboard.
     * @param {TenderComplianceDashboardDeleteArgs} args - Arguments to delete one TenderComplianceDashboard.
     * @example
     * // Delete one TenderComplianceDashboard
     * const TenderComplianceDashboard = await prisma.tenderComplianceDashboard.delete({
     *   where: {
     *     // ... filter to delete one TenderComplianceDashboard
     *   }
     * })
     * 
     */
    delete<T extends TenderComplianceDashboardDeleteArgs>(args: SelectSubset<T, TenderComplianceDashboardDeleteArgs<ExtArgs>>): Prisma__TenderComplianceDashboardClient<$Result.GetResult<Prisma.$TenderComplianceDashboardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TenderComplianceDashboard.
     * @param {TenderComplianceDashboardUpdateArgs} args - Arguments to update one TenderComplianceDashboard.
     * @example
     * // Update one TenderComplianceDashboard
     * const tenderComplianceDashboard = await prisma.tenderComplianceDashboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenderComplianceDashboardUpdateArgs>(args: SelectSubset<T, TenderComplianceDashboardUpdateArgs<ExtArgs>>): Prisma__TenderComplianceDashboardClient<$Result.GetResult<Prisma.$TenderComplianceDashboardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TenderComplianceDashboards.
     * @param {TenderComplianceDashboardDeleteManyArgs} args - Arguments to filter TenderComplianceDashboards to delete.
     * @example
     * // Delete a few TenderComplianceDashboards
     * const { count } = await prisma.tenderComplianceDashboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenderComplianceDashboardDeleteManyArgs>(args?: SelectSubset<T, TenderComplianceDashboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenderComplianceDashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderComplianceDashboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenderComplianceDashboards
     * const tenderComplianceDashboard = await prisma.tenderComplianceDashboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenderComplianceDashboardUpdateManyArgs>(args: SelectSubset<T, TenderComplianceDashboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TenderComplianceDashboard.
     * @param {TenderComplianceDashboardUpsertArgs} args - Arguments to update or create a TenderComplianceDashboard.
     * @example
     * // Update or create a TenderComplianceDashboard
     * const tenderComplianceDashboard = await prisma.tenderComplianceDashboard.upsert({
     *   create: {
     *     // ... data to create a TenderComplianceDashboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenderComplianceDashboard we want to update
     *   }
     * })
     */
    upsert<T extends TenderComplianceDashboardUpsertArgs>(args: SelectSubset<T, TenderComplianceDashboardUpsertArgs<ExtArgs>>): Prisma__TenderComplianceDashboardClient<$Result.GetResult<Prisma.$TenderComplianceDashboardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TenderComplianceDashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderComplianceDashboardCountArgs} args - Arguments to filter TenderComplianceDashboards to count.
     * @example
     * // Count the number of TenderComplianceDashboards
     * const count = await prisma.tenderComplianceDashboard.count({
     *   where: {
     *     // ... the filter for the TenderComplianceDashboards we want to count
     *   }
     * })
    **/
    count<T extends TenderComplianceDashboardCountArgs>(
      args?: Subset<T, TenderComplianceDashboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenderComplianceDashboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenderComplianceDashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderComplianceDashboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenderComplianceDashboardAggregateArgs>(args: Subset<T, TenderComplianceDashboardAggregateArgs>): Prisma.PrismaPromise<GetTenderComplianceDashboardAggregateType<T>>

    /**
     * Group by TenderComplianceDashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenderComplianceDashboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenderComplianceDashboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenderComplianceDashboardGroupByArgs['orderBy'] }
        : { orderBy?: TenderComplianceDashboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenderComplianceDashboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenderComplianceDashboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenderComplianceDashboard model
   */
  readonly fields: TenderComplianceDashboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenderComplianceDashboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenderComplianceDashboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tender<T extends TenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenderDefaultArgs<ExtArgs>>): Prisma__TenderClient<$Result.GetResult<Prisma.$TenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenderComplianceDashboard model
   */ 
  interface TenderComplianceDashboardFieldRefs {
    readonly tenderId: FieldRef<"TenderComplianceDashboard", 'String'>
    readonly payload: FieldRef<"TenderComplianceDashboard", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * TenderComplianceDashboard findUnique
   */
  export type TenderComplianceDashboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardInclude<ExtArgs> | null
    /**
     * Filter, which TenderComplianceDashboard to fetch.
     */
    where: TenderComplianceDashboardWhereUniqueInput
  }

  /**
   * TenderComplianceDashboard findUniqueOrThrow
   */
  export type TenderComplianceDashboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardInclude<ExtArgs> | null
    /**
     * Filter, which TenderComplianceDashboard to fetch.
     */
    where: TenderComplianceDashboardWhereUniqueInput
  }

  /**
   * TenderComplianceDashboard findFirst
   */
  export type TenderComplianceDashboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardInclude<ExtArgs> | null
    /**
     * Filter, which TenderComplianceDashboard to fetch.
     */
    where?: TenderComplianceDashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderComplianceDashboards to fetch.
     */
    orderBy?: TenderComplianceDashboardOrderByWithRelationInput | TenderComplianceDashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenderComplianceDashboards.
     */
    cursor?: TenderComplianceDashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderComplianceDashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderComplianceDashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenderComplianceDashboards.
     */
    distinct?: TenderComplianceDashboardScalarFieldEnum | TenderComplianceDashboardScalarFieldEnum[]
  }

  /**
   * TenderComplianceDashboard findFirstOrThrow
   */
  export type TenderComplianceDashboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardInclude<ExtArgs> | null
    /**
     * Filter, which TenderComplianceDashboard to fetch.
     */
    where?: TenderComplianceDashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderComplianceDashboards to fetch.
     */
    orderBy?: TenderComplianceDashboardOrderByWithRelationInput | TenderComplianceDashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenderComplianceDashboards.
     */
    cursor?: TenderComplianceDashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderComplianceDashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderComplianceDashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenderComplianceDashboards.
     */
    distinct?: TenderComplianceDashboardScalarFieldEnum | TenderComplianceDashboardScalarFieldEnum[]
  }

  /**
   * TenderComplianceDashboard findMany
   */
  export type TenderComplianceDashboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardInclude<ExtArgs> | null
    /**
     * Filter, which TenderComplianceDashboards to fetch.
     */
    where?: TenderComplianceDashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenderComplianceDashboards to fetch.
     */
    orderBy?: TenderComplianceDashboardOrderByWithRelationInput | TenderComplianceDashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenderComplianceDashboards.
     */
    cursor?: TenderComplianceDashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenderComplianceDashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenderComplianceDashboards.
     */
    skip?: number
    distinct?: TenderComplianceDashboardScalarFieldEnum | TenderComplianceDashboardScalarFieldEnum[]
  }

  /**
   * TenderComplianceDashboard create
   */
  export type TenderComplianceDashboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardInclude<ExtArgs> | null
    /**
     * The data needed to create a TenderComplianceDashboard.
     */
    data: XOR<TenderComplianceDashboardCreateInput, TenderComplianceDashboardUncheckedCreateInput>
  }

  /**
   * TenderComplianceDashboard createMany
   */
  export type TenderComplianceDashboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenderComplianceDashboards.
     */
    data: TenderComplianceDashboardCreateManyInput | TenderComplianceDashboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenderComplianceDashboard createManyAndReturn
   */
  export type TenderComplianceDashboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TenderComplianceDashboards.
     */
    data: TenderComplianceDashboardCreateManyInput | TenderComplianceDashboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenderComplianceDashboard update
   */
  export type TenderComplianceDashboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardInclude<ExtArgs> | null
    /**
     * The data needed to update a TenderComplianceDashboard.
     */
    data: XOR<TenderComplianceDashboardUpdateInput, TenderComplianceDashboardUncheckedUpdateInput>
    /**
     * Choose, which TenderComplianceDashboard to update.
     */
    where: TenderComplianceDashboardWhereUniqueInput
  }

  /**
   * TenderComplianceDashboard updateMany
   */
  export type TenderComplianceDashboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenderComplianceDashboards.
     */
    data: XOR<TenderComplianceDashboardUpdateManyMutationInput, TenderComplianceDashboardUncheckedUpdateManyInput>
    /**
     * Filter which TenderComplianceDashboards to update
     */
    where?: TenderComplianceDashboardWhereInput
  }

  /**
   * TenderComplianceDashboard upsert
   */
  export type TenderComplianceDashboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardInclude<ExtArgs> | null
    /**
     * The filter to search for the TenderComplianceDashboard to update in case it exists.
     */
    where: TenderComplianceDashboardWhereUniqueInput
    /**
     * In case the TenderComplianceDashboard found by the `where` argument doesn't exist, create a new TenderComplianceDashboard with this data.
     */
    create: XOR<TenderComplianceDashboardCreateInput, TenderComplianceDashboardUncheckedCreateInput>
    /**
     * In case the TenderComplianceDashboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenderComplianceDashboardUpdateInput, TenderComplianceDashboardUncheckedUpdateInput>
  }

  /**
   * TenderComplianceDashboard delete
   */
  export type TenderComplianceDashboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardInclude<ExtArgs> | null
    /**
     * Filter which TenderComplianceDashboard to delete.
     */
    where: TenderComplianceDashboardWhereUniqueInput
  }

  /**
   * TenderComplianceDashboard deleteMany
   */
  export type TenderComplianceDashboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenderComplianceDashboards to delete
     */
    where?: TenderComplianceDashboardWhereInput
  }

  /**
   * TenderComplianceDashboard without action
   */
  export type TenderComplianceDashboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenderComplianceDashboard
     */
    select?: TenderComplianceDashboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenderComplianceDashboardInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const TenantBrandingScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    logoUrl: 'logoUrl',
    publicName: 'publicName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantBrandingScalarFieldEnum = (typeof TenantBrandingScalarFieldEnum)[keyof typeof TenantBrandingScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    password: 'password',
    tenantId: 'tenantId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ScmTenderAssignmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenderId: 'tenderId',
    createdAt: 'createdAt'
  };

  export type ScmTenderAssignmentScalarFieldEnum = (typeof ScmTenderAssignmentScalarFieldEnum)[keyof typeof ScmTenderAssignmentScalarFieldEnum]


  export const TenderScalarFieldEnum: {
    id: 'id',
    number: 'number',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tenantId: 'tenantId'
  };

  export type TenderScalarFieldEnum = (typeof TenderScalarFieldEnum)[keyof typeof TenderScalarFieldEnum]


  export const BidderScalarFieldEnum: {
    id: 'id',
    tenderId: 'tenderId',
    name: 'name',
    price: 'price',
    disqualified: 'disqualified',
    disqualificationReason: 'disqualificationReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BidderScalarFieldEnum = (typeof BidderScalarFieldEnum)[keyof typeof BidderScalarFieldEnum]


  export const BbbeeScalarFieldEnum: {
    id: 'id',
    bidderId: 'bidderId',
    level: 'level',
    expiry: 'expiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BbbeeScalarFieldEnum = (typeof BbbeeScalarFieldEnum)[keyof typeof BbbeeScalarFieldEnum]


  export const EvidenceScalarFieldEnum: {
    id: 'id',
    bidderId: 'bidderId',
    type: 'type',
    metadata: 'metadata',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvidenceScalarFieldEnum = (typeof EvidenceScalarFieldEnum)[keyof typeof EvidenceScalarFieldEnum]


  export const EvaluationConfigScalarFieldEnum: {
    id: 'id',
    tenderId: 'tenderId',
    priceWeight: 'priceWeight',
    bbbeeWeight: 'bbbeeWeight',
    functionalityPass: 'functionalityPass',
    functionalityMax: 'functionalityMax',
    criteria: 'criteria',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvaluationConfigScalarFieldEnum = (typeof EvaluationConfigScalarFieldEnum)[keyof typeof EvaluationConfigScalarFieldEnum]


  export const BidderCriterionScoreScalarFieldEnum: {
    id: 'id',
    bidderId: 'bidderId',
    criterionCode: 'criterionCode',
    rawScore: 'rawScore',
    scaleMax: 'scaleMax',
    weight: 'weight',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BidderCriterionScoreScalarFieldEnum = (typeof BidderCriterionScoreScalarFieldEnum)[keyof typeof BidderCriterionScoreScalarFieldEnum]


  export const EvaluationResultScalarFieldEnum: {
    id: 'id',
    tenderId: 'tenderId',
    bidderId: 'bidderId',
    functionalityScore: 'functionalityScore',
    qualifies: 'qualifies',
    price: 'price',
    priceScore: 'priceScore',
    bbbeeLevel: 'bbbeeLevel',
    bbbeePoints: 'bbbeePoints',
    totalScore: 'totalScore',
    riskScore: 'riskScore',
    complianceRate: 'complianceRate',
    exceptionsCount: 'exceptionsCount',
    slaBreached: 'slaBreached',
    currentStage: 'currentStage',
    createdAt: 'createdAt',
    hash: 'hash'
  };

  export type EvaluationResultScalarFieldEnum = (typeof EvaluationResultScalarFieldEnum)[keyof typeof EvaluationResultScalarFieldEnum]


  export const WorkflowLogScalarFieldEnum: {
    id: 'id',
    evaluationResultId: 'evaluationResultId',
    stage: 'stage',
    daysSpent: 'daysSpent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowLogScalarFieldEnum = (typeof WorkflowLogScalarFieldEnum)[keyof typeof WorkflowLogScalarFieldEnum]


  export const CircularScalarFieldEnum: {
    id: 'id',
    label: 'label',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CircularScalarFieldEnum = (typeof CircularScalarFieldEnum)[keyof typeof CircularScalarFieldEnum]


  export const ComplianceRuleScalarFieldEnum: {
    id: 'id',
    circularId: 'circularId',
    code: 'code',
    label: 'label',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplianceRuleScalarFieldEnum = (typeof ComplianceRuleScalarFieldEnum)[keyof typeof ComplianceRuleScalarFieldEnum]


  export const ComplianceItemScalarFieldEnum: {
    id: 'id',
    evaluationResultId: 'evaluationResultId',
    ruleId: 'ruleId',
    compliant: 'compliant',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplianceItemScalarFieldEnum = (typeof ComplianceItemScalarFieldEnum)[keyof typeof ComplianceItemScalarFieldEnum]


  export const EvaluationExceptionScalarFieldEnum: {
    id: 'id',
    evaluationResultId: 'evaluationResultId',
    type: 'type',
    reason: 'reason',
    approved: 'approved',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvaluationExceptionScalarFieldEnum = (typeof EvaluationExceptionScalarFieldEnum)[keyof typeof EvaluationExceptionScalarFieldEnum]


  export const EvaluationSignatureScalarFieldEnum: {
    id: 'id',
    tenderId: 'tenderId',
    role: 'role',
    name: 'name',
    signature: 'signature',
    comment: 'comment',
    signedAt: 'signedAt'
  };

  export type EvaluationSignatureScalarFieldEnum = (typeof EvaluationSignatureScalarFieldEnum)[keyof typeof EvaluationSignatureScalarFieldEnum]


  export const EvaluationDocumentScalarFieldEnum: {
    id: 'id',
    tenderId: 'tenderId',
    runNumber: 'runNumber',
    fileUrl: 'fileUrl',
    hash: 'hash',
    createdAt: 'createdAt'
  };

  export type EvaluationDocumentScalarFieldEnum = (typeof EvaluationDocumentScalarFieldEnum)[keyof typeof EvaluationDocumentScalarFieldEnum]


  export const AnalyticsAccessLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    role: 'role',
    endpoint: 'endpoint',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AnalyticsAccessLogScalarFieldEnum = (typeof AnalyticsAccessLogScalarFieldEnum)[keyof typeof AnalyticsAccessLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationRuleScalarFieldEnum: {
    id: 'id',
    trigger: 'trigger',
    role: 'role',
    enabled: 'enabled',
    ownerId: 'ownerId'
  };

  export type NotificationRuleScalarFieldEnum = (typeof NotificationRuleScalarFieldEnum)[keyof typeof NotificationRuleScalarFieldEnum]


  export const TenderTimelineEventScalarFieldEnum: {
    id: 'id',
    tenderId: 'tenderId',
    type: 'type',
    label: 'label',
    createdAt: 'createdAt'
  };

  export type TenderTimelineEventScalarFieldEnum = (typeof TenderTimelineEventScalarFieldEnum)[keyof typeof TenderTimelineEventScalarFieldEnum]


  export const TenderInsightsScalarFieldEnum: {
    tenderId: 'tenderId',
    payload: 'payload'
  };

  export type TenderInsightsScalarFieldEnum = (typeof TenderInsightsScalarFieldEnum)[keyof typeof TenderInsightsScalarFieldEnum]


  export const TenderHeatmapScalarFieldEnum: {
    tenderId: 'tenderId',
    cells: 'cells'
  };

  export type TenderHeatmapScalarFieldEnum = (typeof TenderHeatmapScalarFieldEnum)[keyof typeof TenderHeatmapScalarFieldEnum]


  export const BidderIntelligenceScalarFieldEnum: {
    bidderId: 'bidderId',
    timeline: 'timeline'
  };

  export type BidderIntelligenceScalarFieldEnum = (typeof BidderIntelligenceScalarFieldEnum)[keyof typeof BidderIntelligenceScalarFieldEnum]


  export const BidderRiskProfileScalarFieldEnum: {
    bidderId: 'bidderId',
    profile: 'profile'
  };

  export type BidderRiskProfileScalarFieldEnum = (typeof BidderRiskProfileScalarFieldEnum)[keyof typeof BidderRiskProfileScalarFieldEnum]


  export const TenderComplianceDashboardScalarFieldEnum: {
    tenderId: 'tenderId',
    payload: 'payload'
  };

  export type TenderComplianceDashboardScalarFieldEnum = (typeof TenderComplianceDashboardScalarFieldEnum)[keyof typeof TenderComplianceDashboardScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    code?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    active?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    branding?: XOR<TenantBrandingNullableRelationFilter, TenantBrandingWhereInput> | null
    tenders?: TenderListRelationFilter
    users?: UserListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branding?: TenantBrandingOrderByWithRelationInput
    tenders?: TenderOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    active?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    branding?: XOR<TenantBrandingNullableRelationFilter, TenantBrandingWhereInput> | null
    tenders?: TenderListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "code">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    code?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    active?: BoolWithAggregatesFilter<"Tenant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type TenantBrandingWhereInput = {
    AND?: TenantBrandingWhereInput | TenantBrandingWhereInput[]
    OR?: TenantBrandingWhereInput[]
    NOT?: TenantBrandingWhereInput | TenantBrandingWhereInput[]
    id?: StringFilter<"TenantBranding"> | string
    tenantId?: StringFilter<"TenantBranding"> | string
    primaryColor?: StringNullableFilter<"TenantBranding"> | string | null
    secondaryColor?: StringNullableFilter<"TenantBranding"> | string | null
    logoUrl?: StringNullableFilter<"TenantBranding"> | string | null
    publicName?: StringNullableFilter<"TenantBranding"> | string | null
    createdAt?: DateTimeFilter<"TenantBranding"> | Date | string
    updatedAt?: DateTimeFilter<"TenantBranding"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type TenantBrandingOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    publicName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantBrandingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: TenantBrandingWhereInput | TenantBrandingWhereInput[]
    OR?: TenantBrandingWhereInput[]
    NOT?: TenantBrandingWhereInput | TenantBrandingWhereInput[]
    primaryColor?: StringNullableFilter<"TenantBranding"> | string | null
    secondaryColor?: StringNullableFilter<"TenantBranding"> | string | null
    logoUrl?: StringNullableFilter<"TenantBranding"> | string | null
    publicName?: StringNullableFilter<"TenantBranding"> | string | null
    createdAt?: DateTimeFilter<"TenantBranding"> | Date | string
    updatedAt?: DateTimeFilter<"TenantBranding"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type TenantBrandingOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    publicName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantBrandingCountOrderByAggregateInput
    _max?: TenantBrandingMaxOrderByAggregateInput
    _min?: TenantBrandingMinOrderByAggregateInput
  }

  export type TenantBrandingScalarWhereWithAggregatesInput = {
    AND?: TenantBrandingScalarWhereWithAggregatesInput | TenantBrandingScalarWhereWithAggregatesInput[]
    OR?: TenantBrandingScalarWhereWithAggregatesInput[]
    NOT?: TenantBrandingScalarWhereWithAggregatesInput | TenantBrandingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantBranding"> | string
    tenantId?: StringWithAggregatesFilter<"TenantBranding"> | string
    primaryColor?: StringNullableWithAggregatesFilter<"TenantBranding"> | string | null
    secondaryColor?: StringNullableWithAggregatesFilter<"TenantBranding"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"TenantBranding"> | string | null
    publicName?: StringNullableWithAggregatesFilter<"TenantBranding"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantBranding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantBranding"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    analyticsLogs?: AnalyticsAccessLogListRelationFilter
    scmAssignments?: ScmTenderAssignmentListRelationFilter
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    notifications?: NotificationListRelationFilter
    notificationRules?: NotificationRuleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    analyticsLogs?: AnalyticsAccessLogOrderByRelationAggregateInput
    scmAssignments?: ScmTenderAssignmentOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    notificationRules?: NotificationRuleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    analyticsLogs?: AnalyticsAccessLogListRelationFilter
    scmAssignments?: ScmTenderAssignmentListRelationFilter
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    notifications?: NotificationListRelationFilter
    notificationRules?: NotificationRuleListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    password?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ScmTenderAssignmentWhereInput = {
    AND?: ScmTenderAssignmentWhereInput | ScmTenderAssignmentWhereInput[]
    OR?: ScmTenderAssignmentWhereInput[]
    NOT?: ScmTenderAssignmentWhereInput | ScmTenderAssignmentWhereInput[]
    id?: StringFilter<"ScmTenderAssignment"> | string
    userId?: StringFilter<"ScmTenderAssignment"> | string
    tenderId?: StringFilter<"ScmTenderAssignment"> | string
    createdAt?: DateTimeFilter<"ScmTenderAssignment"> | Date | string
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ScmTenderAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenderId?: SortOrder
    createdAt?: SortOrder
    tender?: TenderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ScmTenderAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tenderId?: ScmTenderAssignmentUserIdTenderIdCompoundUniqueInput
    AND?: ScmTenderAssignmentWhereInput | ScmTenderAssignmentWhereInput[]
    OR?: ScmTenderAssignmentWhereInput[]
    NOT?: ScmTenderAssignmentWhereInput | ScmTenderAssignmentWhereInput[]
    userId?: StringFilter<"ScmTenderAssignment"> | string
    tenderId?: StringFilter<"ScmTenderAssignment"> | string
    createdAt?: DateTimeFilter<"ScmTenderAssignment"> | Date | string
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_tenderId">

  export type ScmTenderAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenderId?: SortOrder
    createdAt?: SortOrder
    _count?: ScmTenderAssignmentCountOrderByAggregateInput
    _max?: ScmTenderAssignmentMaxOrderByAggregateInput
    _min?: ScmTenderAssignmentMinOrderByAggregateInput
  }

  export type ScmTenderAssignmentScalarWhereWithAggregatesInput = {
    AND?: ScmTenderAssignmentScalarWhereWithAggregatesInput | ScmTenderAssignmentScalarWhereWithAggregatesInput[]
    OR?: ScmTenderAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ScmTenderAssignmentScalarWhereWithAggregatesInput | ScmTenderAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScmTenderAssignment"> | string
    userId?: StringWithAggregatesFilter<"ScmTenderAssignment"> | string
    tenderId?: StringWithAggregatesFilter<"ScmTenderAssignment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ScmTenderAssignment"> | Date | string
  }

  export type TenderWhereInput = {
    AND?: TenderWhereInput | TenderWhereInput[]
    OR?: TenderWhereInput[]
    NOT?: TenderWhereInput | TenderWhereInput[]
    id?: StringFilter<"Tender"> | string
    number?: StringFilter<"Tender"> | string
    description?: StringFilter<"Tender"> | string
    category?: StringNullableFilter<"Tender"> | string | null
    createdAt?: DateTimeFilter<"Tender"> | Date | string
    updatedAt?: DateTimeFilter<"Tender"> | Date | string
    tenantId?: StringNullableFilter<"Tender"> | string | null
    bidders?: BidderListRelationFilter
    evaluationConfig?: XOR<EvaluationConfigNullableRelationFilter, EvaluationConfigWhereInput> | null
    documents?: EvaluationDocumentListRelationFilter
    evaluationResults?: EvaluationResultListRelationFilter
    signatures?: EvaluationSignatureListRelationFilter
    scmAssignments?: ScmTenderAssignmentListRelationFilter
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    timelineEvents?: TenderTimelineEventListRelationFilter
    insights?: XOR<TenderInsightsNullableRelationFilter, TenderInsightsWhereInput> | null
    heatmap?: XOR<TenderHeatmapNullableRelationFilter, TenderHeatmapWhereInput> | null
    complianceDashboard?: XOR<TenderComplianceDashboardNullableRelationFilter, TenderComplianceDashboardWhereInput> | null
  }

  export type TenderOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    description?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    bidders?: BidderOrderByRelationAggregateInput
    evaluationConfig?: EvaluationConfigOrderByWithRelationInput
    documents?: EvaluationDocumentOrderByRelationAggregateInput
    evaluationResults?: EvaluationResultOrderByRelationAggregateInput
    signatures?: EvaluationSignatureOrderByRelationAggregateInput
    scmAssignments?: ScmTenderAssignmentOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    timelineEvents?: TenderTimelineEventOrderByRelationAggregateInput
    insights?: TenderInsightsOrderByWithRelationInput
    heatmap?: TenderHeatmapOrderByWithRelationInput
    complianceDashboard?: TenderComplianceDashboardOrderByWithRelationInput
  }

  export type TenderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenderWhereInput | TenderWhereInput[]
    OR?: TenderWhereInput[]
    NOT?: TenderWhereInput | TenderWhereInput[]
    number?: StringFilter<"Tender"> | string
    description?: StringFilter<"Tender"> | string
    category?: StringNullableFilter<"Tender"> | string | null
    createdAt?: DateTimeFilter<"Tender"> | Date | string
    updatedAt?: DateTimeFilter<"Tender"> | Date | string
    tenantId?: StringNullableFilter<"Tender"> | string | null
    bidders?: BidderListRelationFilter
    evaluationConfig?: XOR<EvaluationConfigNullableRelationFilter, EvaluationConfigWhereInput> | null
    documents?: EvaluationDocumentListRelationFilter
    evaluationResults?: EvaluationResultListRelationFilter
    signatures?: EvaluationSignatureListRelationFilter
    scmAssignments?: ScmTenderAssignmentListRelationFilter
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    timelineEvents?: TenderTimelineEventListRelationFilter
    insights?: XOR<TenderInsightsNullableRelationFilter, TenderInsightsWhereInput> | null
    heatmap?: XOR<TenderHeatmapNullableRelationFilter, TenderHeatmapWhereInput> | null
    complianceDashboard?: XOR<TenderComplianceDashboardNullableRelationFilter, TenderComplianceDashboardWhereInput> | null
  }, "id">

  export type TenderOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    description?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    _count?: TenderCountOrderByAggregateInput
    _max?: TenderMaxOrderByAggregateInput
    _min?: TenderMinOrderByAggregateInput
  }

  export type TenderScalarWhereWithAggregatesInput = {
    AND?: TenderScalarWhereWithAggregatesInput | TenderScalarWhereWithAggregatesInput[]
    OR?: TenderScalarWhereWithAggregatesInput[]
    NOT?: TenderScalarWhereWithAggregatesInput | TenderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tender"> | string
    number?: StringWithAggregatesFilter<"Tender"> | string
    description?: StringWithAggregatesFilter<"Tender"> | string
    category?: StringNullableWithAggregatesFilter<"Tender"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tender"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tender"> | Date | string
    tenantId?: StringNullableWithAggregatesFilter<"Tender"> | string | null
  }

  export type BidderWhereInput = {
    AND?: BidderWhereInput | BidderWhereInput[]
    OR?: BidderWhereInput[]
    NOT?: BidderWhereInput | BidderWhereInput[]
    id?: StringFilter<"Bidder"> | string
    tenderId?: StringFilter<"Bidder"> | string
    name?: StringFilter<"Bidder"> | string
    price?: FloatNullableFilter<"Bidder"> | number | null
    disqualified?: BoolFilter<"Bidder"> | boolean
    disqualificationReason?: StringNullableFilter<"Bidder"> | string | null
    createdAt?: DateTimeFilter<"Bidder"> | Date | string
    updatedAt?: DateTimeFilter<"Bidder"> | Date | string
    bbbee?: XOR<BbbeeNullableRelationFilter, BbbeeWhereInput> | null
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
    technicalScores?: BidderCriterionScoreListRelationFilter
    evaluationResults?: EvaluationResultListRelationFilter
    evidence?: EvidenceListRelationFilter
    intelligence?: XOR<BidderIntelligenceNullableRelationFilter, BidderIntelligenceWhereInput> | null
    riskProfile?: XOR<BidderRiskProfileNullableRelationFilter, BidderRiskProfileWhereInput> | null
  }

  export type BidderOrderByWithRelationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    disqualified?: SortOrder
    disqualificationReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bbbee?: BbbeeOrderByWithRelationInput
    tender?: TenderOrderByWithRelationInput
    technicalScores?: BidderCriterionScoreOrderByRelationAggregateInput
    evaluationResults?: EvaluationResultOrderByRelationAggregateInput
    evidence?: EvidenceOrderByRelationAggregateInput
    intelligence?: BidderIntelligenceOrderByWithRelationInput
    riskProfile?: BidderRiskProfileOrderByWithRelationInput
  }

  export type BidderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BidderWhereInput | BidderWhereInput[]
    OR?: BidderWhereInput[]
    NOT?: BidderWhereInput | BidderWhereInput[]
    tenderId?: StringFilter<"Bidder"> | string
    name?: StringFilter<"Bidder"> | string
    price?: FloatNullableFilter<"Bidder"> | number | null
    disqualified?: BoolFilter<"Bidder"> | boolean
    disqualificationReason?: StringNullableFilter<"Bidder"> | string | null
    createdAt?: DateTimeFilter<"Bidder"> | Date | string
    updatedAt?: DateTimeFilter<"Bidder"> | Date | string
    bbbee?: XOR<BbbeeNullableRelationFilter, BbbeeWhereInput> | null
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
    technicalScores?: BidderCriterionScoreListRelationFilter
    evaluationResults?: EvaluationResultListRelationFilter
    evidence?: EvidenceListRelationFilter
    intelligence?: XOR<BidderIntelligenceNullableRelationFilter, BidderIntelligenceWhereInput> | null
    riskProfile?: XOR<BidderRiskProfileNullableRelationFilter, BidderRiskProfileWhereInput> | null
  }, "id">

  export type BidderOrderByWithAggregationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    disqualified?: SortOrder
    disqualificationReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BidderCountOrderByAggregateInput
    _avg?: BidderAvgOrderByAggregateInput
    _max?: BidderMaxOrderByAggregateInput
    _min?: BidderMinOrderByAggregateInput
    _sum?: BidderSumOrderByAggregateInput
  }

  export type BidderScalarWhereWithAggregatesInput = {
    AND?: BidderScalarWhereWithAggregatesInput | BidderScalarWhereWithAggregatesInput[]
    OR?: BidderScalarWhereWithAggregatesInput[]
    NOT?: BidderScalarWhereWithAggregatesInput | BidderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bidder"> | string
    tenderId?: StringWithAggregatesFilter<"Bidder"> | string
    name?: StringWithAggregatesFilter<"Bidder"> | string
    price?: FloatNullableWithAggregatesFilter<"Bidder"> | number | null
    disqualified?: BoolWithAggregatesFilter<"Bidder"> | boolean
    disqualificationReason?: StringNullableWithAggregatesFilter<"Bidder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Bidder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bidder"> | Date | string
  }

  export type BbbeeWhereInput = {
    AND?: BbbeeWhereInput | BbbeeWhereInput[]
    OR?: BbbeeWhereInput[]
    NOT?: BbbeeWhereInput | BbbeeWhereInput[]
    id?: StringFilter<"Bbbee"> | string
    bidderId?: StringFilter<"Bbbee"> | string
    level?: IntNullableFilter<"Bbbee"> | number | null
    expiry?: DateTimeNullableFilter<"Bbbee"> | Date | string | null
    createdAt?: DateTimeFilter<"Bbbee"> | Date | string
    updatedAt?: DateTimeFilter<"Bbbee"> | Date | string
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
  }

  export type BbbeeOrderByWithRelationInput = {
    id?: SortOrder
    bidderId?: SortOrder
    level?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bidder?: BidderOrderByWithRelationInput
  }

  export type BbbeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bidderId?: string
    AND?: BbbeeWhereInput | BbbeeWhereInput[]
    OR?: BbbeeWhereInput[]
    NOT?: BbbeeWhereInput | BbbeeWhereInput[]
    level?: IntNullableFilter<"Bbbee"> | number | null
    expiry?: DateTimeNullableFilter<"Bbbee"> | Date | string | null
    createdAt?: DateTimeFilter<"Bbbee"> | Date | string
    updatedAt?: DateTimeFilter<"Bbbee"> | Date | string
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
  }, "id" | "bidderId">

  export type BbbeeOrderByWithAggregationInput = {
    id?: SortOrder
    bidderId?: SortOrder
    level?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BbbeeCountOrderByAggregateInput
    _avg?: BbbeeAvgOrderByAggregateInput
    _max?: BbbeeMaxOrderByAggregateInput
    _min?: BbbeeMinOrderByAggregateInput
    _sum?: BbbeeSumOrderByAggregateInput
  }

  export type BbbeeScalarWhereWithAggregatesInput = {
    AND?: BbbeeScalarWhereWithAggregatesInput | BbbeeScalarWhereWithAggregatesInput[]
    OR?: BbbeeScalarWhereWithAggregatesInput[]
    NOT?: BbbeeScalarWhereWithAggregatesInput | BbbeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bbbee"> | string
    bidderId?: StringWithAggregatesFilter<"Bbbee"> | string
    level?: IntNullableWithAggregatesFilter<"Bbbee"> | number | null
    expiry?: DateTimeNullableWithAggregatesFilter<"Bbbee"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Bbbee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bbbee"> | Date | string
  }

  export type EvidenceWhereInput = {
    AND?: EvidenceWhereInput | EvidenceWhereInput[]
    OR?: EvidenceWhereInput[]
    NOT?: EvidenceWhereInput | EvidenceWhereInput[]
    id?: StringFilter<"Evidence"> | string
    bidderId?: StringFilter<"Evidence"> | string
    type?: StringFilter<"Evidence"> | string
    metadata?: JsonNullableFilter<"Evidence">
    url?: StringNullableFilter<"Evidence"> | string | null
    createdAt?: DateTimeFilter<"Evidence"> | Date | string
    updatedAt?: DateTimeFilter<"Evidence"> | Date | string
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
  }

  export type EvidenceOrderByWithRelationInput = {
    id?: SortOrder
    bidderId?: SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bidder?: BidderOrderByWithRelationInput
  }

  export type EvidenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvidenceWhereInput | EvidenceWhereInput[]
    OR?: EvidenceWhereInput[]
    NOT?: EvidenceWhereInput | EvidenceWhereInput[]
    bidderId?: StringFilter<"Evidence"> | string
    type?: StringFilter<"Evidence"> | string
    metadata?: JsonNullableFilter<"Evidence">
    url?: StringNullableFilter<"Evidence"> | string | null
    createdAt?: DateTimeFilter<"Evidence"> | Date | string
    updatedAt?: DateTimeFilter<"Evidence"> | Date | string
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
  }, "id">

  export type EvidenceOrderByWithAggregationInput = {
    id?: SortOrder
    bidderId?: SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvidenceCountOrderByAggregateInput
    _max?: EvidenceMaxOrderByAggregateInput
    _min?: EvidenceMinOrderByAggregateInput
  }

  export type EvidenceScalarWhereWithAggregatesInput = {
    AND?: EvidenceScalarWhereWithAggregatesInput | EvidenceScalarWhereWithAggregatesInput[]
    OR?: EvidenceScalarWhereWithAggregatesInput[]
    NOT?: EvidenceScalarWhereWithAggregatesInput | EvidenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evidence"> | string
    bidderId?: StringWithAggregatesFilter<"Evidence"> | string
    type?: StringWithAggregatesFilter<"Evidence"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Evidence">
    url?: StringNullableWithAggregatesFilter<"Evidence"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Evidence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evidence"> | Date | string
  }

  export type EvaluationConfigWhereInput = {
    AND?: EvaluationConfigWhereInput | EvaluationConfigWhereInput[]
    OR?: EvaluationConfigWhereInput[]
    NOT?: EvaluationConfigWhereInput | EvaluationConfigWhereInput[]
    id?: StringFilter<"EvaluationConfig"> | string
    tenderId?: StringFilter<"EvaluationConfig"> | string
    priceWeight?: IntFilter<"EvaluationConfig"> | number
    bbbeeWeight?: IntFilter<"EvaluationConfig"> | number
    functionalityPass?: IntFilter<"EvaluationConfig"> | number
    functionalityMax?: IntFilter<"EvaluationConfig"> | number
    criteria?: JsonFilter<"EvaluationConfig">
    createdAt?: DateTimeFilter<"EvaluationConfig"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationConfig"> | Date | string
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }

  export type EvaluationConfigOrderByWithRelationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    priceWeight?: SortOrder
    bbbeeWeight?: SortOrder
    functionalityPass?: SortOrder
    functionalityMax?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tender?: TenderOrderByWithRelationInput
  }

  export type EvaluationConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenderId?: string
    AND?: EvaluationConfigWhereInput | EvaluationConfigWhereInput[]
    OR?: EvaluationConfigWhereInput[]
    NOT?: EvaluationConfigWhereInput | EvaluationConfigWhereInput[]
    priceWeight?: IntFilter<"EvaluationConfig"> | number
    bbbeeWeight?: IntFilter<"EvaluationConfig"> | number
    functionalityPass?: IntFilter<"EvaluationConfig"> | number
    functionalityMax?: IntFilter<"EvaluationConfig"> | number
    criteria?: JsonFilter<"EvaluationConfig">
    createdAt?: DateTimeFilter<"EvaluationConfig"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationConfig"> | Date | string
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }, "id" | "tenderId">

  export type EvaluationConfigOrderByWithAggregationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    priceWeight?: SortOrder
    bbbeeWeight?: SortOrder
    functionalityPass?: SortOrder
    functionalityMax?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvaluationConfigCountOrderByAggregateInput
    _avg?: EvaluationConfigAvgOrderByAggregateInput
    _max?: EvaluationConfigMaxOrderByAggregateInput
    _min?: EvaluationConfigMinOrderByAggregateInput
    _sum?: EvaluationConfigSumOrderByAggregateInput
  }

  export type EvaluationConfigScalarWhereWithAggregatesInput = {
    AND?: EvaluationConfigScalarWhereWithAggregatesInput | EvaluationConfigScalarWhereWithAggregatesInput[]
    OR?: EvaluationConfigScalarWhereWithAggregatesInput[]
    NOT?: EvaluationConfigScalarWhereWithAggregatesInput | EvaluationConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvaluationConfig"> | string
    tenderId?: StringWithAggregatesFilter<"EvaluationConfig"> | string
    priceWeight?: IntWithAggregatesFilter<"EvaluationConfig"> | number
    bbbeeWeight?: IntWithAggregatesFilter<"EvaluationConfig"> | number
    functionalityPass?: IntWithAggregatesFilter<"EvaluationConfig"> | number
    functionalityMax?: IntWithAggregatesFilter<"EvaluationConfig"> | number
    criteria?: JsonWithAggregatesFilter<"EvaluationConfig">
    createdAt?: DateTimeWithAggregatesFilter<"EvaluationConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EvaluationConfig"> | Date | string
  }

  export type BidderCriterionScoreWhereInput = {
    AND?: BidderCriterionScoreWhereInput | BidderCriterionScoreWhereInput[]
    OR?: BidderCriterionScoreWhereInput[]
    NOT?: BidderCriterionScoreWhereInput | BidderCriterionScoreWhereInput[]
    id?: StringFilter<"BidderCriterionScore"> | string
    bidderId?: StringFilter<"BidderCriterionScore"> | string
    criterionCode?: StringFilter<"BidderCriterionScore"> | string
    rawScore?: FloatFilter<"BidderCriterionScore"> | number
    scaleMax?: FloatFilter<"BidderCriterionScore"> | number
    weight?: FloatFilter<"BidderCriterionScore"> | number
    createdAt?: DateTimeFilter<"BidderCriterionScore"> | Date | string
    updatedAt?: DateTimeFilter<"BidderCriterionScore"> | Date | string
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
  }

  export type BidderCriterionScoreOrderByWithRelationInput = {
    id?: SortOrder
    bidderId?: SortOrder
    criterionCode?: SortOrder
    rawScore?: SortOrder
    scaleMax?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bidder?: BidderOrderByWithRelationInput
  }

  export type BidderCriterionScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BidderCriterionScoreWhereInput | BidderCriterionScoreWhereInput[]
    OR?: BidderCriterionScoreWhereInput[]
    NOT?: BidderCriterionScoreWhereInput | BidderCriterionScoreWhereInput[]
    bidderId?: StringFilter<"BidderCriterionScore"> | string
    criterionCode?: StringFilter<"BidderCriterionScore"> | string
    rawScore?: FloatFilter<"BidderCriterionScore"> | number
    scaleMax?: FloatFilter<"BidderCriterionScore"> | number
    weight?: FloatFilter<"BidderCriterionScore"> | number
    createdAt?: DateTimeFilter<"BidderCriterionScore"> | Date | string
    updatedAt?: DateTimeFilter<"BidderCriterionScore"> | Date | string
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
  }, "id">

  export type BidderCriterionScoreOrderByWithAggregationInput = {
    id?: SortOrder
    bidderId?: SortOrder
    criterionCode?: SortOrder
    rawScore?: SortOrder
    scaleMax?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BidderCriterionScoreCountOrderByAggregateInput
    _avg?: BidderCriterionScoreAvgOrderByAggregateInput
    _max?: BidderCriterionScoreMaxOrderByAggregateInput
    _min?: BidderCriterionScoreMinOrderByAggregateInput
    _sum?: BidderCriterionScoreSumOrderByAggregateInput
  }

  export type BidderCriterionScoreScalarWhereWithAggregatesInput = {
    AND?: BidderCriterionScoreScalarWhereWithAggregatesInput | BidderCriterionScoreScalarWhereWithAggregatesInput[]
    OR?: BidderCriterionScoreScalarWhereWithAggregatesInput[]
    NOT?: BidderCriterionScoreScalarWhereWithAggregatesInput | BidderCriterionScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BidderCriterionScore"> | string
    bidderId?: StringWithAggregatesFilter<"BidderCriterionScore"> | string
    criterionCode?: StringWithAggregatesFilter<"BidderCriterionScore"> | string
    rawScore?: FloatWithAggregatesFilter<"BidderCriterionScore"> | number
    scaleMax?: FloatWithAggregatesFilter<"BidderCriterionScore"> | number
    weight?: FloatWithAggregatesFilter<"BidderCriterionScore"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BidderCriterionScore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BidderCriterionScore"> | Date | string
  }

  export type EvaluationResultWhereInput = {
    AND?: EvaluationResultWhereInput | EvaluationResultWhereInput[]
    OR?: EvaluationResultWhereInput[]
    NOT?: EvaluationResultWhereInput | EvaluationResultWhereInput[]
    id?: StringFilter<"EvaluationResult"> | string
    tenderId?: StringFilter<"EvaluationResult"> | string
    bidderId?: StringFilter<"EvaluationResult"> | string
    functionalityScore?: FloatFilter<"EvaluationResult"> | number
    qualifies?: BoolFilter<"EvaluationResult"> | boolean
    price?: FloatFilter<"EvaluationResult"> | number
    priceScore?: FloatFilter<"EvaluationResult"> | number
    bbbeeLevel?: IntNullableFilter<"EvaluationResult"> | number | null
    bbbeePoints?: FloatFilter<"EvaluationResult"> | number
    totalScore?: FloatFilter<"EvaluationResult"> | number
    riskScore?: FloatNullableFilter<"EvaluationResult"> | number | null
    complianceRate?: FloatNullableFilter<"EvaluationResult"> | number | null
    exceptionsCount?: IntFilter<"EvaluationResult"> | number
    slaBreached?: BoolFilter<"EvaluationResult"> | boolean
    currentStage?: StringNullableFilter<"EvaluationResult"> | string | null
    createdAt?: DateTimeFilter<"EvaluationResult"> | Date | string
    hash?: StringFilter<"EvaluationResult"> | string
    compliance?: ComplianceItemListRelationFilter
    exceptions?: EvaluationExceptionListRelationFilter
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
    workflowLogs?: WorkflowLogListRelationFilter
  }

  export type EvaluationResultOrderByWithRelationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    bidderId?: SortOrder
    functionalityScore?: SortOrder
    qualifies?: SortOrder
    price?: SortOrder
    priceScore?: SortOrder
    bbbeeLevel?: SortOrderInput | SortOrder
    bbbeePoints?: SortOrder
    totalScore?: SortOrder
    riskScore?: SortOrderInput | SortOrder
    complianceRate?: SortOrderInput | SortOrder
    exceptionsCount?: SortOrder
    slaBreached?: SortOrder
    currentStage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    hash?: SortOrder
    compliance?: ComplianceItemOrderByRelationAggregateInput
    exceptions?: EvaluationExceptionOrderByRelationAggregateInput
    bidder?: BidderOrderByWithRelationInput
    tender?: TenderOrderByWithRelationInput
    workflowLogs?: WorkflowLogOrderByRelationAggregateInput
  }

  export type EvaluationResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hash?: string
    AND?: EvaluationResultWhereInput | EvaluationResultWhereInput[]
    OR?: EvaluationResultWhereInput[]
    NOT?: EvaluationResultWhereInput | EvaluationResultWhereInput[]
    tenderId?: StringFilter<"EvaluationResult"> | string
    bidderId?: StringFilter<"EvaluationResult"> | string
    functionalityScore?: FloatFilter<"EvaluationResult"> | number
    qualifies?: BoolFilter<"EvaluationResult"> | boolean
    price?: FloatFilter<"EvaluationResult"> | number
    priceScore?: FloatFilter<"EvaluationResult"> | number
    bbbeeLevel?: IntNullableFilter<"EvaluationResult"> | number | null
    bbbeePoints?: FloatFilter<"EvaluationResult"> | number
    totalScore?: FloatFilter<"EvaluationResult"> | number
    riskScore?: FloatNullableFilter<"EvaluationResult"> | number | null
    complianceRate?: FloatNullableFilter<"EvaluationResult"> | number | null
    exceptionsCount?: IntFilter<"EvaluationResult"> | number
    slaBreached?: BoolFilter<"EvaluationResult"> | boolean
    currentStage?: StringNullableFilter<"EvaluationResult"> | string | null
    createdAt?: DateTimeFilter<"EvaluationResult"> | Date | string
    compliance?: ComplianceItemListRelationFilter
    exceptions?: EvaluationExceptionListRelationFilter
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
    workflowLogs?: WorkflowLogListRelationFilter
  }, "id" | "hash">

  export type EvaluationResultOrderByWithAggregationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    bidderId?: SortOrder
    functionalityScore?: SortOrder
    qualifies?: SortOrder
    price?: SortOrder
    priceScore?: SortOrder
    bbbeeLevel?: SortOrderInput | SortOrder
    bbbeePoints?: SortOrder
    totalScore?: SortOrder
    riskScore?: SortOrderInput | SortOrder
    complianceRate?: SortOrderInput | SortOrder
    exceptionsCount?: SortOrder
    slaBreached?: SortOrder
    currentStage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    hash?: SortOrder
    _count?: EvaluationResultCountOrderByAggregateInput
    _avg?: EvaluationResultAvgOrderByAggregateInput
    _max?: EvaluationResultMaxOrderByAggregateInput
    _min?: EvaluationResultMinOrderByAggregateInput
    _sum?: EvaluationResultSumOrderByAggregateInput
  }

  export type EvaluationResultScalarWhereWithAggregatesInput = {
    AND?: EvaluationResultScalarWhereWithAggregatesInput | EvaluationResultScalarWhereWithAggregatesInput[]
    OR?: EvaluationResultScalarWhereWithAggregatesInput[]
    NOT?: EvaluationResultScalarWhereWithAggregatesInput | EvaluationResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvaluationResult"> | string
    tenderId?: StringWithAggregatesFilter<"EvaluationResult"> | string
    bidderId?: StringWithAggregatesFilter<"EvaluationResult"> | string
    functionalityScore?: FloatWithAggregatesFilter<"EvaluationResult"> | number
    qualifies?: BoolWithAggregatesFilter<"EvaluationResult"> | boolean
    price?: FloatWithAggregatesFilter<"EvaluationResult"> | number
    priceScore?: FloatWithAggregatesFilter<"EvaluationResult"> | number
    bbbeeLevel?: IntNullableWithAggregatesFilter<"EvaluationResult"> | number | null
    bbbeePoints?: FloatWithAggregatesFilter<"EvaluationResult"> | number
    totalScore?: FloatWithAggregatesFilter<"EvaluationResult"> | number
    riskScore?: FloatNullableWithAggregatesFilter<"EvaluationResult"> | number | null
    complianceRate?: FloatNullableWithAggregatesFilter<"EvaluationResult"> | number | null
    exceptionsCount?: IntWithAggregatesFilter<"EvaluationResult"> | number
    slaBreached?: BoolWithAggregatesFilter<"EvaluationResult"> | boolean
    currentStage?: StringNullableWithAggregatesFilter<"EvaluationResult"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EvaluationResult"> | Date | string
    hash?: StringWithAggregatesFilter<"EvaluationResult"> | string
  }

  export type WorkflowLogWhereInput = {
    AND?: WorkflowLogWhereInput | WorkflowLogWhereInput[]
    OR?: WorkflowLogWhereInput[]
    NOT?: WorkflowLogWhereInput | WorkflowLogWhereInput[]
    id?: StringFilter<"WorkflowLog"> | string
    evaluationResultId?: StringFilter<"WorkflowLog"> | string
    stage?: StringFilter<"WorkflowLog"> | string
    daysSpent?: FloatFilter<"WorkflowLog"> | number
    createdAt?: DateTimeFilter<"WorkflowLog"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowLog"> | Date | string
    evaluationResult?: XOR<EvaluationResultRelationFilter, EvaluationResultWhereInput>
  }

  export type WorkflowLogOrderByWithRelationInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    stage?: SortOrder
    daysSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluationResult?: EvaluationResultOrderByWithRelationInput
  }

  export type WorkflowLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowLogWhereInput | WorkflowLogWhereInput[]
    OR?: WorkflowLogWhereInput[]
    NOT?: WorkflowLogWhereInput | WorkflowLogWhereInput[]
    evaluationResultId?: StringFilter<"WorkflowLog"> | string
    stage?: StringFilter<"WorkflowLog"> | string
    daysSpent?: FloatFilter<"WorkflowLog"> | number
    createdAt?: DateTimeFilter<"WorkflowLog"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowLog"> | Date | string
    evaluationResult?: XOR<EvaluationResultRelationFilter, EvaluationResultWhereInput>
  }, "id">

  export type WorkflowLogOrderByWithAggregationInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    stage?: SortOrder
    daysSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowLogCountOrderByAggregateInput
    _avg?: WorkflowLogAvgOrderByAggregateInput
    _max?: WorkflowLogMaxOrderByAggregateInput
    _min?: WorkflowLogMinOrderByAggregateInput
    _sum?: WorkflowLogSumOrderByAggregateInput
  }

  export type WorkflowLogScalarWhereWithAggregatesInput = {
    AND?: WorkflowLogScalarWhereWithAggregatesInput | WorkflowLogScalarWhereWithAggregatesInput[]
    OR?: WorkflowLogScalarWhereWithAggregatesInput[]
    NOT?: WorkflowLogScalarWhereWithAggregatesInput | WorkflowLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowLog"> | string
    evaluationResultId?: StringWithAggregatesFilter<"WorkflowLog"> | string
    stage?: StringWithAggregatesFilter<"WorkflowLog"> | string
    daysSpent?: FloatWithAggregatesFilter<"WorkflowLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowLog"> | Date | string
  }

  export type CircularWhereInput = {
    AND?: CircularWhereInput | CircularWhereInput[]
    OR?: CircularWhereInput[]
    NOT?: CircularWhereInput | CircularWhereInput[]
    id?: StringFilter<"Circular"> | string
    label?: StringFilter<"Circular"> | string
    createdAt?: DateTimeFilter<"Circular"> | Date | string
    updatedAt?: DateTimeFilter<"Circular"> | Date | string
    rules?: ComplianceRuleListRelationFilter
  }

  export type CircularOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rules?: ComplianceRuleOrderByRelationAggregateInput
  }

  export type CircularWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CircularWhereInput | CircularWhereInput[]
    OR?: CircularWhereInput[]
    NOT?: CircularWhereInput | CircularWhereInput[]
    label?: StringFilter<"Circular"> | string
    createdAt?: DateTimeFilter<"Circular"> | Date | string
    updatedAt?: DateTimeFilter<"Circular"> | Date | string
    rules?: ComplianceRuleListRelationFilter
  }, "id">

  export type CircularOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CircularCountOrderByAggregateInput
    _max?: CircularMaxOrderByAggregateInput
    _min?: CircularMinOrderByAggregateInput
  }

  export type CircularScalarWhereWithAggregatesInput = {
    AND?: CircularScalarWhereWithAggregatesInput | CircularScalarWhereWithAggregatesInput[]
    OR?: CircularScalarWhereWithAggregatesInput[]
    NOT?: CircularScalarWhereWithAggregatesInput | CircularScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Circular"> | string
    label?: StringWithAggregatesFilter<"Circular"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Circular"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Circular"> | Date | string
  }

  export type ComplianceRuleWhereInput = {
    AND?: ComplianceRuleWhereInput | ComplianceRuleWhereInput[]
    OR?: ComplianceRuleWhereInput[]
    NOT?: ComplianceRuleWhereInput | ComplianceRuleWhereInput[]
    id?: StringFilter<"ComplianceRule"> | string
    circularId?: StringFilter<"ComplianceRule"> | string
    code?: StringFilter<"ComplianceRule"> | string
    label?: StringFilter<"ComplianceRule"> | string
    description?: StringNullableFilter<"ComplianceRule"> | string | null
    createdAt?: DateTimeFilter<"ComplianceRule"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceRule"> | Date | string
    items?: ComplianceItemListRelationFilter
    circular?: XOR<CircularRelationFilter, CircularWhereInput>
  }

  export type ComplianceRuleOrderByWithRelationInput = {
    id?: SortOrder
    circularId?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: ComplianceItemOrderByRelationAggregateInput
    circular?: CircularOrderByWithRelationInput
  }

  export type ComplianceRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComplianceRuleWhereInput | ComplianceRuleWhereInput[]
    OR?: ComplianceRuleWhereInput[]
    NOT?: ComplianceRuleWhereInput | ComplianceRuleWhereInput[]
    circularId?: StringFilter<"ComplianceRule"> | string
    code?: StringFilter<"ComplianceRule"> | string
    label?: StringFilter<"ComplianceRule"> | string
    description?: StringNullableFilter<"ComplianceRule"> | string | null
    createdAt?: DateTimeFilter<"ComplianceRule"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceRule"> | Date | string
    items?: ComplianceItemListRelationFilter
    circular?: XOR<CircularRelationFilter, CircularWhereInput>
  }, "id">

  export type ComplianceRuleOrderByWithAggregationInput = {
    id?: SortOrder
    circularId?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplianceRuleCountOrderByAggregateInput
    _max?: ComplianceRuleMaxOrderByAggregateInput
    _min?: ComplianceRuleMinOrderByAggregateInput
  }

  export type ComplianceRuleScalarWhereWithAggregatesInput = {
    AND?: ComplianceRuleScalarWhereWithAggregatesInput | ComplianceRuleScalarWhereWithAggregatesInput[]
    OR?: ComplianceRuleScalarWhereWithAggregatesInput[]
    NOT?: ComplianceRuleScalarWhereWithAggregatesInput | ComplianceRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComplianceRule"> | string
    circularId?: StringWithAggregatesFilter<"ComplianceRule"> | string
    code?: StringWithAggregatesFilter<"ComplianceRule"> | string
    label?: StringWithAggregatesFilter<"ComplianceRule"> | string
    description?: StringNullableWithAggregatesFilter<"ComplianceRule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ComplianceRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComplianceRule"> | Date | string
  }

  export type ComplianceItemWhereInput = {
    AND?: ComplianceItemWhereInput | ComplianceItemWhereInput[]
    OR?: ComplianceItemWhereInput[]
    NOT?: ComplianceItemWhereInput | ComplianceItemWhereInput[]
    id?: StringFilter<"ComplianceItem"> | string
    evaluationResultId?: StringFilter<"ComplianceItem"> | string
    ruleId?: StringFilter<"ComplianceItem"> | string
    compliant?: BoolFilter<"ComplianceItem"> | boolean
    createdAt?: DateTimeFilter<"ComplianceItem"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceItem"> | Date | string
    evaluationResult?: XOR<EvaluationResultRelationFilter, EvaluationResultWhereInput>
    rule?: XOR<ComplianceRuleRelationFilter, ComplianceRuleWhereInput>
  }

  export type ComplianceItemOrderByWithRelationInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    ruleId?: SortOrder
    compliant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluationResult?: EvaluationResultOrderByWithRelationInput
    rule?: ComplianceRuleOrderByWithRelationInput
  }

  export type ComplianceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComplianceItemWhereInput | ComplianceItemWhereInput[]
    OR?: ComplianceItemWhereInput[]
    NOT?: ComplianceItemWhereInput | ComplianceItemWhereInput[]
    evaluationResultId?: StringFilter<"ComplianceItem"> | string
    ruleId?: StringFilter<"ComplianceItem"> | string
    compliant?: BoolFilter<"ComplianceItem"> | boolean
    createdAt?: DateTimeFilter<"ComplianceItem"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceItem"> | Date | string
    evaluationResult?: XOR<EvaluationResultRelationFilter, EvaluationResultWhereInput>
    rule?: XOR<ComplianceRuleRelationFilter, ComplianceRuleWhereInput>
  }, "id">

  export type ComplianceItemOrderByWithAggregationInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    ruleId?: SortOrder
    compliant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplianceItemCountOrderByAggregateInput
    _max?: ComplianceItemMaxOrderByAggregateInput
    _min?: ComplianceItemMinOrderByAggregateInput
  }

  export type ComplianceItemScalarWhereWithAggregatesInput = {
    AND?: ComplianceItemScalarWhereWithAggregatesInput | ComplianceItemScalarWhereWithAggregatesInput[]
    OR?: ComplianceItemScalarWhereWithAggregatesInput[]
    NOT?: ComplianceItemScalarWhereWithAggregatesInput | ComplianceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComplianceItem"> | string
    evaluationResultId?: StringWithAggregatesFilter<"ComplianceItem"> | string
    ruleId?: StringWithAggregatesFilter<"ComplianceItem"> | string
    compliant?: BoolWithAggregatesFilter<"ComplianceItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ComplianceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComplianceItem"> | Date | string
  }

  export type EvaluationExceptionWhereInput = {
    AND?: EvaluationExceptionWhereInput | EvaluationExceptionWhereInput[]
    OR?: EvaluationExceptionWhereInput[]
    NOT?: EvaluationExceptionWhereInput | EvaluationExceptionWhereInput[]
    id?: StringFilter<"EvaluationException"> | string
    evaluationResultId?: StringFilter<"EvaluationException"> | string
    type?: StringFilter<"EvaluationException"> | string
    reason?: StringFilter<"EvaluationException"> | string
    approved?: BoolNullableFilter<"EvaluationException"> | boolean | null
    approvedBy?: StringNullableFilter<"EvaluationException"> | string | null
    approvedAt?: DateTimeNullableFilter<"EvaluationException"> | Date | string | null
    createdAt?: DateTimeFilter<"EvaluationException"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationException"> | Date | string
    evaluationResult?: XOR<EvaluationResultRelationFilter, EvaluationResultWhereInput>
  }

  export type EvaluationExceptionOrderByWithRelationInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    approved?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluationResult?: EvaluationResultOrderByWithRelationInput
  }

  export type EvaluationExceptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvaluationExceptionWhereInput | EvaluationExceptionWhereInput[]
    OR?: EvaluationExceptionWhereInput[]
    NOT?: EvaluationExceptionWhereInput | EvaluationExceptionWhereInput[]
    evaluationResultId?: StringFilter<"EvaluationException"> | string
    type?: StringFilter<"EvaluationException"> | string
    reason?: StringFilter<"EvaluationException"> | string
    approved?: BoolNullableFilter<"EvaluationException"> | boolean | null
    approvedBy?: StringNullableFilter<"EvaluationException"> | string | null
    approvedAt?: DateTimeNullableFilter<"EvaluationException"> | Date | string | null
    createdAt?: DateTimeFilter<"EvaluationException"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationException"> | Date | string
    evaluationResult?: XOR<EvaluationResultRelationFilter, EvaluationResultWhereInput>
  }, "id">

  export type EvaluationExceptionOrderByWithAggregationInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    approved?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvaluationExceptionCountOrderByAggregateInput
    _max?: EvaluationExceptionMaxOrderByAggregateInput
    _min?: EvaluationExceptionMinOrderByAggregateInput
  }

  export type EvaluationExceptionScalarWhereWithAggregatesInput = {
    AND?: EvaluationExceptionScalarWhereWithAggregatesInput | EvaluationExceptionScalarWhereWithAggregatesInput[]
    OR?: EvaluationExceptionScalarWhereWithAggregatesInput[]
    NOT?: EvaluationExceptionScalarWhereWithAggregatesInput | EvaluationExceptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvaluationException"> | string
    evaluationResultId?: StringWithAggregatesFilter<"EvaluationException"> | string
    type?: StringWithAggregatesFilter<"EvaluationException"> | string
    reason?: StringWithAggregatesFilter<"EvaluationException"> | string
    approved?: BoolNullableWithAggregatesFilter<"EvaluationException"> | boolean | null
    approvedBy?: StringNullableWithAggregatesFilter<"EvaluationException"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"EvaluationException"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EvaluationException"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EvaluationException"> | Date | string
  }

  export type EvaluationSignatureWhereInput = {
    AND?: EvaluationSignatureWhereInput | EvaluationSignatureWhereInput[]
    OR?: EvaluationSignatureWhereInput[]
    NOT?: EvaluationSignatureWhereInput | EvaluationSignatureWhereInput[]
    id?: StringFilter<"EvaluationSignature"> | string
    tenderId?: StringFilter<"EvaluationSignature"> | string
    role?: StringFilter<"EvaluationSignature"> | string
    name?: StringFilter<"EvaluationSignature"> | string
    signature?: StringNullableFilter<"EvaluationSignature"> | string | null
    comment?: StringNullableFilter<"EvaluationSignature"> | string | null
    signedAt?: DateTimeFilter<"EvaluationSignature"> | Date | string
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }

  export type EvaluationSignatureOrderByWithRelationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    signature?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    signedAt?: SortOrder
    tender?: TenderOrderByWithRelationInput
  }

  export type EvaluationSignatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenderId_role?: EvaluationSignatureTenderIdRoleCompoundUniqueInput
    AND?: EvaluationSignatureWhereInput | EvaluationSignatureWhereInput[]
    OR?: EvaluationSignatureWhereInput[]
    NOT?: EvaluationSignatureWhereInput | EvaluationSignatureWhereInput[]
    tenderId?: StringFilter<"EvaluationSignature"> | string
    role?: StringFilter<"EvaluationSignature"> | string
    name?: StringFilter<"EvaluationSignature"> | string
    signature?: StringNullableFilter<"EvaluationSignature"> | string | null
    comment?: StringNullableFilter<"EvaluationSignature"> | string | null
    signedAt?: DateTimeFilter<"EvaluationSignature"> | Date | string
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }, "id" | "tenderId_role">

  export type EvaluationSignatureOrderByWithAggregationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    signature?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    signedAt?: SortOrder
    _count?: EvaluationSignatureCountOrderByAggregateInput
    _max?: EvaluationSignatureMaxOrderByAggregateInput
    _min?: EvaluationSignatureMinOrderByAggregateInput
  }

  export type EvaluationSignatureScalarWhereWithAggregatesInput = {
    AND?: EvaluationSignatureScalarWhereWithAggregatesInput | EvaluationSignatureScalarWhereWithAggregatesInput[]
    OR?: EvaluationSignatureScalarWhereWithAggregatesInput[]
    NOT?: EvaluationSignatureScalarWhereWithAggregatesInput | EvaluationSignatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvaluationSignature"> | string
    tenderId?: StringWithAggregatesFilter<"EvaluationSignature"> | string
    role?: StringWithAggregatesFilter<"EvaluationSignature"> | string
    name?: StringWithAggregatesFilter<"EvaluationSignature"> | string
    signature?: StringNullableWithAggregatesFilter<"EvaluationSignature"> | string | null
    comment?: StringNullableWithAggregatesFilter<"EvaluationSignature"> | string | null
    signedAt?: DateTimeWithAggregatesFilter<"EvaluationSignature"> | Date | string
  }

  export type EvaluationDocumentWhereInput = {
    AND?: EvaluationDocumentWhereInput | EvaluationDocumentWhereInput[]
    OR?: EvaluationDocumentWhereInput[]
    NOT?: EvaluationDocumentWhereInput | EvaluationDocumentWhereInput[]
    id?: StringFilter<"EvaluationDocument"> | string
    tenderId?: StringFilter<"EvaluationDocument"> | string
    runNumber?: IntFilter<"EvaluationDocument"> | number
    fileUrl?: StringFilter<"EvaluationDocument"> | string
    hash?: StringFilter<"EvaluationDocument"> | string
    createdAt?: DateTimeFilter<"EvaluationDocument"> | Date | string
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }

  export type EvaluationDocumentOrderByWithRelationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    runNumber?: SortOrder
    fileUrl?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    tender?: TenderOrderByWithRelationInput
  }

  export type EvaluationDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenderId_runNumber?: EvaluationDocumentTenderIdRunNumberCompoundUniqueInput
    AND?: EvaluationDocumentWhereInput | EvaluationDocumentWhereInput[]
    OR?: EvaluationDocumentWhereInput[]
    NOT?: EvaluationDocumentWhereInput | EvaluationDocumentWhereInput[]
    tenderId?: StringFilter<"EvaluationDocument"> | string
    runNumber?: IntFilter<"EvaluationDocument"> | number
    fileUrl?: StringFilter<"EvaluationDocument"> | string
    hash?: StringFilter<"EvaluationDocument"> | string
    createdAt?: DateTimeFilter<"EvaluationDocument"> | Date | string
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }, "id" | "tenderId_runNumber">

  export type EvaluationDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    runNumber?: SortOrder
    fileUrl?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
    _count?: EvaluationDocumentCountOrderByAggregateInput
    _avg?: EvaluationDocumentAvgOrderByAggregateInput
    _max?: EvaluationDocumentMaxOrderByAggregateInput
    _min?: EvaluationDocumentMinOrderByAggregateInput
    _sum?: EvaluationDocumentSumOrderByAggregateInput
  }

  export type EvaluationDocumentScalarWhereWithAggregatesInput = {
    AND?: EvaluationDocumentScalarWhereWithAggregatesInput | EvaluationDocumentScalarWhereWithAggregatesInput[]
    OR?: EvaluationDocumentScalarWhereWithAggregatesInput[]
    NOT?: EvaluationDocumentScalarWhereWithAggregatesInput | EvaluationDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvaluationDocument"> | string
    tenderId?: StringWithAggregatesFilter<"EvaluationDocument"> | string
    runNumber?: IntWithAggregatesFilter<"EvaluationDocument"> | number
    fileUrl?: StringWithAggregatesFilter<"EvaluationDocument"> | string
    hash?: StringWithAggregatesFilter<"EvaluationDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EvaluationDocument"> | Date | string
  }

  export type AnalyticsAccessLogWhereInput = {
    AND?: AnalyticsAccessLogWhereInput | AnalyticsAccessLogWhereInput[]
    OR?: AnalyticsAccessLogWhereInput[]
    NOT?: AnalyticsAccessLogWhereInput | AnalyticsAccessLogWhereInput[]
    id?: StringFilter<"AnalyticsAccessLog"> | string
    userId?: StringFilter<"AnalyticsAccessLog"> | string
    role?: StringFilter<"AnalyticsAccessLog"> | string
    endpoint?: StringFilter<"AnalyticsAccessLog"> | string
    ip?: StringNullableFilter<"AnalyticsAccessLog"> | string | null
    userAgent?: StringNullableFilter<"AnalyticsAccessLog"> | string | null
    createdAt?: DateTimeFilter<"AnalyticsAccessLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AnalyticsAccessLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    endpoint?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AnalyticsAccessLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsAccessLogWhereInput | AnalyticsAccessLogWhereInput[]
    OR?: AnalyticsAccessLogWhereInput[]
    NOT?: AnalyticsAccessLogWhereInput | AnalyticsAccessLogWhereInput[]
    userId?: StringFilter<"AnalyticsAccessLog"> | string
    role?: StringFilter<"AnalyticsAccessLog"> | string
    endpoint?: StringFilter<"AnalyticsAccessLog"> | string
    ip?: StringNullableFilter<"AnalyticsAccessLog"> | string | null
    userAgent?: StringNullableFilter<"AnalyticsAccessLog"> | string | null
    createdAt?: DateTimeFilter<"AnalyticsAccessLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AnalyticsAccessLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    endpoint?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsAccessLogCountOrderByAggregateInput
    _max?: AnalyticsAccessLogMaxOrderByAggregateInput
    _min?: AnalyticsAccessLogMinOrderByAggregateInput
  }

  export type AnalyticsAccessLogScalarWhereWithAggregatesInput = {
    AND?: AnalyticsAccessLogScalarWhereWithAggregatesInput | AnalyticsAccessLogScalarWhereWithAggregatesInput[]
    OR?: AnalyticsAccessLogScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsAccessLogScalarWhereWithAggregatesInput | AnalyticsAccessLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsAccessLog"> | string
    userId?: StringWithAggregatesFilter<"AnalyticsAccessLog"> | string
    role?: StringWithAggregatesFilter<"AnalyticsAccessLog"> | string
    endpoint?: StringWithAggregatesFilter<"AnalyticsAccessLog"> | string
    ip?: StringNullableWithAggregatesFilter<"AnalyticsAccessLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AnalyticsAccessLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsAccessLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationRuleWhereInput = {
    AND?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    OR?: NotificationRuleWhereInput[]
    NOT?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    id?: StringFilter<"NotificationRule"> | string
    trigger?: StringFilter<"NotificationRule"> | string
    role?: StringFilter<"NotificationRule"> | string
    enabled?: BoolFilter<"NotificationRule"> | boolean
    ownerId?: StringNullableFilter<"NotificationRule"> | string | null
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type NotificationRuleOrderByWithRelationInput = {
    id?: SortOrder
    trigger?: SortOrder
    role?: SortOrder
    enabled?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    owner?: UserOrderByWithRelationInput
  }

  export type NotificationRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trigger_role?: NotificationRuleTrigger_roleCompoundUniqueInput
    AND?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    OR?: NotificationRuleWhereInput[]
    NOT?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    trigger?: StringFilter<"NotificationRule"> | string
    role?: StringFilter<"NotificationRule"> | string
    enabled?: BoolFilter<"NotificationRule"> | boolean
    ownerId?: StringNullableFilter<"NotificationRule"> | string | null
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "trigger_role">

  export type NotificationRuleOrderByWithAggregationInput = {
    id?: SortOrder
    trigger?: SortOrder
    role?: SortOrder
    enabled?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    _count?: NotificationRuleCountOrderByAggregateInput
    _max?: NotificationRuleMaxOrderByAggregateInput
    _min?: NotificationRuleMinOrderByAggregateInput
  }

  export type NotificationRuleScalarWhereWithAggregatesInput = {
    AND?: NotificationRuleScalarWhereWithAggregatesInput | NotificationRuleScalarWhereWithAggregatesInput[]
    OR?: NotificationRuleScalarWhereWithAggregatesInput[]
    NOT?: NotificationRuleScalarWhereWithAggregatesInput | NotificationRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationRule"> | string
    trigger?: StringWithAggregatesFilter<"NotificationRule"> | string
    role?: StringWithAggregatesFilter<"NotificationRule"> | string
    enabled?: BoolWithAggregatesFilter<"NotificationRule"> | boolean
    ownerId?: StringNullableWithAggregatesFilter<"NotificationRule"> | string | null
  }

  export type TenderTimelineEventWhereInput = {
    AND?: TenderTimelineEventWhereInput | TenderTimelineEventWhereInput[]
    OR?: TenderTimelineEventWhereInput[]
    NOT?: TenderTimelineEventWhereInput | TenderTimelineEventWhereInput[]
    id?: StringFilter<"TenderTimelineEvent"> | string
    tenderId?: StringFilter<"TenderTimelineEvent"> | string
    type?: StringFilter<"TenderTimelineEvent"> | string
    label?: StringFilter<"TenderTimelineEvent"> | string
    createdAt?: DateTimeFilter<"TenderTimelineEvent"> | Date | string
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }

  export type TenderTimelineEventOrderByWithRelationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    tender?: TenderOrderByWithRelationInput
  }

  export type TenderTimelineEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenderTimelineEventWhereInput | TenderTimelineEventWhereInput[]
    OR?: TenderTimelineEventWhereInput[]
    NOT?: TenderTimelineEventWhereInput | TenderTimelineEventWhereInput[]
    tenderId?: StringFilter<"TenderTimelineEvent"> | string
    type?: StringFilter<"TenderTimelineEvent"> | string
    label?: StringFilter<"TenderTimelineEvent"> | string
    createdAt?: DateTimeFilter<"TenderTimelineEvent"> | Date | string
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }, "id">

  export type TenderTimelineEventOrderByWithAggregationInput = {
    id?: SortOrder
    tenderId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    _count?: TenderTimelineEventCountOrderByAggregateInput
    _max?: TenderTimelineEventMaxOrderByAggregateInput
    _min?: TenderTimelineEventMinOrderByAggregateInput
  }

  export type TenderTimelineEventScalarWhereWithAggregatesInput = {
    AND?: TenderTimelineEventScalarWhereWithAggregatesInput | TenderTimelineEventScalarWhereWithAggregatesInput[]
    OR?: TenderTimelineEventScalarWhereWithAggregatesInput[]
    NOT?: TenderTimelineEventScalarWhereWithAggregatesInput | TenderTimelineEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenderTimelineEvent"> | string
    tenderId?: StringWithAggregatesFilter<"TenderTimelineEvent"> | string
    type?: StringWithAggregatesFilter<"TenderTimelineEvent"> | string
    label?: StringWithAggregatesFilter<"TenderTimelineEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TenderTimelineEvent"> | Date | string
  }

  export type TenderInsightsWhereInput = {
    AND?: TenderInsightsWhereInput | TenderInsightsWhereInput[]
    OR?: TenderInsightsWhereInput[]
    NOT?: TenderInsightsWhereInput | TenderInsightsWhereInput[]
    tenderId?: StringFilter<"TenderInsights"> | string
    payload?: JsonFilter<"TenderInsights">
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }

  export type TenderInsightsOrderByWithRelationInput = {
    tenderId?: SortOrder
    payload?: SortOrder
    tender?: TenderOrderByWithRelationInput
  }

  export type TenderInsightsWhereUniqueInput = Prisma.AtLeast<{
    tenderId?: string
    AND?: TenderInsightsWhereInput | TenderInsightsWhereInput[]
    OR?: TenderInsightsWhereInput[]
    NOT?: TenderInsightsWhereInput | TenderInsightsWhereInput[]
    payload?: JsonFilter<"TenderInsights">
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }, "tenderId">

  export type TenderInsightsOrderByWithAggregationInput = {
    tenderId?: SortOrder
    payload?: SortOrder
    _count?: TenderInsightsCountOrderByAggregateInput
    _max?: TenderInsightsMaxOrderByAggregateInput
    _min?: TenderInsightsMinOrderByAggregateInput
  }

  export type TenderInsightsScalarWhereWithAggregatesInput = {
    AND?: TenderInsightsScalarWhereWithAggregatesInput | TenderInsightsScalarWhereWithAggregatesInput[]
    OR?: TenderInsightsScalarWhereWithAggregatesInput[]
    NOT?: TenderInsightsScalarWhereWithAggregatesInput | TenderInsightsScalarWhereWithAggregatesInput[]
    tenderId?: StringWithAggregatesFilter<"TenderInsights"> | string
    payload?: JsonWithAggregatesFilter<"TenderInsights">
  }

  export type TenderHeatmapWhereInput = {
    AND?: TenderHeatmapWhereInput | TenderHeatmapWhereInput[]
    OR?: TenderHeatmapWhereInput[]
    NOT?: TenderHeatmapWhereInput | TenderHeatmapWhereInput[]
    tenderId?: StringFilter<"TenderHeatmap"> | string
    cells?: JsonFilter<"TenderHeatmap">
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }

  export type TenderHeatmapOrderByWithRelationInput = {
    tenderId?: SortOrder
    cells?: SortOrder
    tender?: TenderOrderByWithRelationInput
  }

  export type TenderHeatmapWhereUniqueInput = Prisma.AtLeast<{
    tenderId?: string
    AND?: TenderHeatmapWhereInput | TenderHeatmapWhereInput[]
    OR?: TenderHeatmapWhereInput[]
    NOT?: TenderHeatmapWhereInput | TenderHeatmapWhereInput[]
    cells?: JsonFilter<"TenderHeatmap">
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }, "tenderId">

  export type TenderHeatmapOrderByWithAggregationInput = {
    tenderId?: SortOrder
    cells?: SortOrder
    _count?: TenderHeatmapCountOrderByAggregateInput
    _max?: TenderHeatmapMaxOrderByAggregateInput
    _min?: TenderHeatmapMinOrderByAggregateInput
  }

  export type TenderHeatmapScalarWhereWithAggregatesInput = {
    AND?: TenderHeatmapScalarWhereWithAggregatesInput | TenderHeatmapScalarWhereWithAggregatesInput[]
    OR?: TenderHeatmapScalarWhereWithAggregatesInput[]
    NOT?: TenderHeatmapScalarWhereWithAggregatesInput | TenderHeatmapScalarWhereWithAggregatesInput[]
    tenderId?: StringWithAggregatesFilter<"TenderHeatmap"> | string
    cells?: JsonWithAggregatesFilter<"TenderHeatmap">
  }

  export type BidderIntelligenceWhereInput = {
    AND?: BidderIntelligenceWhereInput | BidderIntelligenceWhereInput[]
    OR?: BidderIntelligenceWhereInput[]
    NOT?: BidderIntelligenceWhereInput | BidderIntelligenceWhereInput[]
    bidderId?: StringFilter<"BidderIntelligence"> | string
    timeline?: JsonFilter<"BidderIntelligence">
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
  }

  export type BidderIntelligenceOrderByWithRelationInput = {
    bidderId?: SortOrder
    timeline?: SortOrder
    bidder?: BidderOrderByWithRelationInput
  }

  export type BidderIntelligenceWhereUniqueInput = Prisma.AtLeast<{
    bidderId?: string
    AND?: BidderIntelligenceWhereInput | BidderIntelligenceWhereInput[]
    OR?: BidderIntelligenceWhereInput[]
    NOT?: BidderIntelligenceWhereInput | BidderIntelligenceWhereInput[]
    timeline?: JsonFilter<"BidderIntelligence">
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
  }, "bidderId">

  export type BidderIntelligenceOrderByWithAggregationInput = {
    bidderId?: SortOrder
    timeline?: SortOrder
    _count?: BidderIntelligenceCountOrderByAggregateInput
    _max?: BidderIntelligenceMaxOrderByAggregateInput
    _min?: BidderIntelligenceMinOrderByAggregateInput
  }

  export type BidderIntelligenceScalarWhereWithAggregatesInput = {
    AND?: BidderIntelligenceScalarWhereWithAggregatesInput | BidderIntelligenceScalarWhereWithAggregatesInput[]
    OR?: BidderIntelligenceScalarWhereWithAggregatesInput[]
    NOT?: BidderIntelligenceScalarWhereWithAggregatesInput | BidderIntelligenceScalarWhereWithAggregatesInput[]
    bidderId?: StringWithAggregatesFilter<"BidderIntelligence"> | string
    timeline?: JsonWithAggregatesFilter<"BidderIntelligence">
  }

  export type BidderRiskProfileWhereInput = {
    AND?: BidderRiskProfileWhereInput | BidderRiskProfileWhereInput[]
    OR?: BidderRiskProfileWhereInput[]
    NOT?: BidderRiskProfileWhereInput | BidderRiskProfileWhereInput[]
    bidderId?: StringFilter<"BidderRiskProfile"> | string
    profile?: JsonFilter<"BidderRiskProfile">
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
  }

  export type BidderRiskProfileOrderByWithRelationInput = {
    bidderId?: SortOrder
    profile?: SortOrder
    bidder?: BidderOrderByWithRelationInput
  }

  export type BidderRiskProfileWhereUniqueInput = Prisma.AtLeast<{
    bidderId?: string
    AND?: BidderRiskProfileWhereInput | BidderRiskProfileWhereInput[]
    OR?: BidderRiskProfileWhereInput[]
    NOT?: BidderRiskProfileWhereInput | BidderRiskProfileWhereInput[]
    profile?: JsonFilter<"BidderRiskProfile">
    bidder?: XOR<BidderRelationFilter, BidderWhereInput>
  }, "bidderId">

  export type BidderRiskProfileOrderByWithAggregationInput = {
    bidderId?: SortOrder
    profile?: SortOrder
    _count?: BidderRiskProfileCountOrderByAggregateInput
    _max?: BidderRiskProfileMaxOrderByAggregateInput
    _min?: BidderRiskProfileMinOrderByAggregateInput
  }

  export type BidderRiskProfileScalarWhereWithAggregatesInput = {
    AND?: BidderRiskProfileScalarWhereWithAggregatesInput | BidderRiskProfileScalarWhereWithAggregatesInput[]
    OR?: BidderRiskProfileScalarWhereWithAggregatesInput[]
    NOT?: BidderRiskProfileScalarWhereWithAggregatesInput | BidderRiskProfileScalarWhereWithAggregatesInput[]
    bidderId?: StringWithAggregatesFilter<"BidderRiskProfile"> | string
    profile?: JsonWithAggregatesFilter<"BidderRiskProfile">
  }

  export type TenderComplianceDashboardWhereInput = {
    AND?: TenderComplianceDashboardWhereInput | TenderComplianceDashboardWhereInput[]
    OR?: TenderComplianceDashboardWhereInput[]
    NOT?: TenderComplianceDashboardWhereInput | TenderComplianceDashboardWhereInput[]
    tenderId?: StringFilter<"TenderComplianceDashboard"> | string
    payload?: JsonFilter<"TenderComplianceDashboard">
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }

  export type TenderComplianceDashboardOrderByWithRelationInput = {
    tenderId?: SortOrder
    payload?: SortOrder
    tender?: TenderOrderByWithRelationInput
  }

  export type TenderComplianceDashboardWhereUniqueInput = Prisma.AtLeast<{
    tenderId?: string
    AND?: TenderComplianceDashboardWhereInput | TenderComplianceDashboardWhereInput[]
    OR?: TenderComplianceDashboardWhereInput[]
    NOT?: TenderComplianceDashboardWhereInput | TenderComplianceDashboardWhereInput[]
    payload?: JsonFilter<"TenderComplianceDashboard">
    tender?: XOR<TenderRelationFilter, TenderWhereInput>
  }, "tenderId">

  export type TenderComplianceDashboardOrderByWithAggregationInput = {
    tenderId?: SortOrder
    payload?: SortOrder
    _count?: TenderComplianceDashboardCountOrderByAggregateInput
    _max?: TenderComplianceDashboardMaxOrderByAggregateInput
    _min?: TenderComplianceDashboardMinOrderByAggregateInput
  }

  export type TenderComplianceDashboardScalarWhereWithAggregatesInput = {
    AND?: TenderComplianceDashboardScalarWhereWithAggregatesInput | TenderComplianceDashboardScalarWhereWithAggregatesInput[]
    OR?: TenderComplianceDashboardScalarWhereWithAggregatesInput[]
    NOT?: TenderComplianceDashboardScalarWhereWithAggregatesInput | TenderComplianceDashboardScalarWhereWithAggregatesInput[]
    tenderId?: StringWithAggregatesFilter<"TenderComplianceDashboard"> | string
    payload?: JsonWithAggregatesFilter<"TenderComplianceDashboard">
  }

  export type TenantCreateInput = {
    id?: string
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branding?: TenantBrandingCreateNestedOneWithoutTenantInput
    tenders?: TenderCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branding?: TenantBrandingUncheckedCreateNestedOneWithoutTenantInput
    tenders?: TenderUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branding?: TenantBrandingUpdateOneWithoutTenantNestedInput
    tenders?: TenderUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branding?: TenantBrandingUncheckedUpdateOneWithoutTenantNestedInput
    tenders?: TenderUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBrandingCreateInput = {
    id?: string
    primaryColor?: string | null
    secondaryColor?: string | null
    logoUrl?: string | null
    publicName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBrandingInput
  }

  export type TenantBrandingUncheckedCreateInput = {
    id?: string
    tenantId: string
    primaryColor?: string | null
    secondaryColor?: string | null
    logoUrl?: string | null
    publicName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantBrandingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publicName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBrandingNestedInput
  }

  export type TenantBrandingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publicName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBrandingCreateManyInput = {
    id?: string
    tenantId: string
    primaryColor?: string | null
    secondaryColor?: string | null
    logoUrl?: string | null
    publicName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantBrandingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publicName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBrandingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publicName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    analyticsLogs?: AnalyticsAccessLogCreateNestedManyWithoutUserInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutUserInput
    tenant?: TenantCreateNestedOneWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationRules?: NotificationRuleCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    tenantId?: string | null
    analyticsLogs?: AnalyticsAccessLogUncheckedCreateNestedManyWithoutUserInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationRules?: NotificationRuleUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    analyticsLogs?: AnalyticsAccessLogUpdateManyWithoutUserNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationRules?: NotificationRuleUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsLogs?: AnalyticsAccessLogUncheckedUpdateManyWithoutUserNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationRules?: NotificationRuleUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    tenantId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScmTenderAssignmentCreateInput = {
    id?: string
    createdAt?: Date | string
    tender: TenderCreateNestedOneWithoutScmAssignmentsInput
    user: UserCreateNestedOneWithoutScmAssignmentsInput
  }

  export type ScmTenderAssignmentUncheckedCreateInput = {
    id?: string
    userId: string
    tenderId: string
    createdAt?: Date | string
  }

  export type ScmTenderAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tender?: TenderUpdateOneRequiredWithoutScmAssignmentsNestedInput
    user?: UserUpdateOneRequiredWithoutScmAssignmentsNestedInput
  }

  export type ScmTenderAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScmTenderAssignmentCreateManyInput = {
    id?: string
    userId: string
    tenderId: string
    createdAt?: Date | string
  }

  export type ScmTenderAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScmTenderAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenderCreateInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutTenderInput
    tenant?: TenantCreateNestedOneWithoutTendersInput
    timelineEvents?: TenderTimelineEventCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
    bidders?: BidderUncheckedCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsUncheckedCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutTenderNestedInput
    tenant?: TenantUpdateOneWithoutTendersNestedInput
    timelineEvents?: TenderTimelineEventUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    bidders?: BidderUncheckedUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type TenderCreateManyInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
  }

  export type TenderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BidderCreateInput = {
    id?: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeCreateNestedOneWithoutBidderInput
    tender: TenderCreateNestedOneWithoutBiddersInput
    technicalScores?: BidderCriterionScoreCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutBidderInput
    evidence?: EvidenceCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileCreateNestedOneWithoutBidderInput
  }

  export type BidderUncheckedCreateInput = {
    id?: string
    tenderId: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeUncheckedCreateNestedOneWithoutBidderInput
    technicalScores?: BidderCriterionScoreUncheckedCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutBidderInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceUncheckedCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileUncheckedCreateNestedOneWithoutBidderInput
  }

  export type BidderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUpdateOneWithoutBidderNestedInput
    tender?: TenderUpdateOneRequiredWithoutBiddersNestedInput
    technicalScores?: BidderCriterionScoreUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUpdateOneWithoutBidderNestedInput
  }

  export type BidderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUncheckedUpdateOneWithoutBidderNestedInput
    technicalScores?: BidderCriterionScoreUncheckedUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUncheckedUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUncheckedUpdateOneWithoutBidderNestedInput
  }

  export type BidderCreateManyInput = {
    id?: string
    tenderId: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BbbeeCreateInput = {
    id?: string
    level?: number | null
    expiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidder: BidderCreateNestedOneWithoutBbbeeInput
  }

  export type BbbeeUncheckedCreateInput = {
    id?: string
    bidderId: string
    level?: number | null
    expiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BbbeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidder?: BidderUpdateOneRequiredWithoutBbbeeNestedInput
  }

  export type BbbeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BbbeeCreateManyInput = {
    id?: string
    bidderId: string
    level?: number | null
    expiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BbbeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BbbeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceCreateInput = {
    id?: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidder: BidderCreateNestedOneWithoutEvidenceInput
  }

  export type EvidenceUncheckedCreateInput = {
    id?: string
    bidderId: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidder?: BidderUpdateOneRequiredWithoutEvidenceNestedInput
  }

  export type EvidenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceCreateManyInput = {
    id?: string
    bidderId: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationConfigCreateInput = {
    id?: string
    priceWeight: number
    bbbeeWeight: number
    functionalityPass: number
    functionalityMax: number
    criteria: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tender: TenderCreateNestedOneWithoutEvaluationConfigInput
  }

  export type EvaluationConfigUncheckedCreateInput = {
    id?: string
    tenderId: string
    priceWeight: number
    bbbeeWeight: number
    functionalityPass: number
    functionalityMax: number
    criteria: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceWeight?: IntFieldUpdateOperationsInput | number
    bbbeeWeight?: IntFieldUpdateOperationsInput | number
    functionalityPass?: IntFieldUpdateOperationsInput | number
    functionalityMax?: IntFieldUpdateOperationsInput | number
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tender?: TenderUpdateOneRequiredWithoutEvaluationConfigNestedInput
  }

  export type EvaluationConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    priceWeight?: IntFieldUpdateOperationsInput | number
    bbbeeWeight?: IntFieldUpdateOperationsInput | number
    functionalityPass?: IntFieldUpdateOperationsInput | number
    functionalityMax?: IntFieldUpdateOperationsInput | number
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationConfigCreateManyInput = {
    id?: string
    tenderId: string
    priceWeight: number
    bbbeeWeight: number
    functionalityPass: number
    functionalityMax: number
    criteria: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceWeight?: IntFieldUpdateOperationsInput | number
    bbbeeWeight?: IntFieldUpdateOperationsInput | number
    functionalityPass?: IntFieldUpdateOperationsInput | number
    functionalityMax?: IntFieldUpdateOperationsInput | number
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    priceWeight?: IntFieldUpdateOperationsInput | number
    bbbeeWeight?: IntFieldUpdateOperationsInput | number
    functionalityPass?: IntFieldUpdateOperationsInput | number
    functionalityMax?: IntFieldUpdateOperationsInput | number
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidderCriterionScoreCreateInput = {
    id?: string
    criterionCode: string
    rawScore: number
    scaleMax: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bidder: BidderCreateNestedOneWithoutTechnicalScoresInput
  }

  export type BidderCriterionScoreUncheckedCreateInput = {
    id?: string
    bidderId: string
    criterionCode: string
    rawScore: number
    scaleMax: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidderCriterionScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    criterionCode?: StringFieldUpdateOperationsInput | string
    rawScore?: FloatFieldUpdateOperationsInput | number
    scaleMax?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidder?: BidderUpdateOneRequiredWithoutTechnicalScoresNestedInput
  }

  export type BidderCriterionScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    criterionCode?: StringFieldUpdateOperationsInput | string
    rawScore?: FloatFieldUpdateOperationsInput | number
    scaleMax?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidderCriterionScoreCreateManyInput = {
    id?: string
    bidderId: string
    criterionCode: string
    rawScore: number
    scaleMax: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidderCriterionScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    criterionCode?: StringFieldUpdateOperationsInput | string
    rawScore?: FloatFieldUpdateOperationsInput | number
    scaleMax?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidderCriterionScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    criterionCode?: StringFieldUpdateOperationsInput | string
    rawScore?: FloatFieldUpdateOperationsInput | number
    scaleMax?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationResultCreateInput = {
    id?: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    compliance?: ComplianceItemCreateNestedManyWithoutEvaluationResultInput
    exceptions?: EvaluationExceptionCreateNestedManyWithoutEvaluationResultInput
    bidder: BidderCreateNestedOneWithoutEvaluationResultsInput
    tender: TenderCreateNestedOneWithoutEvaluationResultsInput
    workflowLogs?: WorkflowLogCreateNestedManyWithoutEvaluationResultInput
  }

  export type EvaluationResultUncheckedCreateInput = {
    id?: string
    tenderId: string
    bidderId: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    compliance?: ComplianceItemUncheckedCreateNestedManyWithoutEvaluationResultInput
    exceptions?: EvaluationExceptionUncheckedCreateNestedManyWithoutEvaluationResultInput
    workflowLogs?: WorkflowLogUncheckedCreateNestedManyWithoutEvaluationResultInput
  }

  export type EvaluationResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    compliance?: ComplianceItemUpdateManyWithoutEvaluationResultNestedInput
    exceptions?: EvaluationExceptionUpdateManyWithoutEvaluationResultNestedInput
    bidder?: BidderUpdateOneRequiredWithoutEvaluationResultsNestedInput
    tender?: TenderUpdateOneRequiredWithoutEvaluationResultsNestedInput
    workflowLogs?: WorkflowLogUpdateManyWithoutEvaluationResultNestedInput
  }

  export type EvaluationResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    compliance?: ComplianceItemUncheckedUpdateManyWithoutEvaluationResultNestedInput
    exceptions?: EvaluationExceptionUncheckedUpdateManyWithoutEvaluationResultNestedInput
    workflowLogs?: WorkflowLogUncheckedUpdateManyWithoutEvaluationResultNestedInput
  }

  export type EvaluationResultCreateManyInput = {
    id?: string
    tenderId: string
    bidderId: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
  }

  export type EvaluationResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
  }

  export type EvaluationResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowLogCreateInput = {
    id?: string
    stage: string
    daysSpent: number
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationResult: EvaluationResultCreateNestedOneWithoutWorkflowLogsInput
  }

  export type WorkflowLogUncheckedCreateInput = {
    id?: string
    evaluationResultId: string
    stage: string
    daysSpent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    daysSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationResult?: EvaluationResultUpdateOneRequiredWithoutWorkflowLogsNestedInput
  }

  export type WorkflowLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationResultId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    daysSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowLogCreateManyInput = {
    id?: string
    evaluationResultId: string
    stage: string
    daysSpent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    daysSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationResultId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    daysSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircularCreateInput = {
    id?: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: ComplianceRuleCreateNestedManyWithoutCircularInput
  }

  export type CircularUncheckedCreateInput = {
    id?: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: ComplianceRuleUncheckedCreateNestedManyWithoutCircularInput
  }

  export type CircularUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: ComplianceRuleUpdateManyWithoutCircularNestedInput
  }

  export type CircularUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: ComplianceRuleUncheckedUpdateManyWithoutCircularNestedInput
  }

  export type CircularCreateManyInput = {
    id?: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircularUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircularUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceRuleCreateInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ComplianceItemCreateNestedManyWithoutRuleInput
    circular: CircularCreateNestedOneWithoutRulesInput
  }

  export type ComplianceRuleUncheckedCreateInput = {
    id?: string
    circularId: string
    code: string
    label: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ComplianceItemUncheckedCreateNestedManyWithoutRuleInput
  }

  export type ComplianceRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ComplianceItemUpdateManyWithoutRuleNestedInput
    circular?: CircularUpdateOneRequiredWithoutRulesNestedInput
  }

  export type ComplianceRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    circularId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ComplianceItemUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type ComplianceRuleCreateManyInput = {
    id?: string
    circularId: string
    code: string
    label: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    circularId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceItemCreateInput = {
    id?: string
    compliant: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationResult: EvaluationResultCreateNestedOneWithoutComplianceInput
    rule: ComplianceRuleCreateNestedOneWithoutItemsInput
  }

  export type ComplianceItemUncheckedCreateInput = {
    id?: string
    evaluationResultId: string
    ruleId: string
    compliant: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    compliant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationResult?: EvaluationResultUpdateOneRequiredWithoutComplianceNestedInput
    rule?: ComplianceRuleUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ComplianceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationResultId?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    compliant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceItemCreateManyInput = {
    id?: string
    evaluationResultId: string
    ruleId: string
    compliant: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    compliant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationResultId?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    compliant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationExceptionCreateInput = {
    id?: string
    type: string
    reason: string
    approved?: boolean | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationResult: EvaluationResultCreateNestedOneWithoutExceptionsInput
  }

  export type EvaluationExceptionUncheckedCreateInput = {
    id?: string
    evaluationResultId: string
    type: string
    reason: string
    approved?: boolean | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationExceptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationResult?: EvaluationResultUpdateOneRequiredWithoutExceptionsNestedInput
  }

  export type EvaluationExceptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationResultId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationExceptionCreateManyInput = {
    id?: string
    evaluationResultId: string
    type: string
    reason: string
    approved?: boolean | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationExceptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationExceptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationResultId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationSignatureCreateInput = {
    id?: string
    role: string
    name: string
    signature?: string | null
    comment?: string | null
    signedAt?: Date | string
    tender: TenderCreateNestedOneWithoutSignaturesInput
  }

  export type EvaluationSignatureUncheckedCreateInput = {
    id?: string
    tenderId: string
    role: string
    name: string
    signature?: string | null
    comment?: string | null
    signedAt?: Date | string
  }

  export type EvaluationSignatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tender?: TenderUpdateOneRequiredWithoutSignaturesNestedInput
  }

  export type EvaluationSignatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationSignatureCreateManyInput = {
    id?: string
    tenderId: string
    role: string
    name: string
    signature?: string | null
    comment?: string | null
    signedAt?: Date | string
  }

  export type EvaluationSignatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationSignatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationDocumentCreateInput = {
    id?: string
    runNumber: number
    fileUrl: string
    hash: string
    createdAt?: Date | string
    tender: TenderCreateNestedOneWithoutDocumentsInput
  }

  export type EvaluationDocumentUncheckedCreateInput = {
    id?: string
    tenderId: string
    runNumber: number
    fileUrl: string
    hash: string
    createdAt?: Date | string
  }

  export type EvaluationDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runNumber?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tender?: TenderUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type EvaluationDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    runNumber?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationDocumentCreateManyInput = {
    id?: string
    tenderId: string
    runNumber: number
    fileUrl: string
    hash: string
    createdAt?: Date | string
  }

  export type EvaluationDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    runNumber?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    runNumber?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAccessLogCreateInput = {
    id?: string
    role: string
    endpoint: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAnalyticsLogsInput
  }

  export type AnalyticsAccessLogUncheckedCreateInput = {
    id?: string
    userId: string
    role: string
    endpoint: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AnalyticsAccessLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnalyticsLogsNestedInput
  }

  export type AnalyticsAccessLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAccessLogCreateManyInput = {
    id?: string
    userId: string
    role: string
    endpoint: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AnalyticsAccessLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAccessLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    message: string
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    message: string
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRuleCreateInput = {
    id?: string
    trigger: string
    role: string
    enabled?: boolean
    owner?: UserCreateNestedOneWithoutNotificationRulesInput
  }

  export type NotificationRuleUncheckedCreateInput = {
    id?: string
    trigger: string
    role: string
    enabled?: boolean
    ownerId?: string | null
  }

  export type NotificationRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUpdateOneWithoutNotificationRulesNestedInput
  }

  export type NotificationRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationRuleCreateManyInput = {
    id?: string
    trigger: string
    role: string
    enabled?: boolean
    ownerId?: string | null
  }

  export type NotificationRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenderTimelineEventCreateInput = {
    id?: string
    type: string
    label: string
    createdAt?: Date | string
    tender: TenderCreateNestedOneWithoutTimelineEventsInput
  }

  export type TenderTimelineEventUncheckedCreateInput = {
    id?: string
    tenderId: string
    type: string
    label: string
    createdAt?: Date | string
  }

  export type TenderTimelineEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tender?: TenderUpdateOneRequiredWithoutTimelineEventsNestedInput
  }

  export type TenderTimelineEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenderTimelineEventCreateManyInput = {
    id?: string
    tenderId: string
    type: string
    label: string
    createdAt?: Date | string
  }

  export type TenderTimelineEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenderTimelineEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenderInsightsCreateInput = {
    payload: JsonNullValueInput | InputJsonValue
    tender: TenderCreateNestedOneWithoutInsightsInput
  }

  export type TenderInsightsUncheckedCreateInput = {
    tenderId: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type TenderInsightsUpdateInput = {
    payload?: JsonNullValueInput | InputJsonValue
    tender?: TenderUpdateOneRequiredWithoutInsightsNestedInput
  }

  export type TenderInsightsUncheckedUpdateInput = {
    tenderId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type TenderInsightsCreateManyInput = {
    tenderId: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type TenderInsightsUpdateManyMutationInput = {
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type TenderInsightsUncheckedUpdateManyInput = {
    tenderId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type TenderHeatmapCreateInput = {
    cells: JsonNullValueInput | InputJsonValue
    tender: TenderCreateNestedOneWithoutHeatmapInput
  }

  export type TenderHeatmapUncheckedCreateInput = {
    tenderId: string
    cells: JsonNullValueInput | InputJsonValue
  }

  export type TenderHeatmapUpdateInput = {
    cells?: JsonNullValueInput | InputJsonValue
    tender?: TenderUpdateOneRequiredWithoutHeatmapNestedInput
  }

  export type TenderHeatmapUncheckedUpdateInput = {
    tenderId?: StringFieldUpdateOperationsInput | string
    cells?: JsonNullValueInput | InputJsonValue
  }

  export type TenderHeatmapCreateManyInput = {
    tenderId: string
    cells: JsonNullValueInput | InputJsonValue
  }

  export type TenderHeatmapUpdateManyMutationInput = {
    cells?: JsonNullValueInput | InputJsonValue
  }

  export type TenderHeatmapUncheckedUpdateManyInput = {
    tenderId?: StringFieldUpdateOperationsInput | string
    cells?: JsonNullValueInput | InputJsonValue
  }

  export type BidderIntelligenceCreateInput = {
    timeline: JsonNullValueInput | InputJsonValue
    bidder: BidderCreateNestedOneWithoutIntelligenceInput
  }

  export type BidderIntelligenceUncheckedCreateInput = {
    bidderId: string
    timeline: JsonNullValueInput | InputJsonValue
  }

  export type BidderIntelligenceUpdateInput = {
    timeline?: JsonNullValueInput | InputJsonValue
    bidder?: BidderUpdateOneRequiredWithoutIntelligenceNestedInput
  }

  export type BidderIntelligenceUncheckedUpdateInput = {
    bidderId?: StringFieldUpdateOperationsInput | string
    timeline?: JsonNullValueInput | InputJsonValue
  }

  export type BidderIntelligenceCreateManyInput = {
    bidderId: string
    timeline: JsonNullValueInput | InputJsonValue
  }

  export type BidderIntelligenceUpdateManyMutationInput = {
    timeline?: JsonNullValueInput | InputJsonValue
  }

  export type BidderIntelligenceUncheckedUpdateManyInput = {
    bidderId?: StringFieldUpdateOperationsInput | string
    timeline?: JsonNullValueInput | InputJsonValue
  }

  export type BidderRiskProfileCreateInput = {
    profile: JsonNullValueInput | InputJsonValue
    bidder: BidderCreateNestedOneWithoutRiskProfileInput
  }

  export type BidderRiskProfileUncheckedCreateInput = {
    bidderId: string
    profile: JsonNullValueInput | InputJsonValue
  }

  export type BidderRiskProfileUpdateInput = {
    profile?: JsonNullValueInput | InputJsonValue
    bidder?: BidderUpdateOneRequiredWithoutRiskProfileNestedInput
  }

  export type BidderRiskProfileUncheckedUpdateInput = {
    bidderId?: StringFieldUpdateOperationsInput | string
    profile?: JsonNullValueInput | InputJsonValue
  }

  export type BidderRiskProfileCreateManyInput = {
    bidderId: string
    profile: JsonNullValueInput | InputJsonValue
  }

  export type BidderRiskProfileUpdateManyMutationInput = {
    profile?: JsonNullValueInput | InputJsonValue
  }

  export type BidderRiskProfileUncheckedUpdateManyInput = {
    bidderId?: StringFieldUpdateOperationsInput | string
    profile?: JsonNullValueInput | InputJsonValue
  }

  export type TenderComplianceDashboardCreateInput = {
    payload: JsonNullValueInput | InputJsonValue
    tender: TenderCreateNestedOneWithoutComplianceDashboardInput
  }

  export type TenderComplianceDashboardUncheckedCreateInput = {
    tenderId: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type TenderComplianceDashboardUpdateInput = {
    payload?: JsonNullValueInput | InputJsonValue
    tender?: TenderUpdateOneRequiredWithoutComplianceDashboardNestedInput
  }

  export type TenderComplianceDashboardUncheckedUpdateInput = {
    tenderId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type TenderComplianceDashboardCreateManyInput = {
    tenderId: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type TenderComplianceDashboardUpdateManyMutationInput = {
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type TenderComplianceDashboardUncheckedUpdateManyInput = {
    tenderId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TenantBrandingNullableRelationFilter = {
    is?: TenantBrandingWhereInput | null
    isNot?: TenantBrandingWhereInput | null
  }

  export type TenderListRelationFilter = {
    every?: TenderWhereInput
    some?: TenderWhereInput
    none?: TenderWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TenderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TenantBrandingCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    logoUrl?: SortOrder
    publicName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantBrandingMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    logoUrl?: SortOrder
    publicName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantBrandingMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    logoUrl?: SortOrder
    publicName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type AnalyticsAccessLogListRelationFilter = {
    every?: AnalyticsAccessLogWhereInput
    some?: AnalyticsAccessLogWhereInput
    none?: AnalyticsAccessLogWhereInput
  }

  export type ScmTenderAssignmentListRelationFilter = {
    every?: ScmTenderAssignmentWhereInput
    some?: ScmTenderAssignmentWhereInput
    none?: ScmTenderAssignmentWhereInput
  }

  export type TenantNullableRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationRuleListRelationFilter = {
    every?: NotificationRuleWhereInput
    some?: NotificationRuleWhereInput
    none?: NotificationRuleWhereInput
  }

  export type AnalyticsAccessLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScmTenderAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    tenantId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    tenantId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    tenantId?: SortOrder
  }

  export type TenderRelationFilter = {
    is?: TenderWhereInput
    isNot?: TenderWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ScmTenderAssignmentUserIdTenderIdCompoundUniqueInput = {
    userId: string
    tenderId: string
  }

  export type ScmTenderAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenderId?: SortOrder
    createdAt?: SortOrder
  }

  export type ScmTenderAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenderId?: SortOrder
    createdAt?: SortOrder
  }

  export type ScmTenderAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenderId?: SortOrder
    createdAt?: SortOrder
  }

  export type BidderListRelationFilter = {
    every?: BidderWhereInput
    some?: BidderWhereInput
    none?: BidderWhereInput
  }

  export type EvaluationConfigNullableRelationFilter = {
    is?: EvaluationConfigWhereInput | null
    isNot?: EvaluationConfigWhereInput | null
  }

  export type EvaluationDocumentListRelationFilter = {
    every?: EvaluationDocumentWhereInput
    some?: EvaluationDocumentWhereInput
    none?: EvaluationDocumentWhereInput
  }

  export type EvaluationResultListRelationFilter = {
    every?: EvaluationResultWhereInput
    some?: EvaluationResultWhereInput
    none?: EvaluationResultWhereInput
  }

  export type EvaluationSignatureListRelationFilter = {
    every?: EvaluationSignatureWhereInput
    some?: EvaluationSignatureWhereInput
    none?: EvaluationSignatureWhereInput
  }

  export type TenderTimelineEventListRelationFilter = {
    every?: TenderTimelineEventWhereInput
    some?: TenderTimelineEventWhereInput
    none?: TenderTimelineEventWhereInput
  }

  export type TenderInsightsNullableRelationFilter = {
    is?: TenderInsightsWhereInput | null
    isNot?: TenderInsightsWhereInput | null
  }

  export type TenderHeatmapNullableRelationFilter = {
    is?: TenderHeatmapWhereInput | null
    isNot?: TenderHeatmapWhereInput | null
  }

  export type TenderComplianceDashboardNullableRelationFilter = {
    is?: TenderComplianceDashboardWhereInput | null
    isNot?: TenderComplianceDashboardWhereInput | null
  }

  export type BidderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationSignatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenderTimelineEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenderCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
  }

  export type TenderMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
  }

  export type TenderMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BbbeeNullableRelationFilter = {
    is?: BbbeeWhereInput | null
    isNot?: BbbeeWhereInput | null
  }

  export type BidderCriterionScoreListRelationFilter = {
    every?: BidderCriterionScoreWhereInput
    some?: BidderCriterionScoreWhereInput
    none?: BidderCriterionScoreWhereInput
  }

  export type EvidenceListRelationFilter = {
    every?: EvidenceWhereInput
    some?: EvidenceWhereInput
    none?: EvidenceWhereInput
  }

  export type BidderIntelligenceNullableRelationFilter = {
    is?: BidderIntelligenceWhereInput | null
    isNot?: BidderIntelligenceWhereInput | null
  }

  export type BidderRiskProfileNullableRelationFilter = {
    is?: BidderRiskProfileWhereInput | null
    isNot?: BidderRiskProfileWhereInput | null
  }

  export type BidderCriterionScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvidenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BidderCountOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    disqualified?: SortOrder
    disqualificationReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidderAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type BidderMaxOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    disqualified?: SortOrder
    disqualificationReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidderMinOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    disqualified?: SortOrder
    disqualificationReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidderSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BidderRelationFilter = {
    is?: BidderWhereInput
    isNot?: BidderWhereInput
  }

  export type BbbeeCountOrderByAggregateInput = {
    id?: SortOrder
    bidderId?: SortOrder
    level?: SortOrder
    expiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BbbeeAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type BbbeeMaxOrderByAggregateInput = {
    id?: SortOrder
    bidderId?: SortOrder
    level?: SortOrder
    expiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BbbeeMinOrderByAggregateInput = {
    id?: SortOrder
    bidderId?: SortOrder
    level?: SortOrder
    expiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BbbeeSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EvidenceCountOrderByAggregateInput = {
    id?: SortOrder
    bidderId?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvidenceMaxOrderByAggregateInput = {
    id?: SortOrder
    bidderId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvidenceMinOrderByAggregateInput = {
    id?: SortOrder
    bidderId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EvaluationConfigCountOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    priceWeight?: SortOrder
    bbbeeWeight?: SortOrder
    functionalityPass?: SortOrder
    functionalityMax?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationConfigAvgOrderByAggregateInput = {
    priceWeight?: SortOrder
    bbbeeWeight?: SortOrder
    functionalityPass?: SortOrder
    functionalityMax?: SortOrder
  }

  export type EvaluationConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    priceWeight?: SortOrder
    bbbeeWeight?: SortOrder
    functionalityPass?: SortOrder
    functionalityMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationConfigMinOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    priceWeight?: SortOrder
    bbbeeWeight?: SortOrder
    functionalityPass?: SortOrder
    functionalityMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationConfigSumOrderByAggregateInput = {
    priceWeight?: SortOrder
    bbbeeWeight?: SortOrder
    functionalityPass?: SortOrder
    functionalityMax?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BidderCriterionScoreCountOrderByAggregateInput = {
    id?: SortOrder
    bidderId?: SortOrder
    criterionCode?: SortOrder
    rawScore?: SortOrder
    scaleMax?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidderCriterionScoreAvgOrderByAggregateInput = {
    rawScore?: SortOrder
    scaleMax?: SortOrder
    weight?: SortOrder
  }

  export type BidderCriterionScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    bidderId?: SortOrder
    criterionCode?: SortOrder
    rawScore?: SortOrder
    scaleMax?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidderCriterionScoreMinOrderByAggregateInput = {
    id?: SortOrder
    bidderId?: SortOrder
    criterionCode?: SortOrder
    rawScore?: SortOrder
    scaleMax?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidderCriterionScoreSumOrderByAggregateInput = {
    rawScore?: SortOrder
    scaleMax?: SortOrder
    weight?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ComplianceItemListRelationFilter = {
    every?: ComplianceItemWhereInput
    some?: ComplianceItemWhereInput
    none?: ComplianceItemWhereInput
  }

  export type EvaluationExceptionListRelationFilter = {
    every?: EvaluationExceptionWhereInput
    some?: EvaluationExceptionWhereInput
    none?: EvaluationExceptionWhereInput
  }

  export type WorkflowLogListRelationFilter = {
    every?: WorkflowLogWhereInput
    some?: WorkflowLogWhereInput
    none?: WorkflowLogWhereInput
  }

  export type ComplianceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationExceptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationResultCountOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    bidderId?: SortOrder
    functionalityScore?: SortOrder
    qualifies?: SortOrder
    price?: SortOrder
    priceScore?: SortOrder
    bbbeeLevel?: SortOrder
    bbbeePoints?: SortOrder
    totalScore?: SortOrder
    riskScore?: SortOrder
    complianceRate?: SortOrder
    exceptionsCount?: SortOrder
    slaBreached?: SortOrder
    currentStage?: SortOrder
    createdAt?: SortOrder
    hash?: SortOrder
  }

  export type EvaluationResultAvgOrderByAggregateInput = {
    functionalityScore?: SortOrder
    price?: SortOrder
    priceScore?: SortOrder
    bbbeeLevel?: SortOrder
    bbbeePoints?: SortOrder
    totalScore?: SortOrder
    riskScore?: SortOrder
    complianceRate?: SortOrder
    exceptionsCount?: SortOrder
  }

  export type EvaluationResultMaxOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    bidderId?: SortOrder
    functionalityScore?: SortOrder
    qualifies?: SortOrder
    price?: SortOrder
    priceScore?: SortOrder
    bbbeeLevel?: SortOrder
    bbbeePoints?: SortOrder
    totalScore?: SortOrder
    riskScore?: SortOrder
    complianceRate?: SortOrder
    exceptionsCount?: SortOrder
    slaBreached?: SortOrder
    currentStage?: SortOrder
    createdAt?: SortOrder
    hash?: SortOrder
  }

  export type EvaluationResultMinOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    bidderId?: SortOrder
    functionalityScore?: SortOrder
    qualifies?: SortOrder
    price?: SortOrder
    priceScore?: SortOrder
    bbbeeLevel?: SortOrder
    bbbeePoints?: SortOrder
    totalScore?: SortOrder
    riskScore?: SortOrder
    complianceRate?: SortOrder
    exceptionsCount?: SortOrder
    slaBreached?: SortOrder
    currentStage?: SortOrder
    createdAt?: SortOrder
    hash?: SortOrder
  }

  export type EvaluationResultSumOrderByAggregateInput = {
    functionalityScore?: SortOrder
    price?: SortOrder
    priceScore?: SortOrder
    bbbeeLevel?: SortOrder
    bbbeePoints?: SortOrder
    totalScore?: SortOrder
    riskScore?: SortOrder
    complianceRate?: SortOrder
    exceptionsCount?: SortOrder
  }

  export type EvaluationResultRelationFilter = {
    is?: EvaluationResultWhereInput
    isNot?: EvaluationResultWhereInput
  }

  export type WorkflowLogCountOrderByAggregateInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    stage?: SortOrder
    daysSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowLogAvgOrderByAggregateInput = {
    daysSpent?: SortOrder
  }

  export type WorkflowLogMaxOrderByAggregateInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    stage?: SortOrder
    daysSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowLogMinOrderByAggregateInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    stage?: SortOrder
    daysSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowLogSumOrderByAggregateInput = {
    daysSpent?: SortOrder
  }

  export type ComplianceRuleListRelationFilter = {
    every?: ComplianceRuleWhereInput
    some?: ComplianceRuleWhereInput
    none?: ComplianceRuleWhereInput
  }

  export type ComplianceRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CircularCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircularMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircularMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircularRelationFilter = {
    is?: CircularWhereInput
    isNot?: CircularWhereInput
  }

  export type ComplianceRuleCountOrderByAggregateInput = {
    id?: SortOrder
    circularId?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    circularId?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceRuleMinOrderByAggregateInput = {
    id?: SortOrder
    circularId?: SortOrder
    code?: SortOrder
    label?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceRuleRelationFilter = {
    is?: ComplianceRuleWhereInput
    isNot?: ComplianceRuleWhereInput
  }

  export type ComplianceItemCountOrderByAggregateInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    ruleId?: SortOrder
    compliant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    ruleId?: SortOrder
    compliant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceItemMinOrderByAggregateInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    ruleId?: SortOrder
    compliant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EvaluationExceptionCountOrderByAggregateInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationExceptionMaxOrderByAggregateInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationExceptionMinOrderByAggregateInput = {
    id?: SortOrder
    evaluationResultId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EvaluationSignatureTenderIdRoleCompoundUniqueInput = {
    tenderId: string
    role: string
  }

  export type EvaluationSignatureCountOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    signature?: SortOrder
    comment?: SortOrder
    signedAt?: SortOrder
  }

  export type EvaluationSignatureMaxOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    signature?: SortOrder
    comment?: SortOrder
    signedAt?: SortOrder
  }

  export type EvaluationSignatureMinOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    signature?: SortOrder
    comment?: SortOrder
    signedAt?: SortOrder
  }

  export type EvaluationDocumentTenderIdRunNumberCompoundUniqueInput = {
    tenderId: string
    runNumber: number
  }

  export type EvaluationDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    runNumber?: SortOrder
    fileUrl?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationDocumentAvgOrderByAggregateInput = {
    runNumber?: SortOrder
  }

  export type EvaluationDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    runNumber?: SortOrder
    fileUrl?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    runNumber?: SortOrder
    fileUrl?: SortOrder
    hash?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationDocumentSumOrderByAggregateInput = {
    runNumber?: SortOrder
  }

  export type AnalyticsAccessLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    endpoint?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAccessLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    endpoint?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAccessLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    endpoint?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type NotificationRuleTrigger_roleCompoundUniqueInput = {
    trigger: string
    role: string
  }

  export type NotificationRuleCountOrderByAggregateInput = {
    id?: SortOrder
    trigger?: SortOrder
    role?: SortOrder
    enabled?: SortOrder
    ownerId?: SortOrder
  }

  export type NotificationRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    trigger?: SortOrder
    role?: SortOrder
    enabled?: SortOrder
    ownerId?: SortOrder
  }

  export type NotificationRuleMinOrderByAggregateInput = {
    id?: SortOrder
    trigger?: SortOrder
    role?: SortOrder
    enabled?: SortOrder
    ownerId?: SortOrder
  }

  export type TenderTimelineEventCountOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type TenderTimelineEventMaxOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type TenderTimelineEventMinOrderByAggregateInput = {
    id?: SortOrder
    tenderId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type TenderInsightsCountOrderByAggregateInput = {
    tenderId?: SortOrder
    payload?: SortOrder
  }

  export type TenderInsightsMaxOrderByAggregateInput = {
    tenderId?: SortOrder
  }

  export type TenderInsightsMinOrderByAggregateInput = {
    tenderId?: SortOrder
  }

  export type TenderHeatmapCountOrderByAggregateInput = {
    tenderId?: SortOrder
    cells?: SortOrder
  }

  export type TenderHeatmapMaxOrderByAggregateInput = {
    tenderId?: SortOrder
  }

  export type TenderHeatmapMinOrderByAggregateInput = {
    tenderId?: SortOrder
  }

  export type BidderIntelligenceCountOrderByAggregateInput = {
    bidderId?: SortOrder
    timeline?: SortOrder
  }

  export type BidderIntelligenceMaxOrderByAggregateInput = {
    bidderId?: SortOrder
  }

  export type BidderIntelligenceMinOrderByAggregateInput = {
    bidderId?: SortOrder
  }

  export type BidderRiskProfileCountOrderByAggregateInput = {
    bidderId?: SortOrder
    profile?: SortOrder
  }

  export type BidderRiskProfileMaxOrderByAggregateInput = {
    bidderId?: SortOrder
  }

  export type BidderRiskProfileMinOrderByAggregateInput = {
    bidderId?: SortOrder
  }

  export type TenderComplianceDashboardCountOrderByAggregateInput = {
    tenderId?: SortOrder
    payload?: SortOrder
  }

  export type TenderComplianceDashboardMaxOrderByAggregateInput = {
    tenderId?: SortOrder
  }

  export type TenderComplianceDashboardMinOrderByAggregateInput = {
    tenderId?: SortOrder
  }

  export type TenantBrandingCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantBrandingCreateWithoutTenantInput, TenantBrandingUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantBrandingCreateOrConnectWithoutTenantInput
    connect?: TenantBrandingWhereUniqueInput
  }

  export type TenderCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenderCreateWithoutTenantInput, TenderUncheckedCreateWithoutTenantInput> | TenderCreateWithoutTenantInput[] | TenderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenderCreateOrConnectWithoutTenantInput | TenderCreateOrConnectWithoutTenantInput[]
    createMany?: TenderCreateManyTenantInputEnvelope
    connect?: TenderWhereUniqueInput | TenderWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TenantBrandingUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantBrandingCreateWithoutTenantInput, TenantBrandingUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantBrandingCreateOrConnectWithoutTenantInput
    connect?: TenantBrandingWhereUniqueInput
  }

  export type TenderUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenderCreateWithoutTenantInput, TenderUncheckedCreateWithoutTenantInput> | TenderCreateWithoutTenantInput[] | TenderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenderCreateOrConnectWithoutTenantInput | TenderCreateOrConnectWithoutTenantInput[]
    createMany?: TenderCreateManyTenantInputEnvelope
    connect?: TenderWhereUniqueInput | TenderWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TenantBrandingUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantBrandingCreateWithoutTenantInput, TenantBrandingUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantBrandingCreateOrConnectWithoutTenantInput
    upsert?: TenantBrandingUpsertWithoutTenantInput
    disconnect?: TenantBrandingWhereInput | boolean
    delete?: TenantBrandingWhereInput | boolean
    connect?: TenantBrandingWhereUniqueInput
    update?: XOR<XOR<TenantBrandingUpdateToOneWithWhereWithoutTenantInput, TenantBrandingUpdateWithoutTenantInput>, TenantBrandingUncheckedUpdateWithoutTenantInput>
  }

  export type TenderUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenderCreateWithoutTenantInput, TenderUncheckedCreateWithoutTenantInput> | TenderCreateWithoutTenantInput[] | TenderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenderCreateOrConnectWithoutTenantInput | TenderCreateOrConnectWithoutTenantInput[]
    upsert?: TenderUpsertWithWhereUniqueWithoutTenantInput | TenderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenderCreateManyTenantInputEnvelope
    set?: TenderWhereUniqueInput | TenderWhereUniqueInput[]
    disconnect?: TenderWhereUniqueInput | TenderWhereUniqueInput[]
    delete?: TenderWhereUniqueInput | TenderWhereUniqueInput[]
    connect?: TenderWhereUniqueInput | TenderWhereUniqueInput[]
    update?: TenderUpdateWithWhereUniqueWithoutTenantInput | TenderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenderUpdateManyWithWhereWithoutTenantInput | TenderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenderScalarWhereInput | TenderScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TenantBrandingUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantBrandingCreateWithoutTenantInput, TenantBrandingUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantBrandingCreateOrConnectWithoutTenantInput
    upsert?: TenantBrandingUpsertWithoutTenantInput
    disconnect?: TenantBrandingWhereInput | boolean
    delete?: TenantBrandingWhereInput | boolean
    connect?: TenantBrandingWhereUniqueInput
    update?: XOR<XOR<TenantBrandingUpdateToOneWithWhereWithoutTenantInput, TenantBrandingUpdateWithoutTenantInput>, TenantBrandingUncheckedUpdateWithoutTenantInput>
  }

  export type TenderUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenderCreateWithoutTenantInput, TenderUncheckedCreateWithoutTenantInput> | TenderCreateWithoutTenantInput[] | TenderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenderCreateOrConnectWithoutTenantInput | TenderCreateOrConnectWithoutTenantInput[]
    upsert?: TenderUpsertWithWhereUniqueWithoutTenantInput | TenderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenderCreateManyTenantInputEnvelope
    set?: TenderWhereUniqueInput | TenderWhereUniqueInput[]
    disconnect?: TenderWhereUniqueInput | TenderWhereUniqueInput[]
    delete?: TenderWhereUniqueInput | TenderWhereUniqueInput[]
    connect?: TenderWhereUniqueInput | TenderWhereUniqueInput[]
    update?: TenderUpdateWithWhereUniqueWithoutTenantInput | TenderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenderUpdateManyWithWhereWithoutTenantInput | TenderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenderScalarWhereInput | TenderScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutBrandingInput = {
    create?: XOR<TenantCreateWithoutBrandingInput, TenantUncheckedCreateWithoutBrandingInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBrandingInput
    connect?: TenantWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type TenantUpdateOneRequiredWithoutBrandingNestedInput = {
    create?: XOR<TenantCreateWithoutBrandingInput, TenantUncheckedCreateWithoutBrandingInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBrandingInput
    upsert?: TenantUpsertWithoutBrandingInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBrandingInput, TenantUpdateWithoutBrandingInput>, TenantUncheckedUpdateWithoutBrandingInput>
  }

  export type AnalyticsAccessLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalyticsAccessLogCreateWithoutUserInput, AnalyticsAccessLogUncheckedCreateWithoutUserInput> | AnalyticsAccessLogCreateWithoutUserInput[] | AnalyticsAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsAccessLogCreateOrConnectWithoutUserInput | AnalyticsAccessLogCreateOrConnectWithoutUserInput[]
    createMany?: AnalyticsAccessLogCreateManyUserInputEnvelope
    connect?: AnalyticsAccessLogWhereUniqueInput | AnalyticsAccessLogWhereUniqueInput[]
  }

  export type ScmTenderAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<ScmTenderAssignmentCreateWithoutUserInput, ScmTenderAssignmentUncheckedCreateWithoutUserInput> | ScmTenderAssignmentCreateWithoutUserInput[] | ScmTenderAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScmTenderAssignmentCreateOrConnectWithoutUserInput | ScmTenderAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: ScmTenderAssignmentCreateManyUserInputEnvelope
    connect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationRuleCreateNestedManyWithoutOwnerInput = {
    create?: XOR<NotificationRuleCreateWithoutOwnerInput, NotificationRuleUncheckedCreateWithoutOwnerInput> | NotificationRuleCreateWithoutOwnerInput[] | NotificationRuleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutOwnerInput | NotificationRuleCreateOrConnectWithoutOwnerInput[]
    createMany?: NotificationRuleCreateManyOwnerInputEnvelope
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
  }

  export type AnalyticsAccessLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalyticsAccessLogCreateWithoutUserInput, AnalyticsAccessLogUncheckedCreateWithoutUserInput> | AnalyticsAccessLogCreateWithoutUserInput[] | AnalyticsAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsAccessLogCreateOrConnectWithoutUserInput | AnalyticsAccessLogCreateOrConnectWithoutUserInput[]
    createMany?: AnalyticsAccessLogCreateManyUserInputEnvelope
    connect?: AnalyticsAccessLogWhereUniqueInput | AnalyticsAccessLogWhereUniqueInput[]
  }

  export type ScmTenderAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ScmTenderAssignmentCreateWithoutUserInput, ScmTenderAssignmentUncheckedCreateWithoutUserInput> | ScmTenderAssignmentCreateWithoutUserInput[] | ScmTenderAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScmTenderAssignmentCreateOrConnectWithoutUserInput | ScmTenderAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: ScmTenderAssignmentCreateManyUserInputEnvelope
    connect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationRuleUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<NotificationRuleCreateWithoutOwnerInput, NotificationRuleUncheckedCreateWithoutOwnerInput> | NotificationRuleCreateWithoutOwnerInput[] | NotificationRuleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutOwnerInput | NotificationRuleCreateOrConnectWithoutOwnerInput[]
    createMany?: NotificationRuleCreateManyOwnerInputEnvelope
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
  }

  export type AnalyticsAccessLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalyticsAccessLogCreateWithoutUserInput, AnalyticsAccessLogUncheckedCreateWithoutUserInput> | AnalyticsAccessLogCreateWithoutUserInput[] | AnalyticsAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsAccessLogCreateOrConnectWithoutUserInput | AnalyticsAccessLogCreateOrConnectWithoutUserInput[]
    upsert?: AnalyticsAccessLogUpsertWithWhereUniqueWithoutUserInput | AnalyticsAccessLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalyticsAccessLogCreateManyUserInputEnvelope
    set?: AnalyticsAccessLogWhereUniqueInput | AnalyticsAccessLogWhereUniqueInput[]
    disconnect?: AnalyticsAccessLogWhereUniqueInput | AnalyticsAccessLogWhereUniqueInput[]
    delete?: AnalyticsAccessLogWhereUniqueInput | AnalyticsAccessLogWhereUniqueInput[]
    connect?: AnalyticsAccessLogWhereUniqueInput | AnalyticsAccessLogWhereUniqueInput[]
    update?: AnalyticsAccessLogUpdateWithWhereUniqueWithoutUserInput | AnalyticsAccessLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalyticsAccessLogUpdateManyWithWhereWithoutUserInput | AnalyticsAccessLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalyticsAccessLogScalarWhereInput | AnalyticsAccessLogScalarWhereInput[]
  }

  export type ScmTenderAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScmTenderAssignmentCreateWithoutUserInput, ScmTenderAssignmentUncheckedCreateWithoutUserInput> | ScmTenderAssignmentCreateWithoutUserInput[] | ScmTenderAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScmTenderAssignmentCreateOrConnectWithoutUserInput | ScmTenderAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: ScmTenderAssignmentUpsertWithWhereUniqueWithoutUserInput | ScmTenderAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScmTenderAssignmentCreateManyUserInputEnvelope
    set?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    disconnect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    delete?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    connect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    update?: ScmTenderAssignmentUpdateWithWhereUniqueWithoutUserInput | ScmTenderAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScmTenderAssignmentUpdateManyWithWhereWithoutUserInput | ScmTenderAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScmTenderAssignmentScalarWhereInput | ScmTenderAssignmentScalarWhereInput[]
  }

  export type TenantUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationRuleUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<NotificationRuleCreateWithoutOwnerInput, NotificationRuleUncheckedCreateWithoutOwnerInput> | NotificationRuleCreateWithoutOwnerInput[] | NotificationRuleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutOwnerInput | NotificationRuleCreateOrConnectWithoutOwnerInput[]
    upsert?: NotificationRuleUpsertWithWhereUniqueWithoutOwnerInput | NotificationRuleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: NotificationRuleCreateManyOwnerInputEnvelope
    set?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    disconnect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    delete?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    update?: NotificationRuleUpdateWithWhereUniqueWithoutOwnerInput | NotificationRuleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: NotificationRuleUpdateManyWithWhereWithoutOwnerInput | NotificationRuleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: NotificationRuleScalarWhereInput | NotificationRuleScalarWhereInput[]
  }

  export type AnalyticsAccessLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalyticsAccessLogCreateWithoutUserInput, AnalyticsAccessLogUncheckedCreateWithoutUserInput> | AnalyticsAccessLogCreateWithoutUserInput[] | AnalyticsAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalyticsAccessLogCreateOrConnectWithoutUserInput | AnalyticsAccessLogCreateOrConnectWithoutUserInput[]
    upsert?: AnalyticsAccessLogUpsertWithWhereUniqueWithoutUserInput | AnalyticsAccessLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalyticsAccessLogCreateManyUserInputEnvelope
    set?: AnalyticsAccessLogWhereUniqueInput | AnalyticsAccessLogWhereUniqueInput[]
    disconnect?: AnalyticsAccessLogWhereUniqueInput | AnalyticsAccessLogWhereUniqueInput[]
    delete?: AnalyticsAccessLogWhereUniqueInput | AnalyticsAccessLogWhereUniqueInput[]
    connect?: AnalyticsAccessLogWhereUniqueInput | AnalyticsAccessLogWhereUniqueInput[]
    update?: AnalyticsAccessLogUpdateWithWhereUniqueWithoutUserInput | AnalyticsAccessLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalyticsAccessLogUpdateManyWithWhereWithoutUserInput | AnalyticsAccessLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalyticsAccessLogScalarWhereInput | AnalyticsAccessLogScalarWhereInput[]
  }

  export type ScmTenderAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScmTenderAssignmentCreateWithoutUserInput, ScmTenderAssignmentUncheckedCreateWithoutUserInput> | ScmTenderAssignmentCreateWithoutUserInput[] | ScmTenderAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScmTenderAssignmentCreateOrConnectWithoutUserInput | ScmTenderAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: ScmTenderAssignmentUpsertWithWhereUniqueWithoutUserInput | ScmTenderAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScmTenderAssignmentCreateManyUserInputEnvelope
    set?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    disconnect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    delete?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    connect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    update?: ScmTenderAssignmentUpdateWithWhereUniqueWithoutUserInput | ScmTenderAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScmTenderAssignmentUpdateManyWithWhereWithoutUserInput | ScmTenderAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScmTenderAssignmentScalarWhereInput | ScmTenderAssignmentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationRuleUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<NotificationRuleCreateWithoutOwnerInput, NotificationRuleUncheckedCreateWithoutOwnerInput> | NotificationRuleCreateWithoutOwnerInput[] | NotificationRuleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutOwnerInput | NotificationRuleCreateOrConnectWithoutOwnerInput[]
    upsert?: NotificationRuleUpsertWithWhereUniqueWithoutOwnerInput | NotificationRuleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: NotificationRuleCreateManyOwnerInputEnvelope
    set?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    disconnect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    delete?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    update?: NotificationRuleUpdateWithWhereUniqueWithoutOwnerInput | NotificationRuleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: NotificationRuleUpdateManyWithWhereWithoutOwnerInput | NotificationRuleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: NotificationRuleScalarWhereInput | NotificationRuleScalarWhereInput[]
  }

  export type TenderCreateNestedOneWithoutScmAssignmentsInput = {
    create?: XOR<TenderCreateWithoutScmAssignmentsInput, TenderUncheckedCreateWithoutScmAssignmentsInput>
    connectOrCreate?: TenderCreateOrConnectWithoutScmAssignmentsInput
    connect?: TenderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutScmAssignmentsInput = {
    create?: XOR<UserCreateWithoutScmAssignmentsInput, UserUncheckedCreateWithoutScmAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutScmAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type TenderUpdateOneRequiredWithoutScmAssignmentsNestedInput = {
    create?: XOR<TenderCreateWithoutScmAssignmentsInput, TenderUncheckedCreateWithoutScmAssignmentsInput>
    connectOrCreate?: TenderCreateOrConnectWithoutScmAssignmentsInput
    upsert?: TenderUpsertWithoutScmAssignmentsInput
    connect?: TenderWhereUniqueInput
    update?: XOR<XOR<TenderUpdateToOneWithWhereWithoutScmAssignmentsInput, TenderUpdateWithoutScmAssignmentsInput>, TenderUncheckedUpdateWithoutScmAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutScmAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutScmAssignmentsInput, UserUncheckedCreateWithoutScmAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutScmAssignmentsInput
    upsert?: UserUpsertWithoutScmAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScmAssignmentsInput, UserUpdateWithoutScmAssignmentsInput>, UserUncheckedUpdateWithoutScmAssignmentsInput>
  }

  export type BidderCreateNestedManyWithoutTenderInput = {
    create?: XOR<BidderCreateWithoutTenderInput, BidderUncheckedCreateWithoutTenderInput> | BidderCreateWithoutTenderInput[] | BidderUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: BidderCreateOrConnectWithoutTenderInput | BidderCreateOrConnectWithoutTenderInput[]
    createMany?: BidderCreateManyTenderInputEnvelope
    connect?: BidderWhereUniqueInput | BidderWhereUniqueInput[]
  }

  export type EvaluationConfigCreateNestedOneWithoutTenderInput = {
    create?: XOR<EvaluationConfigCreateWithoutTenderInput, EvaluationConfigUncheckedCreateWithoutTenderInput>
    connectOrCreate?: EvaluationConfigCreateOrConnectWithoutTenderInput
    connect?: EvaluationConfigWhereUniqueInput
  }

  export type EvaluationDocumentCreateNestedManyWithoutTenderInput = {
    create?: XOR<EvaluationDocumentCreateWithoutTenderInput, EvaluationDocumentUncheckedCreateWithoutTenderInput> | EvaluationDocumentCreateWithoutTenderInput[] | EvaluationDocumentUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationDocumentCreateOrConnectWithoutTenderInput | EvaluationDocumentCreateOrConnectWithoutTenderInput[]
    createMany?: EvaluationDocumentCreateManyTenderInputEnvelope
    connect?: EvaluationDocumentWhereUniqueInput | EvaluationDocumentWhereUniqueInput[]
  }

  export type EvaluationResultCreateNestedManyWithoutTenderInput = {
    create?: XOR<EvaluationResultCreateWithoutTenderInput, EvaluationResultUncheckedCreateWithoutTenderInput> | EvaluationResultCreateWithoutTenderInput[] | EvaluationResultUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutTenderInput | EvaluationResultCreateOrConnectWithoutTenderInput[]
    createMany?: EvaluationResultCreateManyTenderInputEnvelope
    connect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
  }

  export type EvaluationSignatureCreateNestedManyWithoutTenderInput = {
    create?: XOR<EvaluationSignatureCreateWithoutTenderInput, EvaluationSignatureUncheckedCreateWithoutTenderInput> | EvaluationSignatureCreateWithoutTenderInput[] | EvaluationSignatureUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationSignatureCreateOrConnectWithoutTenderInput | EvaluationSignatureCreateOrConnectWithoutTenderInput[]
    createMany?: EvaluationSignatureCreateManyTenderInputEnvelope
    connect?: EvaluationSignatureWhereUniqueInput | EvaluationSignatureWhereUniqueInput[]
  }

  export type ScmTenderAssignmentCreateNestedManyWithoutTenderInput = {
    create?: XOR<ScmTenderAssignmentCreateWithoutTenderInput, ScmTenderAssignmentUncheckedCreateWithoutTenderInput> | ScmTenderAssignmentCreateWithoutTenderInput[] | ScmTenderAssignmentUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: ScmTenderAssignmentCreateOrConnectWithoutTenderInput | ScmTenderAssignmentCreateOrConnectWithoutTenderInput[]
    createMany?: ScmTenderAssignmentCreateManyTenderInputEnvelope
    connect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutTendersInput = {
    create?: XOR<TenantCreateWithoutTendersInput, TenantUncheckedCreateWithoutTendersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTendersInput
    connect?: TenantWhereUniqueInput
  }

  export type TenderTimelineEventCreateNestedManyWithoutTenderInput = {
    create?: XOR<TenderTimelineEventCreateWithoutTenderInput, TenderTimelineEventUncheckedCreateWithoutTenderInput> | TenderTimelineEventCreateWithoutTenderInput[] | TenderTimelineEventUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: TenderTimelineEventCreateOrConnectWithoutTenderInput | TenderTimelineEventCreateOrConnectWithoutTenderInput[]
    createMany?: TenderTimelineEventCreateManyTenderInputEnvelope
    connect?: TenderTimelineEventWhereUniqueInput | TenderTimelineEventWhereUniqueInput[]
  }

  export type TenderInsightsCreateNestedOneWithoutTenderInput = {
    create?: XOR<TenderInsightsCreateWithoutTenderInput, TenderInsightsUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderInsightsCreateOrConnectWithoutTenderInput
    connect?: TenderInsightsWhereUniqueInput
  }

  export type TenderHeatmapCreateNestedOneWithoutTenderInput = {
    create?: XOR<TenderHeatmapCreateWithoutTenderInput, TenderHeatmapUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderHeatmapCreateOrConnectWithoutTenderInput
    connect?: TenderHeatmapWhereUniqueInput
  }

  export type TenderComplianceDashboardCreateNestedOneWithoutTenderInput = {
    create?: XOR<TenderComplianceDashboardCreateWithoutTenderInput, TenderComplianceDashboardUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderComplianceDashboardCreateOrConnectWithoutTenderInput
    connect?: TenderComplianceDashboardWhereUniqueInput
  }

  export type BidderUncheckedCreateNestedManyWithoutTenderInput = {
    create?: XOR<BidderCreateWithoutTenderInput, BidderUncheckedCreateWithoutTenderInput> | BidderCreateWithoutTenderInput[] | BidderUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: BidderCreateOrConnectWithoutTenderInput | BidderCreateOrConnectWithoutTenderInput[]
    createMany?: BidderCreateManyTenderInputEnvelope
    connect?: BidderWhereUniqueInput | BidderWhereUniqueInput[]
  }

  export type EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput = {
    create?: XOR<EvaluationConfigCreateWithoutTenderInput, EvaluationConfigUncheckedCreateWithoutTenderInput>
    connectOrCreate?: EvaluationConfigCreateOrConnectWithoutTenderInput
    connect?: EvaluationConfigWhereUniqueInput
  }

  export type EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput = {
    create?: XOR<EvaluationDocumentCreateWithoutTenderInput, EvaluationDocumentUncheckedCreateWithoutTenderInput> | EvaluationDocumentCreateWithoutTenderInput[] | EvaluationDocumentUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationDocumentCreateOrConnectWithoutTenderInput | EvaluationDocumentCreateOrConnectWithoutTenderInput[]
    createMany?: EvaluationDocumentCreateManyTenderInputEnvelope
    connect?: EvaluationDocumentWhereUniqueInput | EvaluationDocumentWhereUniqueInput[]
  }

  export type EvaluationResultUncheckedCreateNestedManyWithoutTenderInput = {
    create?: XOR<EvaluationResultCreateWithoutTenderInput, EvaluationResultUncheckedCreateWithoutTenderInput> | EvaluationResultCreateWithoutTenderInput[] | EvaluationResultUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutTenderInput | EvaluationResultCreateOrConnectWithoutTenderInput[]
    createMany?: EvaluationResultCreateManyTenderInputEnvelope
    connect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
  }

  export type EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput = {
    create?: XOR<EvaluationSignatureCreateWithoutTenderInput, EvaluationSignatureUncheckedCreateWithoutTenderInput> | EvaluationSignatureCreateWithoutTenderInput[] | EvaluationSignatureUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationSignatureCreateOrConnectWithoutTenderInput | EvaluationSignatureCreateOrConnectWithoutTenderInput[]
    createMany?: EvaluationSignatureCreateManyTenderInputEnvelope
    connect?: EvaluationSignatureWhereUniqueInput | EvaluationSignatureWhereUniqueInput[]
  }

  export type ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput = {
    create?: XOR<ScmTenderAssignmentCreateWithoutTenderInput, ScmTenderAssignmentUncheckedCreateWithoutTenderInput> | ScmTenderAssignmentCreateWithoutTenderInput[] | ScmTenderAssignmentUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: ScmTenderAssignmentCreateOrConnectWithoutTenderInput | ScmTenderAssignmentCreateOrConnectWithoutTenderInput[]
    createMany?: ScmTenderAssignmentCreateManyTenderInputEnvelope
    connect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
  }

  export type TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput = {
    create?: XOR<TenderTimelineEventCreateWithoutTenderInput, TenderTimelineEventUncheckedCreateWithoutTenderInput> | TenderTimelineEventCreateWithoutTenderInput[] | TenderTimelineEventUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: TenderTimelineEventCreateOrConnectWithoutTenderInput | TenderTimelineEventCreateOrConnectWithoutTenderInput[]
    createMany?: TenderTimelineEventCreateManyTenderInputEnvelope
    connect?: TenderTimelineEventWhereUniqueInput | TenderTimelineEventWhereUniqueInput[]
  }

  export type TenderInsightsUncheckedCreateNestedOneWithoutTenderInput = {
    create?: XOR<TenderInsightsCreateWithoutTenderInput, TenderInsightsUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderInsightsCreateOrConnectWithoutTenderInput
    connect?: TenderInsightsWhereUniqueInput
  }

  export type TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput = {
    create?: XOR<TenderHeatmapCreateWithoutTenderInput, TenderHeatmapUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderHeatmapCreateOrConnectWithoutTenderInput
    connect?: TenderHeatmapWhereUniqueInput
  }

  export type TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput = {
    create?: XOR<TenderComplianceDashboardCreateWithoutTenderInput, TenderComplianceDashboardUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderComplianceDashboardCreateOrConnectWithoutTenderInput
    connect?: TenderComplianceDashboardWhereUniqueInput
  }

  export type BidderUpdateManyWithoutTenderNestedInput = {
    create?: XOR<BidderCreateWithoutTenderInput, BidderUncheckedCreateWithoutTenderInput> | BidderCreateWithoutTenderInput[] | BidderUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: BidderCreateOrConnectWithoutTenderInput | BidderCreateOrConnectWithoutTenderInput[]
    upsert?: BidderUpsertWithWhereUniqueWithoutTenderInput | BidderUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: BidderCreateManyTenderInputEnvelope
    set?: BidderWhereUniqueInput | BidderWhereUniqueInput[]
    disconnect?: BidderWhereUniqueInput | BidderWhereUniqueInput[]
    delete?: BidderWhereUniqueInput | BidderWhereUniqueInput[]
    connect?: BidderWhereUniqueInput | BidderWhereUniqueInput[]
    update?: BidderUpdateWithWhereUniqueWithoutTenderInput | BidderUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: BidderUpdateManyWithWhereWithoutTenderInput | BidderUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: BidderScalarWhereInput | BidderScalarWhereInput[]
  }

  export type EvaluationConfigUpdateOneWithoutTenderNestedInput = {
    create?: XOR<EvaluationConfigCreateWithoutTenderInput, EvaluationConfigUncheckedCreateWithoutTenderInput>
    connectOrCreate?: EvaluationConfigCreateOrConnectWithoutTenderInput
    upsert?: EvaluationConfigUpsertWithoutTenderInput
    disconnect?: EvaluationConfigWhereInput | boolean
    delete?: EvaluationConfigWhereInput | boolean
    connect?: EvaluationConfigWhereUniqueInput
    update?: XOR<XOR<EvaluationConfigUpdateToOneWithWhereWithoutTenderInput, EvaluationConfigUpdateWithoutTenderInput>, EvaluationConfigUncheckedUpdateWithoutTenderInput>
  }

  export type EvaluationDocumentUpdateManyWithoutTenderNestedInput = {
    create?: XOR<EvaluationDocumentCreateWithoutTenderInput, EvaluationDocumentUncheckedCreateWithoutTenderInput> | EvaluationDocumentCreateWithoutTenderInput[] | EvaluationDocumentUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationDocumentCreateOrConnectWithoutTenderInput | EvaluationDocumentCreateOrConnectWithoutTenderInput[]
    upsert?: EvaluationDocumentUpsertWithWhereUniqueWithoutTenderInput | EvaluationDocumentUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: EvaluationDocumentCreateManyTenderInputEnvelope
    set?: EvaluationDocumentWhereUniqueInput | EvaluationDocumentWhereUniqueInput[]
    disconnect?: EvaluationDocumentWhereUniqueInput | EvaluationDocumentWhereUniqueInput[]
    delete?: EvaluationDocumentWhereUniqueInput | EvaluationDocumentWhereUniqueInput[]
    connect?: EvaluationDocumentWhereUniqueInput | EvaluationDocumentWhereUniqueInput[]
    update?: EvaluationDocumentUpdateWithWhereUniqueWithoutTenderInput | EvaluationDocumentUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: EvaluationDocumentUpdateManyWithWhereWithoutTenderInput | EvaluationDocumentUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: EvaluationDocumentScalarWhereInput | EvaluationDocumentScalarWhereInput[]
  }

  export type EvaluationResultUpdateManyWithoutTenderNestedInput = {
    create?: XOR<EvaluationResultCreateWithoutTenderInput, EvaluationResultUncheckedCreateWithoutTenderInput> | EvaluationResultCreateWithoutTenderInput[] | EvaluationResultUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutTenderInput | EvaluationResultCreateOrConnectWithoutTenderInput[]
    upsert?: EvaluationResultUpsertWithWhereUniqueWithoutTenderInput | EvaluationResultUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: EvaluationResultCreateManyTenderInputEnvelope
    set?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    disconnect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    delete?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    connect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    update?: EvaluationResultUpdateWithWhereUniqueWithoutTenderInput | EvaluationResultUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: EvaluationResultUpdateManyWithWhereWithoutTenderInput | EvaluationResultUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: EvaluationResultScalarWhereInput | EvaluationResultScalarWhereInput[]
  }

  export type EvaluationSignatureUpdateManyWithoutTenderNestedInput = {
    create?: XOR<EvaluationSignatureCreateWithoutTenderInput, EvaluationSignatureUncheckedCreateWithoutTenderInput> | EvaluationSignatureCreateWithoutTenderInput[] | EvaluationSignatureUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationSignatureCreateOrConnectWithoutTenderInput | EvaluationSignatureCreateOrConnectWithoutTenderInput[]
    upsert?: EvaluationSignatureUpsertWithWhereUniqueWithoutTenderInput | EvaluationSignatureUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: EvaluationSignatureCreateManyTenderInputEnvelope
    set?: EvaluationSignatureWhereUniqueInput | EvaluationSignatureWhereUniqueInput[]
    disconnect?: EvaluationSignatureWhereUniqueInput | EvaluationSignatureWhereUniqueInput[]
    delete?: EvaluationSignatureWhereUniqueInput | EvaluationSignatureWhereUniqueInput[]
    connect?: EvaluationSignatureWhereUniqueInput | EvaluationSignatureWhereUniqueInput[]
    update?: EvaluationSignatureUpdateWithWhereUniqueWithoutTenderInput | EvaluationSignatureUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: EvaluationSignatureUpdateManyWithWhereWithoutTenderInput | EvaluationSignatureUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: EvaluationSignatureScalarWhereInput | EvaluationSignatureScalarWhereInput[]
  }

  export type ScmTenderAssignmentUpdateManyWithoutTenderNestedInput = {
    create?: XOR<ScmTenderAssignmentCreateWithoutTenderInput, ScmTenderAssignmentUncheckedCreateWithoutTenderInput> | ScmTenderAssignmentCreateWithoutTenderInput[] | ScmTenderAssignmentUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: ScmTenderAssignmentCreateOrConnectWithoutTenderInput | ScmTenderAssignmentCreateOrConnectWithoutTenderInput[]
    upsert?: ScmTenderAssignmentUpsertWithWhereUniqueWithoutTenderInput | ScmTenderAssignmentUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: ScmTenderAssignmentCreateManyTenderInputEnvelope
    set?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    disconnect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    delete?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    connect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    update?: ScmTenderAssignmentUpdateWithWhereUniqueWithoutTenderInput | ScmTenderAssignmentUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: ScmTenderAssignmentUpdateManyWithWhereWithoutTenderInput | ScmTenderAssignmentUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: ScmTenderAssignmentScalarWhereInput | ScmTenderAssignmentScalarWhereInput[]
  }

  export type TenantUpdateOneWithoutTendersNestedInput = {
    create?: XOR<TenantCreateWithoutTendersInput, TenantUncheckedCreateWithoutTendersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTendersInput
    upsert?: TenantUpsertWithoutTendersInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTendersInput, TenantUpdateWithoutTendersInput>, TenantUncheckedUpdateWithoutTendersInput>
  }

  export type TenderTimelineEventUpdateManyWithoutTenderNestedInput = {
    create?: XOR<TenderTimelineEventCreateWithoutTenderInput, TenderTimelineEventUncheckedCreateWithoutTenderInput> | TenderTimelineEventCreateWithoutTenderInput[] | TenderTimelineEventUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: TenderTimelineEventCreateOrConnectWithoutTenderInput | TenderTimelineEventCreateOrConnectWithoutTenderInput[]
    upsert?: TenderTimelineEventUpsertWithWhereUniqueWithoutTenderInput | TenderTimelineEventUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: TenderTimelineEventCreateManyTenderInputEnvelope
    set?: TenderTimelineEventWhereUniqueInput | TenderTimelineEventWhereUniqueInput[]
    disconnect?: TenderTimelineEventWhereUniqueInput | TenderTimelineEventWhereUniqueInput[]
    delete?: TenderTimelineEventWhereUniqueInput | TenderTimelineEventWhereUniqueInput[]
    connect?: TenderTimelineEventWhereUniqueInput | TenderTimelineEventWhereUniqueInput[]
    update?: TenderTimelineEventUpdateWithWhereUniqueWithoutTenderInput | TenderTimelineEventUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: TenderTimelineEventUpdateManyWithWhereWithoutTenderInput | TenderTimelineEventUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: TenderTimelineEventScalarWhereInput | TenderTimelineEventScalarWhereInput[]
  }

  export type TenderInsightsUpdateOneWithoutTenderNestedInput = {
    create?: XOR<TenderInsightsCreateWithoutTenderInput, TenderInsightsUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderInsightsCreateOrConnectWithoutTenderInput
    upsert?: TenderInsightsUpsertWithoutTenderInput
    disconnect?: TenderInsightsWhereInput | boolean
    delete?: TenderInsightsWhereInput | boolean
    connect?: TenderInsightsWhereUniqueInput
    update?: XOR<XOR<TenderInsightsUpdateToOneWithWhereWithoutTenderInput, TenderInsightsUpdateWithoutTenderInput>, TenderInsightsUncheckedUpdateWithoutTenderInput>
  }

  export type TenderHeatmapUpdateOneWithoutTenderNestedInput = {
    create?: XOR<TenderHeatmapCreateWithoutTenderInput, TenderHeatmapUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderHeatmapCreateOrConnectWithoutTenderInput
    upsert?: TenderHeatmapUpsertWithoutTenderInput
    disconnect?: TenderHeatmapWhereInput | boolean
    delete?: TenderHeatmapWhereInput | boolean
    connect?: TenderHeatmapWhereUniqueInput
    update?: XOR<XOR<TenderHeatmapUpdateToOneWithWhereWithoutTenderInput, TenderHeatmapUpdateWithoutTenderInput>, TenderHeatmapUncheckedUpdateWithoutTenderInput>
  }

  export type TenderComplianceDashboardUpdateOneWithoutTenderNestedInput = {
    create?: XOR<TenderComplianceDashboardCreateWithoutTenderInput, TenderComplianceDashboardUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderComplianceDashboardCreateOrConnectWithoutTenderInput
    upsert?: TenderComplianceDashboardUpsertWithoutTenderInput
    disconnect?: TenderComplianceDashboardWhereInput | boolean
    delete?: TenderComplianceDashboardWhereInput | boolean
    connect?: TenderComplianceDashboardWhereUniqueInput
    update?: XOR<XOR<TenderComplianceDashboardUpdateToOneWithWhereWithoutTenderInput, TenderComplianceDashboardUpdateWithoutTenderInput>, TenderComplianceDashboardUncheckedUpdateWithoutTenderInput>
  }

  export type BidderUncheckedUpdateManyWithoutTenderNestedInput = {
    create?: XOR<BidderCreateWithoutTenderInput, BidderUncheckedCreateWithoutTenderInput> | BidderCreateWithoutTenderInput[] | BidderUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: BidderCreateOrConnectWithoutTenderInput | BidderCreateOrConnectWithoutTenderInput[]
    upsert?: BidderUpsertWithWhereUniqueWithoutTenderInput | BidderUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: BidderCreateManyTenderInputEnvelope
    set?: BidderWhereUniqueInput | BidderWhereUniqueInput[]
    disconnect?: BidderWhereUniqueInput | BidderWhereUniqueInput[]
    delete?: BidderWhereUniqueInput | BidderWhereUniqueInput[]
    connect?: BidderWhereUniqueInput | BidderWhereUniqueInput[]
    update?: BidderUpdateWithWhereUniqueWithoutTenderInput | BidderUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: BidderUpdateManyWithWhereWithoutTenderInput | BidderUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: BidderScalarWhereInput | BidderScalarWhereInput[]
  }

  export type EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput = {
    create?: XOR<EvaluationConfigCreateWithoutTenderInput, EvaluationConfigUncheckedCreateWithoutTenderInput>
    connectOrCreate?: EvaluationConfigCreateOrConnectWithoutTenderInput
    upsert?: EvaluationConfigUpsertWithoutTenderInput
    disconnect?: EvaluationConfigWhereInput | boolean
    delete?: EvaluationConfigWhereInput | boolean
    connect?: EvaluationConfigWhereUniqueInput
    update?: XOR<XOR<EvaluationConfigUpdateToOneWithWhereWithoutTenderInput, EvaluationConfigUpdateWithoutTenderInput>, EvaluationConfigUncheckedUpdateWithoutTenderInput>
  }

  export type EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput = {
    create?: XOR<EvaluationDocumentCreateWithoutTenderInput, EvaluationDocumentUncheckedCreateWithoutTenderInput> | EvaluationDocumentCreateWithoutTenderInput[] | EvaluationDocumentUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationDocumentCreateOrConnectWithoutTenderInput | EvaluationDocumentCreateOrConnectWithoutTenderInput[]
    upsert?: EvaluationDocumentUpsertWithWhereUniqueWithoutTenderInput | EvaluationDocumentUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: EvaluationDocumentCreateManyTenderInputEnvelope
    set?: EvaluationDocumentWhereUniqueInput | EvaluationDocumentWhereUniqueInput[]
    disconnect?: EvaluationDocumentWhereUniqueInput | EvaluationDocumentWhereUniqueInput[]
    delete?: EvaluationDocumentWhereUniqueInput | EvaluationDocumentWhereUniqueInput[]
    connect?: EvaluationDocumentWhereUniqueInput | EvaluationDocumentWhereUniqueInput[]
    update?: EvaluationDocumentUpdateWithWhereUniqueWithoutTenderInput | EvaluationDocumentUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: EvaluationDocumentUpdateManyWithWhereWithoutTenderInput | EvaluationDocumentUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: EvaluationDocumentScalarWhereInput | EvaluationDocumentScalarWhereInput[]
  }

  export type EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput = {
    create?: XOR<EvaluationResultCreateWithoutTenderInput, EvaluationResultUncheckedCreateWithoutTenderInput> | EvaluationResultCreateWithoutTenderInput[] | EvaluationResultUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutTenderInput | EvaluationResultCreateOrConnectWithoutTenderInput[]
    upsert?: EvaluationResultUpsertWithWhereUniqueWithoutTenderInput | EvaluationResultUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: EvaluationResultCreateManyTenderInputEnvelope
    set?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    disconnect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    delete?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    connect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    update?: EvaluationResultUpdateWithWhereUniqueWithoutTenderInput | EvaluationResultUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: EvaluationResultUpdateManyWithWhereWithoutTenderInput | EvaluationResultUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: EvaluationResultScalarWhereInput | EvaluationResultScalarWhereInput[]
  }

  export type EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput = {
    create?: XOR<EvaluationSignatureCreateWithoutTenderInput, EvaluationSignatureUncheckedCreateWithoutTenderInput> | EvaluationSignatureCreateWithoutTenderInput[] | EvaluationSignatureUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: EvaluationSignatureCreateOrConnectWithoutTenderInput | EvaluationSignatureCreateOrConnectWithoutTenderInput[]
    upsert?: EvaluationSignatureUpsertWithWhereUniqueWithoutTenderInput | EvaluationSignatureUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: EvaluationSignatureCreateManyTenderInputEnvelope
    set?: EvaluationSignatureWhereUniqueInput | EvaluationSignatureWhereUniqueInput[]
    disconnect?: EvaluationSignatureWhereUniqueInput | EvaluationSignatureWhereUniqueInput[]
    delete?: EvaluationSignatureWhereUniqueInput | EvaluationSignatureWhereUniqueInput[]
    connect?: EvaluationSignatureWhereUniqueInput | EvaluationSignatureWhereUniqueInput[]
    update?: EvaluationSignatureUpdateWithWhereUniqueWithoutTenderInput | EvaluationSignatureUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: EvaluationSignatureUpdateManyWithWhereWithoutTenderInput | EvaluationSignatureUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: EvaluationSignatureScalarWhereInput | EvaluationSignatureScalarWhereInput[]
  }

  export type ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput = {
    create?: XOR<ScmTenderAssignmentCreateWithoutTenderInput, ScmTenderAssignmentUncheckedCreateWithoutTenderInput> | ScmTenderAssignmentCreateWithoutTenderInput[] | ScmTenderAssignmentUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: ScmTenderAssignmentCreateOrConnectWithoutTenderInput | ScmTenderAssignmentCreateOrConnectWithoutTenderInput[]
    upsert?: ScmTenderAssignmentUpsertWithWhereUniqueWithoutTenderInput | ScmTenderAssignmentUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: ScmTenderAssignmentCreateManyTenderInputEnvelope
    set?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    disconnect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    delete?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    connect?: ScmTenderAssignmentWhereUniqueInput | ScmTenderAssignmentWhereUniqueInput[]
    update?: ScmTenderAssignmentUpdateWithWhereUniqueWithoutTenderInput | ScmTenderAssignmentUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: ScmTenderAssignmentUpdateManyWithWhereWithoutTenderInput | ScmTenderAssignmentUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: ScmTenderAssignmentScalarWhereInput | ScmTenderAssignmentScalarWhereInput[]
  }

  export type TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput = {
    create?: XOR<TenderTimelineEventCreateWithoutTenderInput, TenderTimelineEventUncheckedCreateWithoutTenderInput> | TenderTimelineEventCreateWithoutTenderInput[] | TenderTimelineEventUncheckedCreateWithoutTenderInput[]
    connectOrCreate?: TenderTimelineEventCreateOrConnectWithoutTenderInput | TenderTimelineEventCreateOrConnectWithoutTenderInput[]
    upsert?: TenderTimelineEventUpsertWithWhereUniqueWithoutTenderInput | TenderTimelineEventUpsertWithWhereUniqueWithoutTenderInput[]
    createMany?: TenderTimelineEventCreateManyTenderInputEnvelope
    set?: TenderTimelineEventWhereUniqueInput | TenderTimelineEventWhereUniqueInput[]
    disconnect?: TenderTimelineEventWhereUniqueInput | TenderTimelineEventWhereUniqueInput[]
    delete?: TenderTimelineEventWhereUniqueInput | TenderTimelineEventWhereUniqueInput[]
    connect?: TenderTimelineEventWhereUniqueInput | TenderTimelineEventWhereUniqueInput[]
    update?: TenderTimelineEventUpdateWithWhereUniqueWithoutTenderInput | TenderTimelineEventUpdateWithWhereUniqueWithoutTenderInput[]
    updateMany?: TenderTimelineEventUpdateManyWithWhereWithoutTenderInput | TenderTimelineEventUpdateManyWithWhereWithoutTenderInput[]
    deleteMany?: TenderTimelineEventScalarWhereInput | TenderTimelineEventScalarWhereInput[]
  }

  export type TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput = {
    create?: XOR<TenderInsightsCreateWithoutTenderInput, TenderInsightsUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderInsightsCreateOrConnectWithoutTenderInput
    upsert?: TenderInsightsUpsertWithoutTenderInput
    disconnect?: TenderInsightsWhereInput | boolean
    delete?: TenderInsightsWhereInput | boolean
    connect?: TenderInsightsWhereUniqueInput
    update?: XOR<XOR<TenderInsightsUpdateToOneWithWhereWithoutTenderInput, TenderInsightsUpdateWithoutTenderInput>, TenderInsightsUncheckedUpdateWithoutTenderInput>
  }

  export type TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput = {
    create?: XOR<TenderHeatmapCreateWithoutTenderInput, TenderHeatmapUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderHeatmapCreateOrConnectWithoutTenderInput
    upsert?: TenderHeatmapUpsertWithoutTenderInput
    disconnect?: TenderHeatmapWhereInput | boolean
    delete?: TenderHeatmapWhereInput | boolean
    connect?: TenderHeatmapWhereUniqueInput
    update?: XOR<XOR<TenderHeatmapUpdateToOneWithWhereWithoutTenderInput, TenderHeatmapUpdateWithoutTenderInput>, TenderHeatmapUncheckedUpdateWithoutTenderInput>
  }

  export type TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput = {
    create?: XOR<TenderComplianceDashboardCreateWithoutTenderInput, TenderComplianceDashboardUncheckedCreateWithoutTenderInput>
    connectOrCreate?: TenderComplianceDashboardCreateOrConnectWithoutTenderInput
    upsert?: TenderComplianceDashboardUpsertWithoutTenderInput
    disconnect?: TenderComplianceDashboardWhereInput | boolean
    delete?: TenderComplianceDashboardWhereInput | boolean
    connect?: TenderComplianceDashboardWhereUniqueInput
    update?: XOR<XOR<TenderComplianceDashboardUpdateToOneWithWhereWithoutTenderInput, TenderComplianceDashboardUpdateWithoutTenderInput>, TenderComplianceDashboardUncheckedUpdateWithoutTenderInput>
  }

  export type BbbeeCreateNestedOneWithoutBidderInput = {
    create?: XOR<BbbeeCreateWithoutBidderInput, BbbeeUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BbbeeCreateOrConnectWithoutBidderInput
    connect?: BbbeeWhereUniqueInput
  }

  export type TenderCreateNestedOneWithoutBiddersInput = {
    create?: XOR<TenderCreateWithoutBiddersInput, TenderUncheckedCreateWithoutBiddersInput>
    connectOrCreate?: TenderCreateOrConnectWithoutBiddersInput
    connect?: TenderWhereUniqueInput
  }

  export type BidderCriterionScoreCreateNestedManyWithoutBidderInput = {
    create?: XOR<BidderCriterionScoreCreateWithoutBidderInput, BidderCriterionScoreUncheckedCreateWithoutBidderInput> | BidderCriterionScoreCreateWithoutBidderInput[] | BidderCriterionScoreUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidderCriterionScoreCreateOrConnectWithoutBidderInput | BidderCriterionScoreCreateOrConnectWithoutBidderInput[]
    createMany?: BidderCriterionScoreCreateManyBidderInputEnvelope
    connect?: BidderCriterionScoreWhereUniqueInput | BidderCriterionScoreWhereUniqueInput[]
  }

  export type EvaluationResultCreateNestedManyWithoutBidderInput = {
    create?: XOR<EvaluationResultCreateWithoutBidderInput, EvaluationResultUncheckedCreateWithoutBidderInput> | EvaluationResultCreateWithoutBidderInput[] | EvaluationResultUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutBidderInput | EvaluationResultCreateOrConnectWithoutBidderInput[]
    createMany?: EvaluationResultCreateManyBidderInputEnvelope
    connect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
  }

  export type EvidenceCreateNestedManyWithoutBidderInput = {
    create?: XOR<EvidenceCreateWithoutBidderInput, EvidenceUncheckedCreateWithoutBidderInput> | EvidenceCreateWithoutBidderInput[] | EvidenceUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutBidderInput | EvidenceCreateOrConnectWithoutBidderInput[]
    createMany?: EvidenceCreateManyBidderInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type BidderIntelligenceCreateNestedOneWithoutBidderInput = {
    create?: XOR<BidderIntelligenceCreateWithoutBidderInput, BidderIntelligenceUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BidderIntelligenceCreateOrConnectWithoutBidderInput
    connect?: BidderIntelligenceWhereUniqueInput
  }

  export type BidderRiskProfileCreateNestedOneWithoutBidderInput = {
    create?: XOR<BidderRiskProfileCreateWithoutBidderInput, BidderRiskProfileUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BidderRiskProfileCreateOrConnectWithoutBidderInput
    connect?: BidderRiskProfileWhereUniqueInput
  }

  export type BbbeeUncheckedCreateNestedOneWithoutBidderInput = {
    create?: XOR<BbbeeCreateWithoutBidderInput, BbbeeUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BbbeeCreateOrConnectWithoutBidderInput
    connect?: BbbeeWhereUniqueInput
  }

  export type BidderCriterionScoreUncheckedCreateNestedManyWithoutBidderInput = {
    create?: XOR<BidderCriterionScoreCreateWithoutBidderInput, BidderCriterionScoreUncheckedCreateWithoutBidderInput> | BidderCriterionScoreCreateWithoutBidderInput[] | BidderCriterionScoreUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidderCriterionScoreCreateOrConnectWithoutBidderInput | BidderCriterionScoreCreateOrConnectWithoutBidderInput[]
    createMany?: BidderCriterionScoreCreateManyBidderInputEnvelope
    connect?: BidderCriterionScoreWhereUniqueInput | BidderCriterionScoreWhereUniqueInput[]
  }

  export type EvaluationResultUncheckedCreateNestedManyWithoutBidderInput = {
    create?: XOR<EvaluationResultCreateWithoutBidderInput, EvaluationResultUncheckedCreateWithoutBidderInput> | EvaluationResultCreateWithoutBidderInput[] | EvaluationResultUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutBidderInput | EvaluationResultCreateOrConnectWithoutBidderInput[]
    createMany?: EvaluationResultCreateManyBidderInputEnvelope
    connect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
  }

  export type EvidenceUncheckedCreateNestedManyWithoutBidderInput = {
    create?: XOR<EvidenceCreateWithoutBidderInput, EvidenceUncheckedCreateWithoutBidderInput> | EvidenceCreateWithoutBidderInput[] | EvidenceUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutBidderInput | EvidenceCreateOrConnectWithoutBidderInput[]
    createMany?: EvidenceCreateManyBidderInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type BidderIntelligenceUncheckedCreateNestedOneWithoutBidderInput = {
    create?: XOR<BidderIntelligenceCreateWithoutBidderInput, BidderIntelligenceUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BidderIntelligenceCreateOrConnectWithoutBidderInput
    connect?: BidderIntelligenceWhereUniqueInput
  }

  export type BidderRiskProfileUncheckedCreateNestedOneWithoutBidderInput = {
    create?: XOR<BidderRiskProfileCreateWithoutBidderInput, BidderRiskProfileUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BidderRiskProfileCreateOrConnectWithoutBidderInput
    connect?: BidderRiskProfileWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BbbeeUpdateOneWithoutBidderNestedInput = {
    create?: XOR<BbbeeCreateWithoutBidderInput, BbbeeUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BbbeeCreateOrConnectWithoutBidderInput
    upsert?: BbbeeUpsertWithoutBidderInput
    disconnect?: BbbeeWhereInput | boolean
    delete?: BbbeeWhereInput | boolean
    connect?: BbbeeWhereUniqueInput
    update?: XOR<XOR<BbbeeUpdateToOneWithWhereWithoutBidderInput, BbbeeUpdateWithoutBidderInput>, BbbeeUncheckedUpdateWithoutBidderInput>
  }

  export type TenderUpdateOneRequiredWithoutBiddersNestedInput = {
    create?: XOR<TenderCreateWithoutBiddersInput, TenderUncheckedCreateWithoutBiddersInput>
    connectOrCreate?: TenderCreateOrConnectWithoutBiddersInput
    upsert?: TenderUpsertWithoutBiddersInput
    connect?: TenderWhereUniqueInput
    update?: XOR<XOR<TenderUpdateToOneWithWhereWithoutBiddersInput, TenderUpdateWithoutBiddersInput>, TenderUncheckedUpdateWithoutBiddersInput>
  }

  export type BidderCriterionScoreUpdateManyWithoutBidderNestedInput = {
    create?: XOR<BidderCriterionScoreCreateWithoutBidderInput, BidderCriterionScoreUncheckedCreateWithoutBidderInput> | BidderCriterionScoreCreateWithoutBidderInput[] | BidderCriterionScoreUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidderCriterionScoreCreateOrConnectWithoutBidderInput | BidderCriterionScoreCreateOrConnectWithoutBidderInput[]
    upsert?: BidderCriterionScoreUpsertWithWhereUniqueWithoutBidderInput | BidderCriterionScoreUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: BidderCriterionScoreCreateManyBidderInputEnvelope
    set?: BidderCriterionScoreWhereUniqueInput | BidderCriterionScoreWhereUniqueInput[]
    disconnect?: BidderCriterionScoreWhereUniqueInput | BidderCriterionScoreWhereUniqueInput[]
    delete?: BidderCriterionScoreWhereUniqueInput | BidderCriterionScoreWhereUniqueInput[]
    connect?: BidderCriterionScoreWhereUniqueInput | BidderCriterionScoreWhereUniqueInput[]
    update?: BidderCriterionScoreUpdateWithWhereUniqueWithoutBidderInput | BidderCriterionScoreUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: BidderCriterionScoreUpdateManyWithWhereWithoutBidderInput | BidderCriterionScoreUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: BidderCriterionScoreScalarWhereInput | BidderCriterionScoreScalarWhereInput[]
  }

  export type EvaluationResultUpdateManyWithoutBidderNestedInput = {
    create?: XOR<EvaluationResultCreateWithoutBidderInput, EvaluationResultUncheckedCreateWithoutBidderInput> | EvaluationResultCreateWithoutBidderInput[] | EvaluationResultUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutBidderInput | EvaluationResultCreateOrConnectWithoutBidderInput[]
    upsert?: EvaluationResultUpsertWithWhereUniqueWithoutBidderInput | EvaluationResultUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: EvaluationResultCreateManyBidderInputEnvelope
    set?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    disconnect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    delete?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    connect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    update?: EvaluationResultUpdateWithWhereUniqueWithoutBidderInput | EvaluationResultUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: EvaluationResultUpdateManyWithWhereWithoutBidderInput | EvaluationResultUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: EvaluationResultScalarWhereInput | EvaluationResultScalarWhereInput[]
  }

  export type EvidenceUpdateManyWithoutBidderNestedInput = {
    create?: XOR<EvidenceCreateWithoutBidderInput, EvidenceUncheckedCreateWithoutBidderInput> | EvidenceCreateWithoutBidderInput[] | EvidenceUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutBidderInput | EvidenceCreateOrConnectWithoutBidderInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutBidderInput | EvidenceUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: EvidenceCreateManyBidderInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutBidderInput | EvidenceUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutBidderInput | EvidenceUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type BidderIntelligenceUpdateOneWithoutBidderNestedInput = {
    create?: XOR<BidderIntelligenceCreateWithoutBidderInput, BidderIntelligenceUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BidderIntelligenceCreateOrConnectWithoutBidderInput
    upsert?: BidderIntelligenceUpsertWithoutBidderInput
    disconnect?: BidderIntelligenceWhereInput | boolean
    delete?: BidderIntelligenceWhereInput | boolean
    connect?: BidderIntelligenceWhereUniqueInput
    update?: XOR<XOR<BidderIntelligenceUpdateToOneWithWhereWithoutBidderInput, BidderIntelligenceUpdateWithoutBidderInput>, BidderIntelligenceUncheckedUpdateWithoutBidderInput>
  }

  export type BidderRiskProfileUpdateOneWithoutBidderNestedInput = {
    create?: XOR<BidderRiskProfileCreateWithoutBidderInput, BidderRiskProfileUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BidderRiskProfileCreateOrConnectWithoutBidderInput
    upsert?: BidderRiskProfileUpsertWithoutBidderInput
    disconnect?: BidderRiskProfileWhereInput | boolean
    delete?: BidderRiskProfileWhereInput | boolean
    connect?: BidderRiskProfileWhereUniqueInput
    update?: XOR<XOR<BidderRiskProfileUpdateToOneWithWhereWithoutBidderInput, BidderRiskProfileUpdateWithoutBidderInput>, BidderRiskProfileUncheckedUpdateWithoutBidderInput>
  }

  export type BbbeeUncheckedUpdateOneWithoutBidderNestedInput = {
    create?: XOR<BbbeeCreateWithoutBidderInput, BbbeeUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BbbeeCreateOrConnectWithoutBidderInput
    upsert?: BbbeeUpsertWithoutBidderInput
    disconnect?: BbbeeWhereInput | boolean
    delete?: BbbeeWhereInput | boolean
    connect?: BbbeeWhereUniqueInput
    update?: XOR<XOR<BbbeeUpdateToOneWithWhereWithoutBidderInput, BbbeeUpdateWithoutBidderInput>, BbbeeUncheckedUpdateWithoutBidderInput>
  }

  export type BidderCriterionScoreUncheckedUpdateManyWithoutBidderNestedInput = {
    create?: XOR<BidderCriterionScoreCreateWithoutBidderInput, BidderCriterionScoreUncheckedCreateWithoutBidderInput> | BidderCriterionScoreCreateWithoutBidderInput[] | BidderCriterionScoreUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: BidderCriterionScoreCreateOrConnectWithoutBidderInput | BidderCriterionScoreCreateOrConnectWithoutBidderInput[]
    upsert?: BidderCriterionScoreUpsertWithWhereUniqueWithoutBidderInput | BidderCriterionScoreUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: BidderCriterionScoreCreateManyBidderInputEnvelope
    set?: BidderCriterionScoreWhereUniqueInput | BidderCriterionScoreWhereUniqueInput[]
    disconnect?: BidderCriterionScoreWhereUniqueInput | BidderCriterionScoreWhereUniqueInput[]
    delete?: BidderCriterionScoreWhereUniqueInput | BidderCriterionScoreWhereUniqueInput[]
    connect?: BidderCriterionScoreWhereUniqueInput | BidderCriterionScoreWhereUniqueInput[]
    update?: BidderCriterionScoreUpdateWithWhereUniqueWithoutBidderInput | BidderCriterionScoreUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: BidderCriterionScoreUpdateManyWithWhereWithoutBidderInput | BidderCriterionScoreUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: BidderCriterionScoreScalarWhereInput | BidderCriterionScoreScalarWhereInput[]
  }

  export type EvaluationResultUncheckedUpdateManyWithoutBidderNestedInput = {
    create?: XOR<EvaluationResultCreateWithoutBidderInput, EvaluationResultUncheckedCreateWithoutBidderInput> | EvaluationResultCreateWithoutBidderInput[] | EvaluationResultUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutBidderInput | EvaluationResultCreateOrConnectWithoutBidderInput[]
    upsert?: EvaluationResultUpsertWithWhereUniqueWithoutBidderInput | EvaluationResultUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: EvaluationResultCreateManyBidderInputEnvelope
    set?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    disconnect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    delete?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    connect?: EvaluationResultWhereUniqueInput | EvaluationResultWhereUniqueInput[]
    update?: EvaluationResultUpdateWithWhereUniqueWithoutBidderInput | EvaluationResultUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: EvaluationResultUpdateManyWithWhereWithoutBidderInput | EvaluationResultUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: EvaluationResultScalarWhereInput | EvaluationResultScalarWhereInput[]
  }

  export type EvidenceUncheckedUpdateManyWithoutBidderNestedInput = {
    create?: XOR<EvidenceCreateWithoutBidderInput, EvidenceUncheckedCreateWithoutBidderInput> | EvidenceCreateWithoutBidderInput[] | EvidenceUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutBidderInput | EvidenceCreateOrConnectWithoutBidderInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutBidderInput | EvidenceUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: EvidenceCreateManyBidderInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutBidderInput | EvidenceUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutBidderInput | EvidenceUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type BidderIntelligenceUncheckedUpdateOneWithoutBidderNestedInput = {
    create?: XOR<BidderIntelligenceCreateWithoutBidderInput, BidderIntelligenceUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BidderIntelligenceCreateOrConnectWithoutBidderInput
    upsert?: BidderIntelligenceUpsertWithoutBidderInput
    disconnect?: BidderIntelligenceWhereInput | boolean
    delete?: BidderIntelligenceWhereInput | boolean
    connect?: BidderIntelligenceWhereUniqueInput
    update?: XOR<XOR<BidderIntelligenceUpdateToOneWithWhereWithoutBidderInput, BidderIntelligenceUpdateWithoutBidderInput>, BidderIntelligenceUncheckedUpdateWithoutBidderInput>
  }

  export type BidderRiskProfileUncheckedUpdateOneWithoutBidderNestedInput = {
    create?: XOR<BidderRiskProfileCreateWithoutBidderInput, BidderRiskProfileUncheckedCreateWithoutBidderInput>
    connectOrCreate?: BidderRiskProfileCreateOrConnectWithoutBidderInput
    upsert?: BidderRiskProfileUpsertWithoutBidderInput
    disconnect?: BidderRiskProfileWhereInput | boolean
    delete?: BidderRiskProfileWhereInput | boolean
    connect?: BidderRiskProfileWhereUniqueInput
    update?: XOR<XOR<BidderRiskProfileUpdateToOneWithWhereWithoutBidderInput, BidderRiskProfileUpdateWithoutBidderInput>, BidderRiskProfileUncheckedUpdateWithoutBidderInput>
  }

  export type BidderCreateNestedOneWithoutBbbeeInput = {
    create?: XOR<BidderCreateWithoutBbbeeInput, BidderUncheckedCreateWithoutBbbeeInput>
    connectOrCreate?: BidderCreateOrConnectWithoutBbbeeInput
    connect?: BidderWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BidderUpdateOneRequiredWithoutBbbeeNestedInput = {
    create?: XOR<BidderCreateWithoutBbbeeInput, BidderUncheckedCreateWithoutBbbeeInput>
    connectOrCreate?: BidderCreateOrConnectWithoutBbbeeInput
    upsert?: BidderUpsertWithoutBbbeeInput
    connect?: BidderWhereUniqueInput
    update?: XOR<XOR<BidderUpdateToOneWithWhereWithoutBbbeeInput, BidderUpdateWithoutBbbeeInput>, BidderUncheckedUpdateWithoutBbbeeInput>
  }

  export type BidderCreateNestedOneWithoutEvidenceInput = {
    create?: XOR<BidderCreateWithoutEvidenceInput, BidderUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: BidderCreateOrConnectWithoutEvidenceInput
    connect?: BidderWhereUniqueInput
  }

  export type BidderUpdateOneRequiredWithoutEvidenceNestedInput = {
    create?: XOR<BidderCreateWithoutEvidenceInput, BidderUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: BidderCreateOrConnectWithoutEvidenceInput
    upsert?: BidderUpsertWithoutEvidenceInput
    connect?: BidderWhereUniqueInput
    update?: XOR<XOR<BidderUpdateToOneWithWhereWithoutEvidenceInput, BidderUpdateWithoutEvidenceInput>, BidderUncheckedUpdateWithoutEvidenceInput>
  }

  export type TenderCreateNestedOneWithoutEvaluationConfigInput = {
    create?: XOR<TenderCreateWithoutEvaluationConfigInput, TenderUncheckedCreateWithoutEvaluationConfigInput>
    connectOrCreate?: TenderCreateOrConnectWithoutEvaluationConfigInput
    connect?: TenderWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenderUpdateOneRequiredWithoutEvaluationConfigNestedInput = {
    create?: XOR<TenderCreateWithoutEvaluationConfigInput, TenderUncheckedCreateWithoutEvaluationConfigInput>
    connectOrCreate?: TenderCreateOrConnectWithoutEvaluationConfigInput
    upsert?: TenderUpsertWithoutEvaluationConfigInput
    connect?: TenderWhereUniqueInput
    update?: XOR<XOR<TenderUpdateToOneWithWhereWithoutEvaluationConfigInput, TenderUpdateWithoutEvaluationConfigInput>, TenderUncheckedUpdateWithoutEvaluationConfigInput>
  }

  export type BidderCreateNestedOneWithoutTechnicalScoresInput = {
    create?: XOR<BidderCreateWithoutTechnicalScoresInput, BidderUncheckedCreateWithoutTechnicalScoresInput>
    connectOrCreate?: BidderCreateOrConnectWithoutTechnicalScoresInput
    connect?: BidderWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BidderUpdateOneRequiredWithoutTechnicalScoresNestedInput = {
    create?: XOR<BidderCreateWithoutTechnicalScoresInput, BidderUncheckedCreateWithoutTechnicalScoresInput>
    connectOrCreate?: BidderCreateOrConnectWithoutTechnicalScoresInput
    upsert?: BidderUpsertWithoutTechnicalScoresInput
    connect?: BidderWhereUniqueInput
    update?: XOR<XOR<BidderUpdateToOneWithWhereWithoutTechnicalScoresInput, BidderUpdateWithoutTechnicalScoresInput>, BidderUncheckedUpdateWithoutTechnicalScoresInput>
  }

  export type ComplianceItemCreateNestedManyWithoutEvaluationResultInput = {
    create?: XOR<ComplianceItemCreateWithoutEvaluationResultInput, ComplianceItemUncheckedCreateWithoutEvaluationResultInput> | ComplianceItemCreateWithoutEvaluationResultInput[] | ComplianceItemUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: ComplianceItemCreateOrConnectWithoutEvaluationResultInput | ComplianceItemCreateOrConnectWithoutEvaluationResultInput[]
    createMany?: ComplianceItemCreateManyEvaluationResultInputEnvelope
    connect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
  }

  export type EvaluationExceptionCreateNestedManyWithoutEvaluationResultInput = {
    create?: XOR<EvaluationExceptionCreateWithoutEvaluationResultInput, EvaluationExceptionUncheckedCreateWithoutEvaluationResultInput> | EvaluationExceptionCreateWithoutEvaluationResultInput[] | EvaluationExceptionUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: EvaluationExceptionCreateOrConnectWithoutEvaluationResultInput | EvaluationExceptionCreateOrConnectWithoutEvaluationResultInput[]
    createMany?: EvaluationExceptionCreateManyEvaluationResultInputEnvelope
    connect?: EvaluationExceptionWhereUniqueInput | EvaluationExceptionWhereUniqueInput[]
  }

  export type BidderCreateNestedOneWithoutEvaluationResultsInput = {
    create?: XOR<BidderCreateWithoutEvaluationResultsInput, BidderUncheckedCreateWithoutEvaluationResultsInput>
    connectOrCreate?: BidderCreateOrConnectWithoutEvaluationResultsInput
    connect?: BidderWhereUniqueInput
  }

  export type TenderCreateNestedOneWithoutEvaluationResultsInput = {
    create?: XOR<TenderCreateWithoutEvaluationResultsInput, TenderUncheckedCreateWithoutEvaluationResultsInput>
    connectOrCreate?: TenderCreateOrConnectWithoutEvaluationResultsInput
    connect?: TenderWhereUniqueInput
  }

  export type WorkflowLogCreateNestedManyWithoutEvaluationResultInput = {
    create?: XOR<WorkflowLogCreateWithoutEvaluationResultInput, WorkflowLogUncheckedCreateWithoutEvaluationResultInput> | WorkflowLogCreateWithoutEvaluationResultInput[] | WorkflowLogUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: WorkflowLogCreateOrConnectWithoutEvaluationResultInput | WorkflowLogCreateOrConnectWithoutEvaluationResultInput[]
    createMany?: WorkflowLogCreateManyEvaluationResultInputEnvelope
    connect?: WorkflowLogWhereUniqueInput | WorkflowLogWhereUniqueInput[]
  }

  export type ComplianceItemUncheckedCreateNestedManyWithoutEvaluationResultInput = {
    create?: XOR<ComplianceItemCreateWithoutEvaluationResultInput, ComplianceItemUncheckedCreateWithoutEvaluationResultInput> | ComplianceItemCreateWithoutEvaluationResultInput[] | ComplianceItemUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: ComplianceItemCreateOrConnectWithoutEvaluationResultInput | ComplianceItemCreateOrConnectWithoutEvaluationResultInput[]
    createMany?: ComplianceItemCreateManyEvaluationResultInputEnvelope
    connect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
  }

  export type EvaluationExceptionUncheckedCreateNestedManyWithoutEvaluationResultInput = {
    create?: XOR<EvaluationExceptionCreateWithoutEvaluationResultInput, EvaluationExceptionUncheckedCreateWithoutEvaluationResultInput> | EvaluationExceptionCreateWithoutEvaluationResultInput[] | EvaluationExceptionUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: EvaluationExceptionCreateOrConnectWithoutEvaluationResultInput | EvaluationExceptionCreateOrConnectWithoutEvaluationResultInput[]
    createMany?: EvaluationExceptionCreateManyEvaluationResultInputEnvelope
    connect?: EvaluationExceptionWhereUniqueInput | EvaluationExceptionWhereUniqueInput[]
  }

  export type WorkflowLogUncheckedCreateNestedManyWithoutEvaluationResultInput = {
    create?: XOR<WorkflowLogCreateWithoutEvaluationResultInput, WorkflowLogUncheckedCreateWithoutEvaluationResultInput> | WorkflowLogCreateWithoutEvaluationResultInput[] | WorkflowLogUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: WorkflowLogCreateOrConnectWithoutEvaluationResultInput | WorkflowLogCreateOrConnectWithoutEvaluationResultInput[]
    createMany?: WorkflowLogCreateManyEvaluationResultInputEnvelope
    connect?: WorkflowLogWhereUniqueInput | WorkflowLogWhereUniqueInput[]
  }

  export type ComplianceItemUpdateManyWithoutEvaluationResultNestedInput = {
    create?: XOR<ComplianceItemCreateWithoutEvaluationResultInput, ComplianceItemUncheckedCreateWithoutEvaluationResultInput> | ComplianceItemCreateWithoutEvaluationResultInput[] | ComplianceItemUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: ComplianceItemCreateOrConnectWithoutEvaluationResultInput | ComplianceItemCreateOrConnectWithoutEvaluationResultInput[]
    upsert?: ComplianceItemUpsertWithWhereUniqueWithoutEvaluationResultInput | ComplianceItemUpsertWithWhereUniqueWithoutEvaluationResultInput[]
    createMany?: ComplianceItemCreateManyEvaluationResultInputEnvelope
    set?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    disconnect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    delete?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    connect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    update?: ComplianceItemUpdateWithWhereUniqueWithoutEvaluationResultInput | ComplianceItemUpdateWithWhereUniqueWithoutEvaluationResultInput[]
    updateMany?: ComplianceItemUpdateManyWithWhereWithoutEvaluationResultInput | ComplianceItemUpdateManyWithWhereWithoutEvaluationResultInput[]
    deleteMany?: ComplianceItemScalarWhereInput | ComplianceItemScalarWhereInput[]
  }

  export type EvaluationExceptionUpdateManyWithoutEvaluationResultNestedInput = {
    create?: XOR<EvaluationExceptionCreateWithoutEvaluationResultInput, EvaluationExceptionUncheckedCreateWithoutEvaluationResultInput> | EvaluationExceptionCreateWithoutEvaluationResultInput[] | EvaluationExceptionUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: EvaluationExceptionCreateOrConnectWithoutEvaluationResultInput | EvaluationExceptionCreateOrConnectWithoutEvaluationResultInput[]
    upsert?: EvaluationExceptionUpsertWithWhereUniqueWithoutEvaluationResultInput | EvaluationExceptionUpsertWithWhereUniqueWithoutEvaluationResultInput[]
    createMany?: EvaluationExceptionCreateManyEvaluationResultInputEnvelope
    set?: EvaluationExceptionWhereUniqueInput | EvaluationExceptionWhereUniqueInput[]
    disconnect?: EvaluationExceptionWhereUniqueInput | EvaluationExceptionWhereUniqueInput[]
    delete?: EvaluationExceptionWhereUniqueInput | EvaluationExceptionWhereUniqueInput[]
    connect?: EvaluationExceptionWhereUniqueInput | EvaluationExceptionWhereUniqueInput[]
    update?: EvaluationExceptionUpdateWithWhereUniqueWithoutEvaluationResultInput | EvaluationExceptionUpdateWithWhereUniqueWithoutEvaluationResultInput[]
    updateMany?: EvaluationExceptionUpdateManyWithWhereWithoutEvaluationResultInput | EvaluationExceptionUpdateManyWithWhereWithoutEvaluationResultInput[]
    deleteMany?: EvaluationExceptionScalarWhereInput | EvaluationExceptionScalarWhereInput[]
  }

  export type BidderUpdateOneRequiredWithoutEvaluationResultsNestedInput = {
    create?: XOR<BidderCreateWithoutEvaluationResultsInput, BidderUncheckedCreateWithoutEvaluationResultsInput>
    connectOrCreate?: BidderCreateOrConnectWithoutEvaluationResultsInput
    upsert?: BidderUpsertWithoutEvaluationResultsInput
    connect?: BidderWhereUniqueInput
    update?: XOR<XOR<BidderUpdateToOneWithWhereWithoutEvaluationResultsInput, BidderUpdateWithoutEvaluationResultsInput>, BidderUncheckedUpdateWithoutEvaluationResultsInput>
  }

  export type TenderUpdateOneRequiredWithoutEvaluationResultsNestedInput = {
    create?: XOR<TenderCreateWithoutEvaluationResultsInput, TenderUncheckedCreateWithoutEvaluationResultsInput>
    connectOrCreate?: TenderCreateOrConnectWithoutEvaluationResultsInput
    upsert?: TenderUpsertWithoutEvaluationResultsInput
    connect?: TenderWhereUniqueInput
    update?: XOR<XOR<TenderUpdateToOneWithWhereWithoutEvaluationResultsInput, TenderUpdateWithoutEvaluationResultsInput>, TenderUncheckedUpdateWithoutEvaluationResultsInput>
  }

  export type WorkflowLogUpdateManyWithoutEvaluationResultNestedInput = {
    create?: XOR<WorkflowLogCreateWithoutEvaluationResultInput, WorkflowLogUncheckedCreateWithoutEvaluationResultInput> | WorkflowLogCreateWithoutEvaluationResultInput[] | WorkflowLogUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: WorkflowLogCreateOrConnectWithoutEvaluationResultInput | WorkflowLogCreateOrConnectWithoutEvaluationResultInput[]
    upsert?: WorkflowLogUpsertWithWhereUniqueWithoutEvaluationResultInput | WorkflowLogUpsertWithWhereUniqueWithoutEvaluationResultInput[]
    createMany?: WorkflowLogCreateManyEvaluationResultInputEnvelope
    set?: WorkflowLogWhereUniqueInput | WorkflowLogWhereUniqueInput[]
    disconnect?: WorkflowLogWhereUniqueInput | WorkflowLogWhereUniqueInput[]
    delete?: WorkflowLogWhereUniqueInput | WorkflowLogWhereUniqueInput[]
    connect?: WorkflowLogWhereUniqueInput | WorkflowLogWhereUniqueInput[]
    update?: WorkflowLogUpdateWithWhereUniqueWithoutEvaluationResultInput | WorkflowLogUpdateWithWhereUniqueWithoutEvaluationResultInput[]
    updateMany?: WorkflowLogUpdateManyWithWhereWithoutEvaluationResultInput | WorkflowLogUpdateManyWithWhereWithoutEvaluationResultInput[]
    deleteMany?: WorkflowLogScalarWhereInput | WorkflowLogScalarWhereInput[]
  }

  export type ComplianceItemUncheckedUpdateManyWithoutEvaluationResultNestedInput = {
    create?: XOR<ComplianceItemCreateWithoutEvaluationResultInput, ComplianceItemUncheckedCreateWithoutEvaluationResultInput> | ComplianceItemCreateWithoutEvaluationResultInput[] | ComplianceItemUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: ComplianceItemCreateOrConnectWithoutEvaluationResultInput | ComplianceItemCreateOrConnectWithoutEvaluationResultInput[]
    upsert?: ComplianceItemUpsertWithWhereUniqueWithoutEvaluationResultInput | ComplianceItemUpsertWithWhereUniqueWithoutEvaluationResultInput[]
    createMany?: ComplianceItemCreateManyEvaluationResultInputEnvelope
    set?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    disconnect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    delete?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    connect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    update?: ComplianceItemUpdateWithWhereUniqueWithoutEvaluationResultInput | ComplianceItemUpdateWithWhereUniqueWithoutEvaluationResultInput[]
    updateMany?: ComplianceItemUpdateManyWithWhereWithoutEvaluationResultInput | ComplianceItemUpdateManyWithWhereWithoutEvaluationResultInput[]
    deleteMany?: ComplianceItemScalarWhereInput | ComplianceItemScalarWhereInput[]
  }

  export type EvaluationExceptionUncheckedUpdateManyWithoutEvaluationResultNestedInput = {
    create?: XOR<EvaluationExceptionCreateWithoutEvaluationResultInput, EvaluationExceptionUncheckedCreateWithoutEvaluationResultInput> | EvaluationExceptionCreateWithoutEvaluationResultInput[] | EvaluationExceptionUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: EvaluationExceptionCreateOrConnectWithoutEvaluationResultInput | EvaluationExceptionCreateOrConnectWithoutEvaluationResultInput[]
    upsert?: EvaluationExceptionUpsertWithWhereUniqueWithoutEvaluationResultInput | EvaluationExceptionUpsertWithWhereUniqueWithoutEvaluationResultInput[]
    createMany?: EvaluationExceptionCreateManyEvaluationResultInputEnvelope
    set?: EvaluationExceptionWhereUniqueInput | EvaluationExceptionWhereUniqueInput[]
    disconnect?: EvaluationExceptionWhereUniqueInput | EvaluationExceptionWhereUniqueInput[]
    delete?: EvaluationExceptionWhereUniqueInput | EvaluationExceptionWhereUniqueInput[]
    connect?: EvaluationExceptionWhereUniqueInput | EvaluationExceptionWhereUniqueInput[]
    update?: EvaluationExceptionUpdateWithWhereUniqueWithoutEvaluationResultInput | EvaluationExceptionUpdateWithWhereUniqueWithoutEvaluationResultInput[]
    updateMany?: EvaluationExceptionUpdateManyWithWhereWithoutEvaluationResultInput | EvaluationExceptionUpdateManyWithWhereWithoutEvaluationResultInput[]
    deleteMany?: EvaluationExceptionScalarWhereInput | EvaluationExceptionScalarWhereInput[]
  }

  export type WorkflowLogUncheckedUpdateManyWithoutEvaluationResultNestedInput = {
    create?: XOR<WorkflowLogCreateWithoutEvaluationResultInput, WorkflowLogUncheckedCreateWithoutEvaluationResultInput> | WorkflowLogCreateWithoutEvaluationResultInput[] | WorkflowLogUncheckedCreateWithoutEvaluationResultInput[]
    connectOrCreate?: WorkflowLogCreateOrConnectWithoutEvaluationResultInput | WorkflowLogCreateOrConnectWithoutEvaluationResultInput[]
    upsert?: WorkflowLogUpsertWithWhereUniqueWithoutEvaluationResultInput | WorkflowLogUpsertWithWhereUniqueWithoutEvaluationResultInput[]
    createMany?: WorkflowLogCreateManyEvaluationResultInputEnvelope
    set?: WorkflowLogWhereUniqueInput | WorkflowLogWhereUniqueInput[]
    disconnect?: WorkflowLogWhereUniqueInput | WorkflowLogWhereUniqueInput[]
    delete?: WorkflowLogWhereUniqueInput | WorkflowLogWhereUniqueInput[]
    connect?: WorkflowLogWhereUniqueInput | WorkflowLogWhereUniqueInput[]
    update?: WorkflowLogUpdateWithWhereUniqueWithoutEvaluationResultInput | WorkflowLogUpdateWithWhereUniqueWithoutEvaluationResultInput[]
    updateMany?: WorkflowLogUpdateManyWithWhereWithoutEvaluationResultInput | WorkflowLogUpdateManyWithWhereWithoutEvaluationResultInput[]
    deleteMany?: WorkflowLogScalarWhereInput | WorkflowLogScalarWhereInput[]
  }

  export type EvaluationResultCreateNestedOneWithoutWorkflowLogsInput = {
    create?: XOR<EvaluationResultCreateWithoutWorkflowLogsInput, EvaluationResultUncheckedCreateWithoutWorkflowLogsInput>
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutWorkflowLogsInput
    connect?: EvaluationResultWhereUniqueInput
  }

  export type EvaluationResultUpdateOneRequiredWithoutWorkflowLogsNestedInput = {
    create?: XOR<EvaluationResultCreateWithoutWorkflowLogsInput, EvaluationResultUncheckedCreateWithoutWorkflowLogsInput>
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutWorkflowLogsInput
    upsert?: EvaluationResultUpsertWithoutWorkflowLogsInput
    connect?: EvaluationResultWhereUniqueInput
    update?: XOR<XOR<EvaluationResultUpdateToOneWithWhereWithoutWorkflowLogsInput, EvaluationResultUpdateWithoutWorkflowLogsInput>, EvaluationResultUncheckedUpdateWithoutWorkflowLogsInput>
  }

  export type ComplianceRuleCreateNestedManyWithoutCircularInput = {
    create?: XOR<ComplianceRuleCreateWithoutCircularInput, ComplianceRuleUncheckedCreateWithoutCircularInput> | ComplianceRuleCreateWithoutCircularInput[] | ComplianceRuleUncheckedCreateWithoutCircularInput[]
    connectOrCreate?: ComplianceRuleCreateOrConnectWithoutCircularInput | ComplianceRuleCreateOrConnectWithoutCircularInput[]
    createMany?: ComplianceRuleCreateManyCircularInputEnvelope
    connect?: ComplianceRuleWhereUniqueInput | ComplianceRuleWhereUniqueInput[]
  }

  export type ComplianceRuleUncheckedCreateNestedManyWithoutCircularInput = {
    create?: XOR<ComplianceRuleCreateWithoutCircularInput, ComplianceRuleUncheckedCreateWithoutCircularInput> | ComplianceRuleCreateWithoutCircularInput[] | ComplianceRuleUncheckedCreateWithoutCircularInput[]
    connectOrCreate?: ComplianceRuleCreateOrConnectWithoutCircularInput | ComplianceRuleCreateOrConnectWithoutCircularInput[]
    createMany?: ComplianceRuleCreateManyCircularInputEnvelope
    connect?: ComplianceRuleWhereUniqueInput | ComplianceRuleWhereUniqueInput[]
  }

  export type ComplianceRuleUpdateManyWithoutCircularNestedInput = {
    create?: XOR<ComplianceRuleCreateWithoutCircularInput, ComplianceRuleUncheckedCreateWithoutCircularInput> | ComplianceRuleCreateWithoutCircularInput[] | ComplianceRuleUncheckedCreateWithoutCircularInput[]
    connectOrCreate?: ComplianceRuleCreateOrConnectWithoutCircularInput | ComplianceRuleCreateOrConnectWithoutCircularInput[]
    upsert?: ComplianceRuleUpsertWithWhereUniqueWithoutCircularInput | ComplianceRuleUpsertWithWhereUniqueWithoutCircularInput[]
    createMany?: ComplianceRuleCreateManyCircularInputEnvelope
    set?: ComplianceRuleWhereUniqueInput | ComplianceRuleWhereUniqueInput[]
    disconnect?: ComplianceRuleWhereUniqueInput | ComplianceRuleWhereUniqueInput[]
    delete?: ComplianceRuleWhereUniqueInput | ComplianceRuleWhereUniqueInput[]
    connect?: ComplianceRuleWhereUniqueInput | ComplianceRuleWhereUniqueInput[]
    update?: ComplianceRuleUpdateWithWhereUniqueWithoutCircularInput | ComplianceRuleUpdateWithWhereUniqueWithoutCircularInput[]
    updateMany?: ComplianceRuleUpdateManyWithWhereWithoutCircularInput | ComplianceRuleUpdateManyWithWhereWithoutCircularInput[]
    deleteMany?: ComplianceRuleScalarWhereInput | ComplianceRuleScalarWhereInput[]
  }

  export type ComplianceRuleUncheckedUpdateManyWithoutCircularNestedInput = {
    create?: XOR<ComplianceRuleCreateWithoutCircularInput, ComplianceRuleUncheckedCreateWithoutCircularInput> | ComplianceRuleCreateWithoutCircularInput[] | ComplianceRuleUncheckedCreateWithoutCircularInput[]
    connectOrCreate?: ComplianceRuleCreateOrConnectWithoutCircularInput | ComplianceRuleCreateOrConnectWithoutCircularInput[]
    upsert?: ComplianceRuleUpsertWithWhereUniqueWithoutCircularInput | ComplianceRuleUpsertWithWhereUniqueWithoutCircularInput[]
    createMany?: ComplianceRuleCreateManyCircularInputEnvelope
    set?: ComplianceRuleWhereUniqueInput | ComplianceRuleWhereUniqueInput[]
    disconnect?: ComplianceRuleWhereUniqueInput | ComplianceRuleWhereUniqueInput[]
    delete?: ComplianceRuleWhereUniqueInput | ComplianceRuleWhereUniqueInput[]
    connect?: ComplianceRuleWhereUniqueInput | ComplianceRuleWhereUniqueInput[]
    update?: ComplianceRuleUpdateWithWhereUniqueWithoutCircularInput | ComplianceRuleUpdateWithWhereUniqueWithoutCircularInput[]
    updateMany?: ComplianceRuleUpdateManyWithWhereWithoutCircularInput | ComplianceRuleUpdateManyWithWhereWithoutCircularInput[]
    deleteMany?: ComplianceRuleScalarWhereInput | ComplianceRuleScalarWhereInput[]
  }

  export type ComplianceItemCreateNestedManyWithoutRuleInput = {
    create?: XOR<ComplianceItemCreateWithoutRuleInput, ComplianceItemUncheckedCreateWithoutRuleInput> | ComplianceItemCreateWithoutRuleInput[] | ComplianceItemUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: ComplianceItemCreateOrConnectWithoutRuleInput | ComplianceItemCreateOrConnectWithoutRuleInput[]
    createMany?: ComplianceItemCreateManyRuleInputEnvelope
    connect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
  }

  export type CircularCreateNestedOneWithoutRulesInput = {
    create?: XOR<CircularCreateWithoutRulesInput, CircularUncheckedCreateWithoutRulesInput>
    connectOrCreate?: CircularCreateOrConnectWithoutRulesInput
    connect?: CircularWhereUniqueInput
  }

  export type ComplianceItemUncheckedCreateNestedManyWithoutRuleInput = {
    create?: XOR<ComplianceItemCreateWithoutRuleInput, ComplianceItemUncheckedCreateWithoutRuleInput> | ComplianceItemCreateWithoutRuleInput[] | ComplianceItemUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: ComplianceItemCreateOrConnectWithoutRuleInput | ComplianceItemCreateOrConnectWithoutRuleInput[]
    createMany?: ComplianceItemCreateManyRuleInputEnvelope
    connect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
  }

  export type ComplianceItemUpdateManyWithoutRuleNestedInput = {
    create?: XOR<ComplianceItemCreateWithoutRuleInput, ComplianceItemUncheckedCreateWithoutRuleInput> | ComplianceItemCreateWithoutRuleInput[] | ComplianceItemUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: ComplianceItemCreateOrConnectWithoutRuleInput | ComplianceItemCreateOrConnectWithoutRuleInput[]
    upsert?: ComplianceItemUpsertWithWhereUniqueWithoutRuleInput | ComplianceItemUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: ComplianceItemCreateManyRuleInputEnvelope
    set?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    disconnect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    delete?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    connect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    update?: ComplianceItemUpdateWithWhereUniqueWithoutRuleInput | ComplianceItemUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: ComplianceItemUpdateManyWithWhereWithoutRuleInput | ComplianceItemUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: ComplianceItemScalarWhereInput | ComplianceItemScalarWhereInput[]
  }

  export type CircularUpdateOneRequiredWithoutRulesNestedInput = {
    create?: XOR<CircularCreateWithoutRulesInput, CircularUncheckedCreateWithoutRulesInput>
    connectOrCreate?: CircularCreateOrConnectWithoutRulesInput
    upsert?: CircularUpsertWithoutRulesInput
    connect?: CircularWhereUniqueInput
    update?: XOR<XOR<CircularUpdateToOneWithWhereWithoutRulesInput, CircularUpdateWithoutRulesInput>, CircularUncheckedUpdateWithoutRulesInput>
  }

  export type ComplianceItemUncheckedUpdateManyWithoutRuleNestedInput = {
    create?: XOR<ComplianceItemCreateWithoutRuleInput, ComplianceItemUncheckedCreateWithoutRuleInput> | ComplianceItemCreateWithoutRuleInput[] | ComplianceItemUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: ComplianceItemCreateOrConnectWithoutRuleInput | ComplianceItemCreateOrConnectWithoutRuleInput[]
    upsert?: ComplianceItemUpsertWithWhereUniqueWithoutRuleInput | ComplianceItemUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: ComplianceItemCreateManyRuleInputEnvelope
    set?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    disconnect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    delete?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    connect?: ComplianceItemWhereUniqueInput | ComplianceItemWhereUniqueInput[]
    update?: ComplianceItemUpdateWithWhereUniqueWithoutRuleInput | ComplianceItemUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: ComplianceItemUpdateManyWithWhereWithoutRuleInput | ComplianceItemUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: ComplianceItemScalarWhereInput | ComplianceItemScalarWhereInput[]
  }

  export type EvaluationResultCreateNestedOneWithoutComplianceInput = {
    create?: XOR<EvaluationResultCreateWithoutComplianceInput, EvaluationResultUncheckedCreateWithoutComplianceInput>
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutComplianceInput
    connect?: EvaluationResultWhereUniqueInput
  }

  export type ComplianceRuleCreateNestedOneWithoutItemsInput = {
    create?: XOR<ComplianceRuleCreateWithoutItemsInput, ComplianceRuleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ComplianceRuleCreateOrConnectWithoutItemsInput
    connect?: ComplianceRuleWhereUniqueInput
  }

  export type EvaluationResultUpdateOneRequiredWithoutComplianceNestedInput = {
    create?: XOR<EvaluationResultCreateWithoutComplianceInput, EvaluationResultUncheckedCreateWithoutComplianceInput>
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutComplianceInput
    upsert?: EvaluationResultUpsertWithoutComplianceInput
    connect?: EvaluationResultWhereUniqueInput
    update?: XOR<XOR<EvaluationResultUpdateToOneWithWhereWithoutComplianceInput, EvaluationResultUpdateWithoutComplianceInput>, EvaluationResultUncheckedUpdateWithoutComplianceInput>
  }

  export type ComplianceRuleUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ComplianceRuleCreateWithoutItemsInput, ComplianceRuleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ComplianceRuleCreateOrConnectWithoutItemsInput
    upsert?: ComplianceRuleUpsertWithoutItemsInput
    connect?: ComplianceRuleWhereUniqueInput
    update?: XOR<XOR<ComplianceRuleUpdateToOneWithWhereWithoutItemsInput, ComplianceRuleUpdateWithoutItemsInput>, ComplianceRuleUncheckedUpdateWithoutItemsInput>
  }

  export type EvaluationResultCreateNestedOneWithoutExceptionsInput = {
    create?: XOR<EvaluationResultCreateWithoutExceptionsInput, EvaluationResultUncheckedCreateWithoutExceptionsInput>
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutExceptionsInput
    connect?: EvaluationResultWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EvaluationResultUpdateOneRequiredWithoutExceptionsNestedInput = {
    create?: XOR<EvaluationResultCreateWithoutExceptionsInput, EvaluationResultUncheckedCreateWithoutExceptionsInput>
    connectOrCreate?: EvaluationResultCreateOrConnectWithoutExceptionsInput
    upsert?: EvaluationResultUpsertWithoutExceptionsInput
    connect?: EvaluationResultWhereUniqueInput
    update?: XOR<XOR<EvaluationResultUpdateToOneWithWhereWithoutExceptionsInput, EvaluationResultUpdateWithoutExceptionsInput>, EvaluationResultUncheckedUpdateWithoutExceptionsInput>
  }

  export type TenderCreateNestedOneWithoutSignaturesInput = {
    create?: XOR<TenderCreateWithoutSignaturesInput, TenderUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: TenderCreateOrConnectWithoutSignaturesInput
    connect?: TenderWhereUniqueInput
  }

  export type TenderUpdateOneRequiredWithoutSignaturesNestedInput = {
    create?: XOR<TenderCreateWithoutSignaturesInput, TenderUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: TenderCreateOrConnectWithoutSignaturesInput
    upsert?: TenderUpsertWithoutSignaturesInput
    connect?: TenderWhereUniqueInput
    update?: XOR<XOR<TenderUpdateToOneWithWhereWithoutSignaturesInput, TenderUpdateWithoutSignaturesInput>, TenderUncheckedUpdateWithoutSignaturesInput>
  }

  export type TenderCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<TenderCreateWithoutDocumentsInput, TenderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TenderCreateOrConnectWithoutDocumentsInput
    connect?: TenderWhereUniqueInput
  }

  export type TenderUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<TenderCreateWithoutDocumentsInput, TenderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TenderCreateOrConnectWithoutDocumentsInput
    upsert?: TenderUpsertWithoutDocumentsInput
    connect?: TenderWhereUniqueInput
    update?: XOR<XOR<TenderUpdateToOneWithWhereWithoutDocumentsInput, TenderUpdateWithoutDocumentsInput>, TenderUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserCreateNestedOneWithoutAnalyticsLogsInput = {
    create?: XOR<UserCreateWithoutAnalyticsLogsInput, UserUncheckedCreateWithoutAnalyticsLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAnalyticsLogsNestedInput = {
    create?: XOR<UserCreateWithoutAnalyticsLogsInput, UserUncheckedCreateWithoutAnalyticsLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsLogsInput
    upsert?: UserUpsertWithoutAnalyticsLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnalyticsLogsInput, UserUpdateWithoutAnalyticsLogsInput>, UserUncheckedUpdateWithoutAnalyticsLogsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutNotificationRulesInput = {
    create?: XOR<UserCreateWithoutNotificationRulesInput, UserUncheckedCreateWithoutNotificationRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationRulesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutNotificationRulesNestedInput = {
    create?: XOR<UserCreateWithoutNotificationRulesInput, UserUncheckedCreateWithoutNotificationRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationRulesInput
    upsert?: UserUpsertWithoutNotificationRulesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationRulesInput, UserUpdateWithoutNotificationRulesInput>, UserUncheckedUpdateWithoutNotificationRulesInput>
  }

  export type TenderCreateNestedOneWithoutTimelineEventsInput = {
    create?: XOR<TenderCreateWithoutTimelineEventsInput, TenderUncheckedCreateWithoutTimelineEventsInput>
    connectOrCreate?: TenderCreateOrConnectWithoutTimelineEventsInput
    connect?: TenderWhereUniqueInput
  }

  export type TenderUpdateOneRequiredWithoutTimelineEventsNestedInput = {
    create?: XOR<TenderCreateWithoutTimelineEventsInput, TenderUncheckedCreateWithoutTimelineEventsInput>
    connectOrCreate?: TenderCreateOrConnectWithoutTimelineEventsInput
    upsert?: TenderUpsertWithoutTimelineEventsInput
    connect?: TenderWhereUniqueInput
    update?: XOR<XOR<TenderUpdateToOneWithWhereWithoutTimelineEventsInput, TenderUpdateWithoutTimelineEventsInput>, TenderUncheckedUpdateWithoutTimelineEventsInput>
  }

  export type TenderCreateNestedOneWithoutInsightsInput = {
    create?: XOR<TenderCreateWithoutInsightsInput, TenderUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: TenderCreateOrConnectWithoutInsightsInput
    connect?: TenderWhereUniqueInput
  }

  export type TenderUpdateOneRequiredWithoutInsightsNestedInput = {
    create?: XOR<TenderCreateWithoutInsightsInput, TenderUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: TenderCreateOrConnectWithoutInsightsInput
    upsert?: TenderUpsertWithoutInsightsInput
    connect?: TenderWhereUniqueInput
    update?: XOR<XOR<TenderUpdateToOneWithWhereWithoutInsightsInput, TenderUpdateWithoutInsightsInput>, TenderUncheckedUpdateWithoutInsightsInput>
  }

  export type TenderCreateNestedOneWithoutHeatmapInput = {
    create?: XOR<TenderCreateWithoutHeatmapInput, TenderUncheckedCreateWithoutHeatmapInput>
    connectOrCreate?: TenderCreateOrConnectWithoutHeatmapInput
    connect?: TenderWhereUniqueInput
  }

  export type TenderUpdateOneRequiredWithoutHeatmapNestedInput = {
    create?: XOR<TenderCreateWithoutHeatmapInput, TenderUncheckedCreateWithoutHeatmapInput>
    connectOrCreate?: TenderCreateOrConnectWithoutHeatmapInput
    upsert?: TenderUpsertWithoutHeatmapInput
    connect?: TenderWhereUniqueInput
    update?: XOR<XOR<TenderUpdateToOneWithWhereWithoutHeatmapInput, TenderUpdateWithoutHeatmapInput>, TenderUncheckedUpdateWithoutHeatmapInput>
  }

  export type BidderCreateNestedOneWithoutIntelligenceInput = {
    create?: XOR<BidderCreateWithoutIntelligenceInput, BidderUncheckedCreateWithoutIntelligenceInput>
    connectOrCreate?: BidderCreateOrConnectWithoutIntelligenceInput
    connect?: BidderWhereUniqueInput
  }

  export type BidderUpdateOneRequiredWithoutIntelligenceNestedInput = {
    create?: XOR<BidderCreateWithoutIntelligenceInput, BidderUncheckedCreateWithoutIntelligenceInput>
    connectOrCreate?: BidderCreateOrConnectWithoutIntelligenceInput
    upsert?: BidderUpsertWithoutIntelligenceInput
    connect?: BidderWhereUniqueInput
    update?: XOR<XOR<BidderUpdateToOneWithWhereWithoutIntelligenceInput, BidderUpdateWithoutIntelligenceInput>, BidderUncheckedUpdateWithoutIntelligenceInput>
  }

  export type BidderCreateNestedOneWithoutRiskProfileInput = {
    create?: XOR<BidderCreateWithoutRiskProfileInput, BidderUncheckedCreateWithoutRiskProfileInput>
    connectOrCreate?: BidderCreateOrConnectWithoutRiskProfileInput
    connect?: BidderWhereUniqueInput
  }

  export type BidderUpdateOneRequiredWithoutRiskProfileNestedInput = {
    create?: XOR<BidderCreateWithoutRiskProfileInput, BidderUncheckedCreateWithoutRiskProfileInput>
    connectOrCreate?: BidderCreateOrConnectWithoutRiskProfileInput
    upsert?: BidderUpsertWithoutRiskProfileInput
    connect?: BidderWhereUniqueInput
    update?: XOR<XOR<BidderUpdateToOneWithWhereWithoutRiskProfileInput, BidderUpdateWithoutRiskProfileInput>, BidderUncheckedUpdateWithoutRiskProfileInput>
  }

  export type TenderCreateNestedOneWithoutComplianceDashboardInput = {
    create?: XOR<TenderCreateWithoutComplianceDashboardInput, TenderUncheckedCreateWithoutComplianceDashboardInput>
    connectOrCreate?: TenderCreateOrConnectWithoutComplianceDashboardInput
    connect?: TenderWhereUniqueInput
  }

  export type TenderUpdateOneRequiredWithoutComplianceDashboardNestedInput = {
    create?: XOR<TenderCreateWithoutComplianceDashboardInput, TenderUncheckedCreateWithoutComplianceDashboardInput>
    connectOrCreate?: TenderCreateOrConnectWithoutComplianceDashboardInput
    upsert?: TenderUpsertWithoutComplianceDashboardInput
    connect?: TenderWhereUniqueInput
    update?: XOR<XOR<TenderUpdateToOneWithWhereWithoutComplianceDashboardInput, TenderUpdateWithoutComplianceDashboardInput>, TenderUncheckedUpdateWithoutComplianceDashboardInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type TenantBrandingCreateWithoutTenantInput = {
    id?: string
    primaryColor?: string | null
    secondaryColor?: string | null
    logoUrl?: string | null
    publicName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantBrandingUncheckedCreateWithoutTenantInput = {
    id?: string
    primaryColor?: string | null
    secondaryColor?: string | null
    logoUrl?: string | null
    publicName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantBrandingCreateOrConnectWithoutTenantInput = {
    where: TenantBrandingWhereUniqueInput
    create: XOR<TenantBrandingCreateWithoutTenantInput, TenantBrandingUncheckedCreateWithoutTenantInput>
  }

  export type TenderCreateWithoutTenantInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateWithoutTenantInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderUncheckedCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsUncheckedCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderCreateOrConnectWithoutTenantInput = {
    where: TenderWhereUniqueInput
    create: XOR<TenderCreateWithoutTenantInput, TenderUncheckedCreateWithoutTenantInput>
  }

  export type TenderCreateManyTenantInputEnvelope = {
    data: TenderCreateManyTenantInput | TenderCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    analyticsLogs?: AnalyticsAccessLogCreateNestedManyWithoutUserInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationRules?: NotificationRuleCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    analyticsLogs?: AnalyticsAccessLogUncheckedCreateNestedManyWithoutUserInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationRules?: NotificationRuleUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantBrandingUpsertWithoutTenantInput = {
    update: XOR<TenantBrandingUpdateWithoutTenantInput, TenantBrandingUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantBrandingCreateWithoutTenantInput, TenantBrandingUncheckedCreateWithoutTenantInput>
    where?: TenantBrandingWhereInput
  }

  export type TenantBrandingUpdateToOneWithWhereWithoutTenantInput = {
    where?: TenantBrandingWhereInput
    data: XOR<TenantBrandingUpdateWithoutTenantInput, TenantBrandingUncheckedUpdateWithoutTenantInput>
  }

  export type TenantBrandingUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publicName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBrandingUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    publicName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenderUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenderWhereUniqueInput
    update: XOR<TenderUpdateWithoutTenantInput, TenderUncheckedUpdateWithoutTenantInput>
    create: XOR<TenderCreateWithoutTenantInput, TenderUncheckedCreateWithoutTenantInput>
  }

  export type TenderUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenderWhereUniqueInput
    data: XOR<TenderUpdateWithoutTenantInput, TenderUncheckedUpdateWithoutTenantInput>
  }

  export type TenderUpdateManyWithWhereWithoutTenantInput = {
    where: TenderScalarWhereInput
    data: XOR<TenderUpdateManyMutationInput, TenderUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenderScalarWhereInput = {
    AND?: TenderScalarWhereInput | TenderScalarWhereInput[]
    OR?: TenderScalarWhereInput[]
    NOT?: TenderScalarWhereInput | TenderScalarWhereInput[]
    id?: StringFilter<"Tender"> | string
    number?: StringFilter<"Tender"> | string
    description?: StringFilter<"Tender"> | string
    category?: StringNullableFilter<"Tender"> | string | null
    createdAt?: DateTimeFilter<"Tender"> | Date | string
    updatedAt?: DateTimeFilter<"Tender"> | Date | string
    tenantId?: StringNullableFilter<"Tender"> | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
  }

  export type TenantCreateWithoutBrandingInput = {
    id?: string
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenders?: TenderCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBrandingInput = {
    id?: string
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenders?: TenderUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBrandingInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBrandingInput, TenantUncheckedCreateWithoutBrandingInput>
  }

  export type TenantUpsertWithoutBrandingInput = {
    update: XOR<TenantUpdateWithoutBrandingInput, TenantUncheckedUpdateWithoutBrandingInput>
    create: XOR<TenantCreateWithoutBrandingInput, TenantUncheckedCreateWithoutBrandingInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBrandingInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBrandingInput, TenantUncheckedUpdateWithoutBrandingInput>
  }

  export type TenantUpdateWithoutBrandingInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenders?: TenderUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBrandingInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenders?: TenderUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AnalyticsAccessLogCreateWithoutUserInput = {
    id?: string
    role: string
    endpoint: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AnalyticsAccessLogUncheckedCreateWithoutUserInput = {
    id?: string
    role: string
    endpoint: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AnalyticsAccessLogCreateOrConnectWithoutUserInput = {
    where: AnalyticsAccessLogWhereUniqueInput
    create: XOR<AnalyticsAccessLogCreateWithoutUserInput, AnalyticsAccessLogUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsAccessLogCreateManyUserInputEnvelope = {
    data: AnalyticsAccessLogCreateManyUserInput | AnalyticsAccessLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScmTenderAssignmentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    tender: TenderCreateNestedOneWithoutScmAssignmentsInput
  }

  export type ScmTenderAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    tenderId: string
    createdAt?: Date | string
  }

  export type ScmTenderAssignmentCreateOrConnectWithoutUserInput = {
    where: ScmTenderAssignmentWhereUniqueInput
    create: XOR<ScmTenderAssignmentCreateWithoutUserInput, ScmTenderAssignmentUncheckedCreateWithoutUserInput>
  }

  export type ScmTenderAssignmentCreateManyUserInputEnvelope = {
    data: ScmTenderAssignmentCreateManyUserInput | ScmTenderAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branding?: TenantBrandingCreateNestedOneWithoutTenantInput
    tenders?: TenderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branding?: TenantBrandingUncheckedCreateNestedOneWithoutTenantInput
    tenders?: TenderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationRuleCreateWithoutOwnerInput = {
    id?: string
    trigger: string
    role: string
    enabled?: boolean
  }

  export type NotificationRuleUncheckedCreateWithoutOwnerInput = {
    id?: string
    trigger: string
    role: string
    enabled?: boolean
  }

  export type NotificationRuleCreateOrConnectWithoutOwnerInput = {
    where: NotificationRuleWhereUniqueInput
    create: XOR<NotificationRuleCreateWithoutOwnerInput, NotificationRuleUncheckedCreateWithoutOwnerInput>
  }

  export type NotificationRuleCreateManyOwnerInputEnvelope = {
    data: NotificationRuleCreateManyOwnerInput | NotificationRuleCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsAccessLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AnalyticsAccessLogWhereUniqueInput
    update: XOR<AnalyticsAccessLogUpdateWithoutUserInput, AnalyticsAccessLogUncheckedUpdateWithoutUserInput>
    create: XOR<AnalyticsAccessLogCreateWithoutUserInput, AnalyticsAccessLogUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsAccessLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AnalyticsAccessLogWhereUniqueInput
    data: XOR<AnalyticsAccessLogUpdateWithoutUserInput, AnalyticsAccessLogUncheckedUpdateWithoutUserInput>
  }

  export type AnalyticsAccessLogUpdateManyWithWhereWithoutUserInput = {
    where: AnalyticsAccessLogScalarWhereInput
    data: XOR<AnalyticsAccessLogUpdateManyMutationInput, AnalyticsAccessLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AnalyticsAccessLogScalarWhereInput = {
    AND?: AnalyticsAccessLogScalarWhereInput | AnalyticsAccessLogScalarWhereInput[]
    OR?: AnalyticsAccessLogScalarWhereInput[]
    NOT?: AnalyticsAccessLogScalarWhereInput | AnalyticsAccessLogScalarWhereInput[]
    id?: StringFilter<"AnalyticsAccessLog"> | string
    userId?: StringFilter<"AnalyticsAccessLog"> | string
    role?: StringFilter<"AnalyticsAccessLog"> | string
    endpoint?: StringFilter<"AnalyticsAccessLog"> | string
    ip?: StringNullableFilter<"AnalyticsAccessLog"> | string | null
    userAgent?: StringNullableFilter<"AnalyticsAccessLog"> | string | null
    createdAt?: DateTimeFilter<"AnalyticsAccessLog"> | Date | string
  }

  export type ScmTenderAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: ScmTenderAssignmentWhereUniqueInput
    update: XOR<ScmTenderAssignmentUpdateWithoutUserInput, ScmTenderAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<ScmTenderAssignmentCreateWithoutUserInput, ScmTenderAssignmentUncheckedCreateWithoutUserInput>
  }

  export type ScmTenderAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: ScmTenderAssignmentWhereUniqueInput
    data: XOR<ScmTenderAssignmentUpdateWithoutUserInput, ScmTenderAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type ScmTenderAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: ScmTenderAssignmentScalarWhereInput
    data: XOR<ScmTenderAssignmentUpdateManyMutationInput, ScmTenderAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type ScmTenderAssignmentScalarWhereInput = {
    AND?: ScmTenderAssignmentScalarWhereInput | ScmTenderAssignmentScalarWhereInput[]
    OR?: ScmTenderAssignmentScalarWhereInput[]
    NOT?: ScmTenderAssignmentScalarWhereInput | ScmTenderAssignmentScalarWhereInput[]
    id?: StringFilter<"ScmTenderAssignment"> | string
    userId?: StringFilter<"ScmTenderAssignment"> | string
    tenderId?: StringFilter<"ScmTenderAssignment"> | string
    createdAt?: DateTimeFilter<"ScmTenderAssignment"> | Date | string
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branding?: TenantBrandingUpdateOneWithoutTenantNestedInput
    tenders?: TenderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branding?: TenantBrandingUncheckedUpdateOneWithoutTenantNestedInput
    tenders?: TenderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationRuleUpsertWithWhereUniqueWithoutOwnerInput = {
    where: NotificationRuleWhereUniqueInput
    update: XOR<NotificationRuleUpdateWithoutOwnerInput, NotificationRuleUncheckedUpdateWithoutOwnerInput>
    create: XOR<NotificationRuleCreateWithoutOwnerInput, NotificationRuleUncheckedCreateWithoutOwnerInput>
  }

  export type NotificationRuleUpdateWithWhereUniqueWithoutOwnerInput = {
    where: NotificationRuleWhereUniqueInput
    data: XOR<NotificationRuleUpdateWithoutOwnerInput, NotificationRuleUncheckedUpdateWithoutOwnerInput>
  }

  export type NotificationRuleUpdateManyWithWhereWithoutOwnerInput = {
    where: NotificationRuleScalarWhereInput
    data: XOR<NotificationRuleUpdateManyMutationInput, NotificationRuleUncheckedUpdateManyWithoutOwnerInput>
  }

  export type NotificationRuleScalarWhereInput = {
    AND?: NotificationRuleScalarWhereInput | NotificationRuleScalarWhereInput[]
    OR?: NotificationRuleScalarWhereInput[]
    NOT?: NotificationRuleScalarWhereInput | NotificationRuleScalarWhereInput[]
    id?: StringFilter<"NotificationRule"> | string
    trigger?: StringFilter<"NotificationRule"> | string
    role?: StringFilter<"NotificationRule"> | string
    enabled?: BoolFilter<"NotificationRule"> | boolean
    ownerId?: StringNullableFilter<"NotificationRule"> | string | null
  }

  export type TenderCreateWithoutScmAssignmentsInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureCreateNestedManyWithoutTenderInput
    tenant?: TenantCreateNestedOneWithoutTendersInput
    timelineEvents?: TenderTimelineEventCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateWithoutScmAssignmentsInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
    bidders?: BidderUncheckedCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsUncheckedCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderCreateOrConnectWithoutScmAssignmentsInput = {
    where: TenderWhereUniqueInput
    create: XOR<TenderCreateWithoutScmAssignmentsInput, TenderUncheckedCreateWithoutScmAssignmentsInput>
  }

  export type UserCreateWithoutScmAssignmentsInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    analyticsLogs?: AnalyticsAccessLogCreateNestedManyWithoutUserInput
    tenant?: TenantCreateNestedOneWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationRules?: NotificationRuleCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutScmAssignmentsInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    tenantId?: string | null
    analyticsLogs?: AnalyticsAccessLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationRules?: NotificationRuleUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutScmAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScmAssignmentsInput, UserUncheckedCreateWithoutScmAssignmentsInput>
  }

  export type TenderUpsertWithoutScmAssignmentsInput = {
    update: XOR<TenderUpdateWithoutScmAssignmentsInput, TenderUncheckedUpdateWithoutScmAssignmentsInput>
    create: XOR<TenderCreateWithoutScmAssignmentsInput, TenderUncheckedCreateWithoutScmAssignmentsInput>
    where?: TenderWhereInput
  }

  export type TenderUpdateToOneWithWhereWithoutScmAssignmentsInput = {
    where?: TenderWhereInput
    data: XOR<TenderUpdateWithoutScmAssignmentsInput, TenderUncheckedUpdateWithoutScmAssignmentsInput>
  }

  export type TenderUpdateWithoutScmAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUpdateManyWithoutTenderNestedInput
    tenant?: TenantUpdateOneWithoutTendersNestedInput
    timelineEvents?: TenderTimelineEventUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateWithoutScmAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    bidders?: BidderUncheckedUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type UserUpsertWithoutScmAssignmentsInput = {
    update: XOR<UserUpdateWithoutScmAssignmentsInput, UserUncheckedUpdateWithoutScmAssignmentsInput>
    create: XOR<UserCreateWithoutScmAssignmentsInput, UserUncheckedCreateWithoutScmAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScmAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScmAssignmentsInput, UserUncheckedUpdateWithoutScmAssignmentsInput>
  }

  export type UserUpdateWithoutScmAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    analyticsLogs?: AnalyticsAccessLogUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationRules?: NotificationRuleUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutScmAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsLogs?: AnalyticsAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationRules?: NotificationRuleUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type BidderCreateWithoutTenderInput = {
    id?: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeCreateNestedOneWithoutBidderInput
    technicalScores?: BidderCriterionScoreCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutBidderInput
    evidence?: EvidenceCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileCreateNestedOneWithoutBidderInput
  }

  export type BidderUncheckedCreateWithoutTenderInput = {
    id?: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeUncheckedCreateNestedOneWithoutBidderInput
    technicalScores?: BidderCriterionScoreUncheckedCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutBidderInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceUncheckedCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileUncheckedCreateNestedOneWithoutBidderInput
  }

  export type BidderCreateOrConnectWithoutTenderInput = {
    where: BidderWhereUniqueInput
    create: XOR<BidderCreateWithoutTenderInput, BidderUncheckedCreateWithoutTenderInput>
  }

  export type BidderCreateManyTenderInputEnvelope = {
    data: BidderCreateManyTenderInput | BidderCreateManyTenderInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationConfigCreateWithoutTenderInput = {
    id?: string
    priceWeight: number
    bbbeeWeight: number
    functionalityPass: number
    functionalityMax: number
    criteria: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationConfigUncheckedCreateWithoutTenderInput = {
    id?: string
    priceWeight: number
    bbbeeWeight: number
    functionalityPass: number
    functionalityMax: number
    criteria: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationConfigCreateOrConnectWithoutTenderInput = {
    where: EvaluationConfigWhereUniqueInput
    create: XOR<EvaluationConfigCreateWithoutTenderInput, EvaluationConfigUncheckedCreateWithoutTenderInput>
  }

  export type EvaluationDocumentCreateWithoutTenderInput = {
    id?: string
    runNumber: number
    fileUrl: string
    hash: string
    createdAt?: Date | string
  }

  export type EvaluationDocumentUncheckedCreateWithoutTenderInput = {
    id?: string
    runNumber: number
    fileUrl: string
    hash: string
    createdAt?: Date | string
  }

  export type EvaluationDocumentCreateOrConnectWithoutTenderInput = {
    where: EvaluationDocumentWhereUniqueInput
    create: XOR<EvaluationDocumentCreateWithoutTenderInput, EvaluationDocumentUncheckedCreateWithoutTenderInput>
  }

  export type EvaluationDocumentCreateManyTenderInputEnvelope = {
    data: EvaluationDocumentCreateManyTenderInput | EvaluationDocumentCreateManyTenderInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationResultCreateWithoutTenderInput = {
    id?: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    compliance?: ComplianceItemCreateNestedManyWithoutEvaluationResultInput
    exceptions?: EvaluationExceptionCreateNestedManyWithoutEvaluationResultInput
    bidder: BidderCreateNestedOneWithoutEvaluationResultsInput
    workflowLogs?: WorkflowLogCreateNestedManyWithoutEvaluationResultInput
  }

  export type EvaluationResultUncheckedCreateWithoutTenderInput = {
    id?: string
    bidderId: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    compliance?: ComplianceItemUncheckedCreateNestedManyWithoutEvaluationResultInput
    exceptions?: EvaluationExceptionUncheckedCreateNestedManyWithoutEvaluationResultInput
    workflowLogs?: WorkflowLogUncheckedCreateNestedManyWithoutEvaluationResultInput
  }

  export type EvaluationResultCreateOrConnectWithoutTenderInput = {
    where: EvaluationResultWhereUniqueInput
    create: XOR<EvaluationResultCreateWithoutTenderInput, EvaluationResultUncheckedCreateWithoutTenderInput>
  }

  export type EvaluationResultCreateManyTenderInputEnvelope = {
    data: EvaluationResultCreateManyTenderInput | EvaluationResultCreateManyTenderInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationSignatureCreateWithoutTenderInput = {
    id?: string
    role: string
    name: string
    signature?: string | null
    comment?: string | null
    signedAt?: Date | string
  }

  export type EvaluationSignatureUncheckedCreateWithoutTenderInput = {
    id?: string
    role: string
    name: string
    signature?: string | null
    comment?: string | null
    signedAt?: Date | string
  }

  export type EvaluationSignatureCreateOrConnectWithoutTenderInput = {
    where: EvaluationSignatureWhereUniqueInput
    create: XOR<EvaluationSignatureCreateWithoutTenderInput, EvaluationSignatureUncheckedCreateWithoutTenderInput>
  }

  export type EvaluationSignatureCreateManyTenderInputEnvelope = {
    data: EvaluationSignatureCreateManyTenderInput | EvaluationSignatureCreateManyTenderInput[]
    skipDuplicates?: boolean
  }

  export type ScmTenderAssignmentCreateWithoutTenderInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutScmAssignmentsInput
  }

  export type ScmTenderAssignmentUncheckedCreateWithoutTenderInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ScmTenderAssignmentCreateOrConnectWithoutTenderInput = {
    where: ScmTenderAssignmentWhereUniqueInput
    create: XOR<ScmTenderAssignmentCreateWithoutTenderInput, ScmTenderAssignmentUncheckedCreateWithoutTenderInput>
  }

  export type ScmTenderAssignmentCreateManyTenderInputEnvelope = {
    data: ScmTenderAssignmentCreateManyTenderInput | ScmTenderAssignmentCreateManyTenderInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutTendersInput = {
    id?: string
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branding?: TenantBrandingCreateNestedOneWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTendersInput = {
    id?: string
    code: string
    name: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branding?: TenantBrandingUncheckedCreateNestedOneWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTendersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTendersInput, TenantUncheckedCreateWithoutTendersInput>
  }

  export type TenderTimelineEventCreateWithoutTenderInput = {
    id?: string
    type: string
    label: string
    createdAt?: Date | string
  }

  export type TenderTimelineEventUncheckedCreateWithoutTenderInput = {
    id?: string
    type: string
    label: string
    createdAt?: Date | string
  }

  export type TenderTimelineEventCreateOrConnectWithoutTenderInput = {
    where: TenderTimelineEventWhereUniqueInput
    create: XOR<TenderTimelineEventCreateWithoutTenderInput, TenderTimelineEventUncheckedCreateWithoutTenderInput>
  }

  export type TenderTimelineEventCreateManyTenderInputEnvelope = {
    data: TenderTimelineEventCreateManyTenderInput | TenderTimelineEventCreateManyTenderInput[]
    skipDuplicates?: boolean
  }

  export type TenderInsightsCreateWithoutTenderInput = {
    payload: JsonNullValueInput | InputJsonValue
  }

  export type TenderInsightsUncheckedCreateWithoutTenderInput = {
    payload: JsonNullValueInput | InputJsonValue
  }

  export type TenderInsightsCreateOrConnectWithoutTenderInput = {
    where: TenderInsightsWhereUniqueInput
    create: XOR<TenderInsightsCreateWithoutTenderInput, TenderInsightsUncheckedCreateWithoutTenderInput>
  }

  export type TenderHeatmapCreateWithoutTenderInput = {
    cells: JsonNullValueInput | InputJsonValue
  }

  export type TenderHeatmapUncheckedCreateWithoutTenderInput = {
    cells: JsonNullValueInput | InputJsonValue
  }

  export type TenderHeatmapCreateOrConnectWithoutTenderInput = {
    where: TenderHeatmapWhereUniqueInput
    create: XOR<TenderHeatmapCreateWithoutTenderInput, TenderHeatmapUncheckedCreateWithoutTenderInput>
  }

  export type TenderComplianceDashboardCreateWithoutTenderInput = {
    payload: JsonNullValueInput | InputJsonValue
  }

  export type TenderComplianceDashboardUncheckedCreateWithoutTenderInput = {
    payload: JsonNullValueInput | InputJsonValue
  }

  export type TenderComplianceDashboardCreateOrConnectWithoutTenderInput = {
    where: TenderComplianceDashboardWhereUniqueInput
    create: XOR<TenderComplianceDashboardCreateWithoutTenderInput, TenderComplianceDashboardUncheckedCreateWithoutTenderInput>
  }

  export type BidderUpsertWithWhereUniqueWithoutTenderInput = {
    where: BidderWhereUniqueInput
    update: XOR<BidderUpdateWithoutTenderInput, BidderUncheckedUpdateWithoutTenderInput>
    create: XOR<BidderCreateWithoutTenderInput, BidderUncheckedCreateWithoutTenderInput>
  }

  export type BidderUpdateWithWhereUniqueWithoutTenderInput = {
    where: BidderWhereUniqueInput
    data: XOR<BidderUpdateWithoutTenderInput, BidderUncheckedUpdateWithoutTenderInput>
  }

  export type BidderUpdateManyWithWhereWithoutTenderInput = {
    where: BidderScalarWhereInput
    data: XOR<BidderUpdateManyMutationInput, BidderUncheckedUpdateManyWithoutTenderInput>
  }

  export type BidderScalarWhereInput = {
    AND?: BidderScalarWhereInput | BidderScalarWhereInput[]
    OR?: BidderScalarWhereInput[]
    NOT?: BidderScalarWhereInput | BidderScalarWhereInput[]
    id?: StringFilter<"Bidder"> | string
    tenderId?: StringFilter<"Bidder"> | string
    name?: StringFilter<"Bidder"> | string
    price?: FloatNullableFilter<"Bidder"> | number | null
    disqualified?: BoolFilter<"Bidder"> | boolean
    disqualificationReason?: StringNullableFilter<"Bidder"> | string | null
    createdAt?: DateTimeFilter<"Bidder"> | Date | string
    updatedAt?: DateTimeFilter<"Bidder"> | Date | string
  }

  export type EvaluationConfigUpsertWithoutTenderInput = {
    update: XOR<EvaluationConfigUpdateWithoutTenderInput, EvaluationConfigUncheckedUpdateWithoutTenderInput>
    create: XOR<EvaluationConfigCreateWithoutTenderInput, EvaluationConfigUncheckedCreateWithoutTenderInput>
    where?: EvaluationConfigWhereInput
  }

  export type EvaluationConfigUpdateToOneWithWhereWithoutTenderInput = {
    where?: EvaluationConfigWhereInput
    data: XOR<EvaluationConfigUpdateWithoutTenderInput, EvaluationConfigUncheckedUpdateWithoutTenderInput>
  }

  export type EvaluationConfigUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceWeight?: IntFieldUpdateOperationsInput | number
    bbbeeWeight?: IntFieldUpdateOperationsInput | number
    functionalityPass?: IntFieldUpdateOperationsInput | number
    functionalityMax?: IntFieldUpdateOperationsInput | number
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationConfigUncheckedUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceWeight?: IntFieldUpdateOperationsInput | number
    bbbeeWeight?: IntFieldUpdateOperationsInput | number
    functionalityPass?: IntFieldUpdateOperationsInput | number
    functionalityMax?: IntFieldUpdateOperationsInput | number
    criteria?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationDocumentUpsertWithWhereUniqueWithoutTenderInput = {
    where: EvaluationDocumentWhereUniqueInput
    update: XOR<EvaluationDocumentUpdateWithoutTenderInput, EvaluationDocumentUncheckedUpdateWithoutTenderInput>
    create: XOR<EvaluationDocumentCreateWithoutTenderInput, EvaluationDocumentUncheckedCreateWithoutTenderInput>
  }

  export type EvaluationDocumentUpdateWithWhereUniqueWithoutTenderInput = {
    where: EvaluationDocumentWhereUniqueInput
    data: XOR<EvaluationDocumentUpdateWithoutTenderInput, EvaluationDocumentUncheckedUpdateWithoutTenderInput>
  }

  export type EvaluationDocumentUpdateManyWithWhereWithoutTenderInput = {
    where: EvaluationDocumentScalarWhereInput
    data: XOR<EvaluationDocumentUpdateManyMutationInput, EvaluationDocumentUncheckedUpdateManyWithoutTenderInput>
  }

  export type EvaluationDocumentScalarWhereInput = {
    AND?: EvaluationDocumentScalarWhereInput | EvaluationDocumentScalarWhereInput[]
    OR?: EvaluationDocumentScalarWhereInput[]
    NOT?: EvaluationDocumentScalarWhereInput | EvaluationDocumentScalarWhereInput[]
    id?: StringFilter<"EvaluationDocument"> | string
    tenderId?: StringFilter<"EvaluationDocument"> | string
    runNumber?: IntFilter<"EvaluationDocument"> | number
    fileUrl?: StringFilter<"EvaluationDocument"> | string
    hash?: StringFilter<"EvaluationDocument"> | string
    createdAt?: DateTimeFilter<"EvaluationDocument"> | Date | string
  }

  export type EvaluationResultUpsertWithWhereUniqueWithoutTenderInput = {
    where: EvaluationResultWhereUniqueInput
    update: XOR<EvaluationResultUpdateWithoutTenderInput, EvaluationResultUncheckedUpdateWithoutTenderInput>
    create: XOR<EvaluationResultCreateWithoutTenderInput, EvaluationResultUncheckedCreateWithoutTenderInput>
  }

  export type EvaluationResultUpdateWithWhereUniqueWithoutTenderInput = {
    where: EvaluationResultWhereUniqueInput
    data: XOR<EvaluationResultUpdateWithoutTenderInput, EvaluationResultUncheckedUpdateWithoutTenderInput>
  }

  export type EvaluationResultUpdateManyWithWhereWithoutTenderInput = {
    where: EvaluationResultScalarWhereInput
    data: XOR<EvaluationResultUpdateManyMutationInput, EvaluationResultUncheckedUpdateManyWithoutTenderInput>
  }

  export type EvaluationResultScalarWhereInput = {
    AND?: EvaluationResultScalarWhereInput | EvaluationResultScalarWhereInput[]
    OR?: EvaluationResultScalarWhereInput[]
    NOT?: EvaluationResultScalarWhereInput | EvaluationResultScalarWhereInput[]
    id?: StringFilter<"EvaluationResult"> | string
    tenderId?: StringFilter<"EvaluationResult"> | string
    bidderId?: StringFilter<"EvaluationResult"> | string
    functionalityScore?: FloatFilter<"EvaluationResult"> | number
    qualifies?: BoolFilter<"EvaluationResult"> | boolean
    price?: FloatFilter<"EvaluationResult"> | number
    priceScore?: FloatFilter<"EvaluationResult"> | number
    bbbeeLevel?: IntNullableFilter<"EvaluationResult"> | number | null
    bbbeePoints?: FloatFilter<"EvaluationResult"> | number
    totalScore?: FloatFilter<"EvaluationResult"> | number
    riskScore?: FloatNullableFilter<"EvaluationResult"> | number | null
    complianceRate?: FloatNullableFilter<"EvaluationResult"> | number | null
    exceptionsCount?: IntFilter<"EvaluationResult"> | number
    slaBreached?: BoolFilter<"EvaluationResult"> | boolean
    currentStage?: StringNullableFilter<"EvaluationResult"> | string | null
    createdAt?: DateTimeFilter<"EvaluationResult"> | Date | string
    hash?: StringFilter<"EvaluationResult"> | string
  }

  export type EvaluationSignatureUpsertWithWhereUniqueWithoutTenderInput = {
    where: EvaluationSignatureWhereUniqueInput
    update: XOR<EvaluationSignatureUpdateWithoutTenderInput, EvaluationSignatureUncheckedUpdateWithoutTenderInput>
    create: XOR<EvaluationSignatureCreateWithoutTenderInput, EvaluationSignatureUncheckedCreateWithoutTenderInput>
  }

  export type EvaluationSignatureUpdateWithWhereUniqueWithoutTenderInput = {
    where: EvaluationSignatureWhereUniqueInput
    data: XOR<EvaluationSignatureUpdateWithoutTenderInput, EvaluationSignatureUncheckedUpdateWithoutTenderInput>
  }

  export type EvaluationSignatureUpdateManyWithWhereWithoutTenderInput = {
    where: EvaluationSignatureScalarWhereInput
    data: XOR<EvaluationSignatureUpdateManyMutationInput, EvaluationSignatureUncheckedUpdateManyWithoutTenderInput>
  }

  export type EvaluationSignatureScalarWhereInput = {
    AND?: EvaluationSignatureScalarWhereInput | EvaluationSignatureScalarWhereInput[]
    OR?: EvaluationSignatureScalarWhereInput[]
    NOT?: EvaluationSignatureScalarWhereInput | EvaluationSignatureScalarWhereInput[]
    id?: StringFilter<"EvaluationSignature"> | string
    tenderId?: StringFilter<"EvaluationSignature"> | string
    role?: StringFilter<"EvaluationSignature"> | string
    name?: StringFilter<"EvaluationSignature"> | string
    signature?: StringNullableFilter<"EvaluationSignature"> | string | null
    comment?: StringNullableFilter<"EvaluationSignature"> | string | null
    signedAt?: DateTimeFilter<"EvaluationSignature"> | Date | string
  }

  export type ScmTenderAssignmentUpsertWithWhereUniqueWithoutTenderInput = {
    where: ScmTenderAssignmentWhereUniqueInput
    update: XOR<ScmTenderAssignmentUpdateWithoutTenderInput, ScmTenderAssignmentUncheckedUpdateWithoutTenderInput>
    create: XOR<ScmTenderAssignmentCreateWithoutTenderInput, ScmTenderAssignmentUncheckedCreateWithoutTenderInput>
  }

  export type ScmTenderAssignmentUpdateWithWhereUniqueWithoutTenderInput = {
    where: ScmTenderAssignmentWhereUniqueInput
    data: XOR<ScmTenderAssignmentUpdateWithoutTenderInput, ScmTenderAssignmentUncheckedUpdateWithoutTenderInput>
  }

  export type ScmTenderAssignmentUpdateManyWithWhereWithoutTenderInput = {
    where: ScmTenderAssignmentScalarWhereInput
    data: XOR<ScmTenderAssignmentUpdateManyMutationInput, ScmTenderAssignmentUncheckedUpdateManyWithoutTenderInput>
  }

  export type TenantUpsertWithoutTendersInput = {
    update: XOR<TenantUpdateWithoutTendersInput, TenantUncheckedUpdateWithoutTendersInput>
    create: XOR<TenantCreateWithoutTendersInput, TenantUncheckedCreateWithoutTendersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTendersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTendersInput, TenantUncheckedUpdateWithoutTendersInput>
  }

  export type TenantUpdateWithoutTendersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branding?: TenantBrandingUpdateOneWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTendersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branding?: TenantBrandingUncheckedUpdateOneWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenderTimelineEventUpsertWithWhereUniqueWithoutTenderInput = {
    where: TenderTimelineEventWhereUniqueInput
    update: XOR<TenderTimelineEventUpdateWithoutTenderInput, TenderTimelineEventUncheckedUpdateWithoutTenderInput>
    create: XOR<TenderTimelineEventCreateWithoutTenderInput, TenderTimelineEventUncheckedCreateWithoutTenderInput>
  }

  export type TenderTimelineEventUpdateWithWhereUniqueWithoutTenderInput = {
    where: TenderTimelineEventWhereUniqueInput
    data: XOR<TenderTimelineEventUpdateWithoutTenderInput, TenderTimelineEventUncheckedUpdateWithoutTenderInput>
  }

  export type TenderTimelineEventUpdateManyWithWhereWithoutTenderInput = {
    where: TenderTimelineEventScalarWhereInput
    data: XOR<TenderTimelineEventUpdateManyMutationInput, TenderTimelineEventUncheckedUpdateManyWithoutTenderInput>
  }

  export type TenderTimelineEventScalarWhereInput = {
    AND?: TenderTimelineEventScalarWhereInput | TenderTimelineEventScalarWhereInput[]
    OR?: TenderTimelineEventScalarWhereInput[]
    NOT?: TenderTimelineEventScalarWhereInput | TenderTimelineEventScalarWhereInput[]
    id?: StringFilter<"TenderTimelineEvent"> | string
    tenderId?: StringFilter<"TenderTimelineEvent"> | string
    type?: StringFilter<"TenderTimelineEvent"> | string
    label?: StringFilter<"TenderTimelineEvent"> | string
    createdAt?: DateTimeFilter<"TenderTimelineEvent"> | Date | string
  }

  export type TenderInsightsUpsertWithoutTenderInput = {
    update: XOR<TenderInsightsUpdateWithoutTenderInput, TenderInsightsUncheckedUpdateWithoutTenderInput>
    create: XOR<TenderInsightsCreateWithoutTenderInput, TenderInsightsUncheckedCreateWithoutTenderInput>
    where?: TenderInsightsWhereInput
  }

  export type TenderInsightsUpdateToOneWithWhereWithoutTenderInput = {
    where?: TenderInsightsWhereInput
    data: XOR<TenderInsightsUpdateWithoutTenderInput, TenderInsightsUncheckedUpdateWithoutTenderInput>
  }

  export type TenderInsightsUpdateWithoutTenderInput = {
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type TenderInsightsUncheckedUpdateWithoutTenderInput = {
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type TenderHeatmapUpsertWithoutTenderInput = {
    update: XOR<TenderHeatmapUpdateWithoutTenderInput, TenderHeatmapUncheckedUpdateWithoutTenderInput>
    create: XOR<TenderHeatmapCreateWithoutTenderInput, TenderHeatmapUncheckedCreateWithoutTenderInput>
    where?: TenderHeatmapWhereInput
  }

  export type TenderHeatmapUpdateToOneWithWhereWithoutTenderInput = {
    where?: TenderHeatmapWhereInput
    data: XOR<TenderHeatmapUpdateWithoutTenderInput, TenderHeatmapUncheckedUpdateWithoutTenderInput>
  }

  export type TenderHeatmapUpdateWithoutTenderInput = {
    cells?: JsonNullValueInput | InputJsonValue
  }

  export type TenderHeatmapUncheckedUpdateWithoutTenderInput = {
    cells?: JsonNullValueInput | InputJsonValue
  }

  export type TenderComplianceDashboardUpsertWithoutTenderInput = {
    update: XOR<TenderComplianceDashboardUpdateWithoutTenderInput, TenderComplianceDashboardUncheckedUpdateWithoutTenderInput>
    create: XOR<TenderComplianceDashboardCreateWithoutTenderInput, TenderComplianceDashboardUncheckedCreateWithoutTenderInput>
    where?: TenderComplianceDashboardWhereInput
  }

  export type TenderComplianceDashboardUpdateToOneWithWhereWithoutTenderInput = {
    where?: TenderComplianceDashboardWhereInput
    data: XOR<TenderComplianceDashboardUpdateWithoutTenderInput, TenderComplianceDashboardUncheckedUpdateWithoutTenderInput>
  }

  export type TenderComplianceDashboardUpdateWithoutTenderInput = {
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type TenderComplianceDashboardUncheckedUpdateWithoutTenderInput = {
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type BbbeeCreateWithoutBidderInput = {
    id?: string
    level?: number | null
    expiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BbbeeUncheckedCreateWithoutBidderInput = {
    id?: string
    level?: number | null
    expiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BbbeeCreateOrConnectWithoutBidderInput = {
    where: BbbeeWhereUniqueInput
    create: XOR<BbbeeCreateWithoutBidderInput, BbbeeUncheckedCreateWithoutBidderInput>
  }

  export type TenderCreateWithoutBiddersInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationConfig?: EvaluationConfigCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutTenderInput
    tenant?: TenantCreateNestedOneWithoutTendersInput
    timelineEvents?: TenderTimelineEventCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateWithoutBiddersInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
    evaluationConfig?: EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsUncheckedCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderCreateOrConnectWithoutBiddersInput = {
    where: TenderWhereUniqueInput
    create: XOR<TenderCreateWithoutBiddersInput, TenderUncheckedCreateWithoutBiddersInput>
  }

  export type BidderCriterionScoreCreateWithoutBidderInput = {
    id?: string
    criterionCode: string
    rawScore: number
    scaleMax: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidderCriterionScoreUncheckedCreateWithoutBidderInput = {
    id?: string
    criterionCode: string
    rawScore: number
    scaleMax: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidderCriterionScoreCreateOrConnectWithoutBidderInput = {
    where: BidderCriterionScoreWhereUniqueInput
    create: XOR<BidderCriterionScoreCreateWithoutBidderInput, BidderCriterionScoreUncheckedCreateWithoutBidderInput>
  }

  export type BidderCriterionScoreCreateManyBidderInputEnvelope = {
    data: BidderCriterionScoreCreateManyBidderInput | BidderCriterionScoreCreateManyBidderInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationResultCreateWithoutBidderInput = {
    id?: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    compliance?: ComplianceItemCreateNestedManyWithoutEvaluationResultInput
    exceptions?: EvaluationExceptionCreateNestedManyWithoutEvaluationResultInput
    tender: TenderCreateNestedOneWithoutEvaluationResultsInput
    workflowLogs?: WorkflowLogCreateNestedManyWithoutEvaluationResultInput
  }

  export type EvaluationResultUncheckedCreateWithoutBidderInput = {
    id?: string
    tenderId: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    compliance?: ComplianceItemUncheckedCreateNestedManyWithoutEvaluationResultInput
    exceptions?: EvaluationExceptionUncheckedCreateNestedManyWithoutEvaluationResultInput
    workflowLogs?: WorkflowLogUncheckedCreateNestedManyWithoutEvaluationResultInput
  }

  export type EvaluationResultCreateOrConnectWithoutBidderInput = {
    where: EvaluationResultWhereUniqueInput
    create: XOR<EvaluationResultCreateWithoutBidderInput, EvaluationResultUncheckedCreateWithoutBidderInput>
  }

  export type EvaluationResultCreateManyBidderInputEnvelope = {
    data: EvaluationResultCreateManyBidderInput | EvaluationResultCreateManyBidderInput[]
    skipDuplicates?: boolean
  }

  export type EvidenceCreateWithoutBidderInput = {
    id?: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceUncheckedCreateWithoutBidderInput = {
    id?: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceCreateOrConnectWithoutBidderInput = {
    where: EvidenceWhereUniqueInput
    create: XOR<EvidenceCreateWithoutBidderInput, EvidenceUncheckedCreateWithoutBidderInput>
  }

  export type EvidenceCreateManyBidderInputEnvelope = {
    data: EvidenceCreateManyBidderInput | EvidenceCreateManyBidderInput[]
    skipDuplicates?: boolean
  }

  export type BidderIntelligenceCreateWithoutBidderInput = {
    timeline: JsonNullValueInput | InputJsonValue
  }

  export type BidderIntelligenceUncheckedCreateWithoutBidderInput = {
    timeline: JsonNullValueInput | InputJsonValue
  }

  export type BidderIntelligenceCreateOrConnectWithoutBidderInput = {
    where: BidderIntelligenceWhereUniqueInput
    create: XOR<BidderIntelligenceCreateWithoutBidderInput, BidderIntelligenceUncheckedCreateWithoutBidderInput>
  }

  export type BidderRiskProfileCreateWithoutBidderInput = {
    profile: JsonNullValueInput | InputJsonValue
  }

  export type BidderRiskProfileUncheckedCreateWithoutBidderInput = {
    profile: JsonNullValueInput | InputJsonValue
  }

  export type BidderRiskProfileCreateOrConnectWithoutBidderInput = {
    where: BidderRiskProfileWhereUniqueInput
    create: XOR<BidderRiskProfileCreateWithoutBidderInput, BidderRiskProfileUncheckedCreateWithoutBidderInput>
  }

  export type BbbeeUpsertWithoutBidderInput = {
    update: XOR<BbbeeUpdateWithoutBidderInput, BbbeeUncheckedUpdateWithoutBidderInput>
    create: XOR<BbbeeCreateWithoutBidderInput, BbbeeUncheckedCreateWithoutBidderInput>
    where?: BbbeeWhereInput
  }

  export type BbbeeUpdateToOneWithWhereWithoutBidderInput = {
    where?: BbbeeWhereInput
    data: XOR<BbbeeUpdateWithoutBidderInput, BbbeeUncheckedUpdateWithoutBidderInput>
  }

  export type BbbeeUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BbbeeUncheckedUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenderUpsertWithoutBiddersInput = {
    update: XOR<TenderUpdateWithoutBiddersInput, TenderUncheckedUpdateWithoutBiddersInput>
    create: XOR<TenderCreateWithoutBiddersInput, TenderUncheckedCreateWithoutBiddersInput>
    where?: TenderWhereInput
  }

  export type TenderUpdateToOneWithWhereWithoutBiddersInput = {
    where?: TenderWhereInput
    data: XOR<TenderUpdateWithoutBiddersInput, TenderUncheckedUpdateWithoutBiddersInput>
  }

  export type TenderUpdateWithoutBiddersInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationConfig?: EvaluationConfigUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutTenderNestedInput
    tenant?: TenantUpdateOneWithoutTendersNestedInput
    timelineEvents?: TenderTimelineEventUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateWithoutBiddersInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationConfig?: EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type BidderCriterionScoreUpsertWithWhereUniqueWithoutBidderInput = {
    where: BidderCriterionScoreWhereUniqueInput
    update: XOR<BidderCriterionScoreUpdateWithoutBidderInput, BidderCriterionScoreUncheckedUpdateWithoutBidderInput>
    create: XOR<BidderCriterionScoreCreateWithoutBidderInput, BidderCriterionScoreUncheckedCreateWithoutBidderInput>
  }

  export type BidderCriterionScoreUpdateWithWhereUniqueWithoutBidderInput = {
    where: BidderCriterionScoreWhereUniqueInput
    data: XOR<BidderCriterionScoreUpdateWithoutBidderInput, BidderCriterionScoreUncheckedUpdateWithoutBidderInput>
  }

  export type BidderCriterionScoreUpdateManyWithWhereWithoutBidderInput = {
    where: BidderCriterionScoreScalarWhereInput
    data: XOR<BidderCriterionScoreUpdateManyMutationInput, BidderCriterionScoreUncheckedUpdateManyWithoutBidderInput>
  }

  export type BidderCriterionScoreScalarWhereInput = {
    AND?: BidderCriterionScoreScalarWhereInput | BidderCriterionScoreScalarWhereInput[]
    OR?: BidderCriterionScoreScalarWhereInput[]
    NOT?: BidderCriterionScoreScalarWhereInput | BidderCriterionScoreScalarWhereInput[]
    id?: StringFilter<"BidderCriterionScore"> | string
    bidderId?: StringFilter<"BidderCriterionScore"> | string
    criterionCode?: StringFilter<"BidderCriterionScore"> | string
    rawScore?: FloatFilter<"BidderCriterionScore"> | number
    scaleMax?: FloatFilter<"BidderCriterionScore"> | number
    weight?: FloatFilter<"BidderCriterionScore"> | number
    createdAt?: DateTimeFilter<"BidderCriterionScore"> | Date | string
    updatedAt?: DateTimeFilter<"BidderCriterionScore"> | Date | string
  }

  export type EvaluationResultUpsertWithWhereUniqueWithoutBidderInput = {
    where: EvaluationResultWhereUniqueInput
    update: XOR<EvaluationResultUpdateWithoutBidderInput, EvaluationResultUncheckedUpdateWithoutBidderInput>
    create: XOR<EvaluationResultCreateWithoutBidderInput, EvaluationResultUncheckedCreateWithoutBidderInput>
  }

  export type EvaluationResultUpdateWithWhereUniqueWithoutBidderInput = {
    where: EvaluationResultWhereUniqueInput
    data: XOR<EvaluationResultUpdateWithoutBidderInput, EvaluationResultUncheckedUpdateWithoutBidderInput>
  }

  export type EvaluationResultUpdateManyWithWhereWithoutBidderInput = {
    where: EvaluationResultScalarWhereInput
    data: XOR<EvaluationResultUpdateManyMutationInput, EvaluationResultUncheckedUpdateManyWithoutBidderInput>
  }

  export type EvidenceUpsertWithWhereUniqueWithoutBidderInput = {
    where: EvidenceWhereUniqueInput
    update: XOR<EvidenceUpdateWithoutBidderInput, EvidenceUncheckedUpdateWithoutBidderInput>
    create: XOR<EvidenceCreateWithoutBidderInput, EvidenceUncheckedCreateWithoutBidderInput>
  }

  export type EvidenceUpdateWithWhereUniqueWithoutBidderInput = {
    where: EvidenceWhereUniqueInput
    data: XOR<EvidenceUpdateWithoutBidderInput, EvidenceUncheckedUpdateWithoutBidderInput>
  }

  export type EvidenceUpdateManyWithWhereWithoutBidderInput = {
    where: EvidenceScalarWhereInput
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyWithoutBidderInput>
  }

  export type EvidenceScalarWhereInput = {
    AND?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
    OR?: EvidenceScalarWhereInput[]
    NOT?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
    id?: StringFilter<"Evidence"> | string
    bidderId?: StringFilter<"Evidence"> | string
    type?: StringFilter<"Evidence"> | string
    metadata?: JsonNullableFilter<"Evidence">
    url?: StringNullableFilter<"Evidence"> | string | null
    createdAt?: DateTimeFilter<"Evidence"> | Date | string
    updatedAt?: DateTimeFilter<"Evidence"> | Date | string
  }

  export type BidderIntelligenceUpsertWithoutBidderInput = {
    update: XOR<BidderIntelligenceUpdateWithoutBidderInput, BidderIntelligenceUncheckedUpdateWithoutBidderInput>
    create: XOR<BidderIntelligenceCreateWithoutBidderInput, BidderIntelligenceUncheckedCreateWithoutBidderInput>
    where?: BidderIntelligenceWhereInput
  }

  export type BidderIntelligenceUpdateToOneWithWhereWithoutBidderInput = {
    where?: BidderIntelligenceWhereInput
    data: XOR<BidderIntelligenceUpdateWithoutBidderInput, BidderIntelligenceUncheckedUpdateWithoutBidderInput>
  }

  export type BidderIntelligenceUpdateWithoutBidderInput = {
    timeline?: JsonNullValueInput | InputJsonValue
  }

  export type BidderIntelligenceUncheckedUpdateWithoutBidderInput = {
    timeline?: JsonNullValueInput | InputJsonValue
  }

  export type BidderRiskProfileUpsertWithoutBidderInput = {
    update: XOR<BidderRiskProfileUpdateWithoutBidderInput, BidderRiskProfileUncheckedUpdateWithoutBidderInput>
    create: XOR<BidderRiskProfileCreateWithoutBidderInput, BidderRiskProfileUncheckedCreateWithoutBidderInput>
    where?: BidderRiskProfileWhereInput
  }

  export type BidderRiskProfileUpdateToOneWithWhereWithoutBidderInput = {
    where?: BidderRiskProfileWhereInput
    data: XOR<BidderRiskProfileUpdateWithoutBidderInput, BidderRiskProfileUncheckedUpdateWithoutBidderInput>
  }

  export type BidderRiskProfileUpdateWithoutBidderInput = {
    profile?: JsonNullValueInput | InputJsonValue
  }

  export type BidderRiskProfileUncheckedUpdateWithoutBidderInput = {
    profile?: JsonNullValueInput | InputJsonValue
  }

  export type BidderCreateWithoutBbbeeInput = {
    id?: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tender: TenderCreateNestedOneWithoutBiddersInput
    technicalScores?: BidderCriterionScoreCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutBidderInput
    evidence?: EvidenceCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileCreateNestedOneWithoutBidderInput
  }

  export type BidderUncheckedCreateWithoutBbbeeInput = {
    id?: string
    tenderId: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    technicalScores?: BidderCriterionScoreUncheckedCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutBidderInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceUncheckedCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileUncheckedCreateNestedOneWithoutBidderInput
  }

  export type BidderCreateOrConnectWithoutBbbeeInput = {
    where: BidderWhereUniqueInput
    create: XOR<BidderCreateWithoutBbbeeInput, BidderUncheckedCreateWithoutBbbeeInput>
  }

  export type BidderUpsertWithoutBbbeeInput = {
    update: XOR<BidderUpdateWithoutBbbeeInput, BidderUncheckedUpdateWithoutBbbeeInput>
    create: XOR<BidderCreateWithoutBbbeeInput, BidderUncheckedCreateWithoutBbbeeInput>
    where?: BidderWhereInput
  }

  export type BidderUpdateToOneWithWhereWithoutBbbeeInput = {
    where?: BidderWhereInput
    data: XOR<BidderUpdateWithoutBbbeeInput, BidderUncheckedUpdateWithoutBbbeeInput>
  }

  export type BidderUpdateWithoutBbbeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tender?: TenderUpdateOneRequiredWithoutBiddersNestedInput
    technicalScores?: BidderCriterionScoreUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUpdateOneWithoutBidderNestedInput
  }

  export type BidderUncheckedUpdateWithoutBbbeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    technicalScores?: BidderCriterionScoreUncheckedUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUncheckedUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUncheckedUpdateOneWithoutBidderNestedInput
  }

  export type BidderCreateWithoutEvidenceInput = {
    id?: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeCreateNestedOneWithoutBidderInput
    tender: TenderCreateNestedOneWithoutBiddersInput
    technicalScores?: BidderCriterionScoreCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileCreateNestedOneWithoutBidderInput
  }

  export type BidderUncheckedCreateWithoutEvidenceInput = {
    id?: string
    tenderId: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeUncheckedCreateNestedOneWithoutBidderInput
    technicalScores?: BidderCriterionScoreUncheckedCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceUncheckedCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileUncheckedCreateNestedOneWithoutBidderInput
  }

  export type BidderCreateOrConnectWithoutEvidenceInput = {
    where: BidderWhereUniqueInput
    create: XOR<BidderCreateWithoutEvidenceInput, BidderUncheckedCreateWithoutEvidenceInput>
  }

  export type BidderUpsertWithoutEvidenceInput = {
    update: XOR<BidderUpdateWithoutEvidenceInput, BidderUncheckedUpdateWithoutEvidenceInput>
    create: XOR<BidderCreateWithoutEvidenceInput, BidderUncheckedCreateWithoutEvidenceInput>
    where?: BidderWhereInput
  }

  export type BidderUpdateToOneWithWhereWithoutEvidenceInput = {
    where?: BidderWhereInput
    data: XOR<BidderUpdateWithoutEvidenceInput, BidderUncheckedUpdateWithoutEvidenceInput>
  }

  export type BidderUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUpdateOneWithoutBidderNestedInput
    tender?: TenderUpdateOneRequiredWithoutBiddersNestedInput
    technicalScores?: BidderCriterionScoreUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUpdateOneWithoutBidderNestedInput
  }

  export type BidderUncheckedUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUncheckedUpdateOneWithoutBidderNestedInput
    technicalScores?: BidderCriterionScoreUncheckedUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUncheckedUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUncheckedUpdateOneWithoutBidderNestedInput
  }

  export type TenderCreateWithoutEvaluationConfigInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderCreateNestedManyWithoutTenderInput
    documents?: EvaluationDocumentCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutTenderInput
    tenant?: TenantCreateNestedOneWithoutTendersInput
    timelineEvents?: TenderTimelineEventCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateWithoutEvaluationConfigInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
    bidders?: BidderUncheckedCreateNestedManyWithoutTenderInput
    documents?: EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsUncheckedCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderCreateOrConnectWithoutEvaluationConfigInput = {
    where: TenderWhereUniqueInput
    create: XOR<TenderCreateWithoutEvaluationConfigInput, TenderUncheckedCreateWithoutEvaluationConfigInput>
  }

  export type TenderUpsertWithoutEvaluationConfigInput = {
    update: XOR<TenderUpdateWithoutEvaluationConfigInput, TenderUncheckedUpdateWithoutEvaluationConfigInput>
    create: XOR<TenderCreateWithoutEvaluationConfigInput, TenderUncheckedCreateWithoutEvaluationConfigInput>
    where?: TenderWhereInput
  }

  export type TenderUpdateToOneWithWhereWithoutEvaluationConfigInput = {
    where?: TenderWhereInput
    data: XOR<TenderUpdateWithoutEvaluationConfigInput, TenderUncheckedUpdateWithoutEvaluationConfigInput>
  }

  export type TenderUpdateWithoutEvaluationConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUpdateManyWithoutTenderNestedInput
    documents?: EvaluationDocumentUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutTenderNestedInput
    tenant?: TenantUpdateOneWithoutTendersNestedInput
    timelineEvents?: TenderTimelineEventUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateWithoutEvaluationConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    bidders?: BidderUncheckedUpdateManyWithoutTenderNestedInput
    documents?: EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type BidderCreateWithoutTechnicalScoresInput = {
    id?: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeCreateNestedOneWithoutBidderInput
    tender: TenderCreateNestedOneWithoutBiddersInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutBidderInput
    evidence?: EvidenceCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileCreateNestedOneWithoutBidderInput
  }

  export type BidderUncheckedCreateWithoutTechnicalScoresInput = {
    id?: string
    tenderId: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeUncheckedCreateNestedOneWithoutBidderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutBidderInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceUncheckedCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileUncheckedCreateNestedOneWithoutBidderInput
  }

  export type BidderCreateOrConnectWithoutTechnicalScoresInput = {
    where: BidderWhereUniqueInput
    create: XOR<BidderCreateWithoutTechnicalScoresInput, BidderUncheckedCreateWithoutTechnicalScoresInput>
  }

  export type BidderUpsertWithoutTechnicalScoresInput = {
    update: XOR<BidderUpdateWithoutTechnicalScoresInput, BidderUncheckedUpdateWithoutTechnicalScoresInput>
    create: XOR<BidderCreateWithoutTechnicalScoresInput, BidderUncheckedCreateWithoutTechnicalScoresInput>
    where?: BidderWhereInput
  }

  export type BidderUpdateToOneWithWhereWithoutTechnicalScoresInput = {
    where?: BidderWhereInput
    data: XOR<BidderUpdateWithoutTechnicalScoresInput, BidderUncheckedUpdateWithoutTechnicalScoresInput>
  }

  export type BidderUpdateWithoutTechnicalScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUpdateOneWithoutBidderNestedInput
    tender?: TenderUpdateOneRequiredWithoutBiddersNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUpdateOneWithoutBidderNestedInput
  }

  export type BidderUncheckedUpdateWithoutTechnicalScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUncheckedUpdateOneWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUncheckedUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUncheckedUpdateOneWithoutBidderNestedInput
  }

  export type ComplianceItemCreateWithoutEvaluationResultInput = {
    id?: string
    compliant: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rule: ComplianceRuleCreateNestedOneWithoutItemsInput
  }

  export type ComplianceItemUncheckedCreateWithoutEvaluationResultInput = {
    id?: string
    ruleId: string
    compliant: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceItemCreateOrConnectWithoutEvaluationResultInput = {
    where: ComplianceItemWhereUniqueInput
    create: XOR<ComplianceItemCreateWithoutEvaluationResultInput, ComplianceItemUncheckedCreateWithoutEvaluationResultInput>
  }

  export type ComplianceItemCreateManyEvaluationResultInputEnvelope = {
    data: ComplianceItemCreateManyEvaluationResultInput | ComplianceItemCreateManyEvaluationResultInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationExceptionCreateWithoutEvaluationResultInput = {
    id?: string
    type: string
    reason: string
    approved?: boolean | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationExceptionUncheckedCreateWithoutEvaluationResultInput = {
    id?: string
    type: string
    reason: string
    approved?: boolean | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationExceptionCreateOrConnectWithoutEvaluationResultInput = {
    where: EvaluationExceptionWhereUniqueInput
    create: XOR<EvaluationExceptionCreateWithoutEvaluationResultInput, EvaluationExceptionUncheckedCreateWithoutEvaluationResultInput>
  }

  export type EvaluationExceptionCreateManyEvaluationResultInputEnvelope = {
    data: EvaluationExceptionCreateManyEvaluationResultInput | EvaluationExceptionCreateManyEvaluationResultInput[]
    skipDuplicates?: boolean
  }

  export type BidderCreateWithoutEvaluationResultsInput = {
    id?: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeCreateNestedOneWithoutBidderInput
    tender: TenderCreateNestedOneWithoutBiddersInput
    technicalScores?: BidderCriterionScoreCreateNestedManyWithoutBidderInput
    evidence?: EvidenceCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileCreateNestedOneWithoutBidderInput
  }

  export type BidderUncheckedCreateWithoutEvaluationResultsInput = {
    id?: string
    tenderId: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeUncheckedCreateNestedOneWithoutBidderInput
    technicalScores?: BidderCriterionScoreUncheckedCreateNestedManyWithoutBidderInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceUncheckedCreateNestedOneWithoutBidderInput
    riskProfile?: BidderRiskProfileUncheckedCreateNestedOneWithoutBidderInput
  }

  export type BidderCreateOrConnectWithoutEvaluationResultsInput = {
    where: BidderWhereUniqueInput
    create: XOR<BidderCreateWithoutEvaluationResultsInput, BidderUncheckedCreateWithoutEvaluationResultsInput>
  }

  export type TenderCreateWithoutEvaluationResultsInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutTenderInput
    tenant?: TenantCreateNestedOneWithoutTendersInput
    timelineEvents?: TenderTimelineEventCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateWithoutEvaluationResultsInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
    bidders?: BidderUncheckedCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsUncheckedCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderCreateOrConnectWithoutEvaluationResultsInput = {
    where: TenderWhereUniqueInput
    create: XOR<TenderCreateWithoutEvaluationResultsInput, TenderUncheckedCreateWithoutEvaluationResultsInput>
  }

  export type WorkflowLogCreateWithoutEvaluationResultInput = {
    id?: string
    stage: string
    daysSpent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowLogUncheckedCreateWithoutEvaluationResultInput = {
    id?: string
    stage: string
    daysSpent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowLogCreateOrConnectWithoutEvaluationResultInput = {
    where: WorkflowLogWhereUniqueInput
    create: XOR<WorkflowLogCreateWithoutEvaluationResultInput, WorkflowLogUncheckedCreateWithoutEvaluationResultInput>
  }

  export type WorkflowLogCreateManyEvaluationResultInputEnvelope = {
    data: WorkflowLogCreateManyEvaluationResultInput | WorkflowLogCreateManyEvaluationResultInput[]
    skipDuplicates?: boolean
  }

  export type ComplianceItemUpsertWithWhereUniqueWithoutEvaluationResultInput = {
    where: ComplianceItemWhereUniqueInput
    update: XOR<ComplianceItemUpdateWithoutEvaluationResultInput, ComplianceItemUncheckedUpdateWithoutEvaluationResultInput>
    create: XOR<ComplianceItemCreateWithoutEvaluationResultInput, ComplianceItemUncheckedCreateWithoutEvaluationResultInput>
  }

  export type ComplianceItemUpdateWithWhereUniqueWithoutEvaluationResultInput = {
    where: ComplianceItemWhereUniqueInput
    data: XOR<ComplianceItemUpdateWithoutEvaluationResultInput, ComplianceItemUncheckedUpdateWithoutEvaluationResultInput>
  }

  export type ComplianceItemUpdateManyWithWhereWithoutEvaluationResultInput = {
    where: ComplianceItemScalarWhereInput
    data: XOR<ComplianceItemUpdateManyMutationInput, ComplianceItemUncheckedUpdateManyWithoutEvaluationResultInput>
  }

  export type ComplianceItemScalarWhereInput = {
    AND?: ComplianceItemScalarWhereInput | ComplianceItemScalarWhereInput[]
    OR?: ComplianceItemScalarWhereInput[]
    NOT?: ComplianceItemScalarWhereInput | ComplianceItemScalarWhereInput[]
    id?: StringFilter<"ComplianceItem"> | string
    evaluationResultId?: StringFilter<"ComplianceItem"> | string
    ruleId?: StringFilter<"ComplianceItem"> | string
    compliant?: BoolFilter<"ComplianceItem"> | boolean
    createdAt?: DateTimeFilter<"ComplianceItem"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceItem"> | Date | string
  }

  export type EvaluationExceptionUpsertWithWhereUniqueWithoutEvaluationResultInput = {
    where: EvaluationExceptionWhereUniqueInput
    update: XOR<EvaluationExceptionUpdateWithoutEvaluationResultInput, EvaluationExceptionUncheckedUpdateWithoutEvaluationResultInput>
    create: XOR<EvaluationExceptionCreateWithoutEvaluationResultInput, EvaluationExceptionUncheckedCreateWithoutEvaluationResultInput>
  }

  export type EvaluationExceptionUpdateWithWhereUniqueWithoutEvaluationResultInput = {
    where: EvaluationExceptionWhereUniqueInput
    data: XOR<EvaluationExceptionUpdateWithoutEvaluationResultInput, EvaluationExceptionUncheckedUpdateWithoutEvaluationResultInput>
  }

  export type EvaluationExceptionUpdateManyWithWhereWithoutEvaluationResultInput = {
    where: EvaluationExceptionScalarWhereInput
    data: XOR<EvaluationExceptionUpdateManyMutationInput, EvaluationExceptionUncheckedUpdateManyWithoutEvaluationResultInput>
  }

  export type EvaluationExceptionScalarWhereInput = {
    AND?: EvaluationExceptionScalarWhereInput | EvaluationExceptionScalarWhereInput[]
    OR?: EvaluationExceptionScalarWhereInput[]
    NOT?: EvaluationExceptionScalarWhereInput | EvaluationExceptionScalarWhereInput[]
    id?: StringFilter<"EvaluationException"> | string
    evaluationResultId?: StringFilter<"EvaluationException"> | string
    type?: StringFilter<"EvaluationException"> | string
    reason?: StringFilter<"EvaluationException"> | string
    approved?: BoolNullableFilter<"EvaluationException"> | boolean | null
    approvedBy?: StringNullableFilter<"EvaluationException"> | string | null
    approvedAt?: DateTimeNullableFilter<"EvaluationException"> | Date | string | null
    createdAt?: DateTimeFilter<"EvaluationException"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationException"> | Date | string
  }

  export type BidderUpsertWithoutEvaluationResultsInput = {
    update: XOR<BidderUpdateWithoutEvaluationResultsInput, BidderUncheckedUpdateWithoutEvaluationResultsInput>
    create: XOR<BidderCreateWithoutEvaluationResultsInput, BidderUncheckedCreateWithoutEvaluationResultsInput>
    where?: BidderWhereInput
  }

  export type BidderUpdateToOneWithWhereWithoutEvaluationResultsInput = {
    where?: BidderWhereInput
    data: XOR<BidderUpdateWithoutEvaluationResultsInput, BidderUncheckedUpdateWithoutEvaluationResultsInput>
  }

  export type BidderUpdateWithoutEvaluationResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUpdateOneWithoutBidderNestedInput
    tender?: TenderUpdateOneRequiredWithoutBiddersNestedInput
    technicalScores?: BidderCriterionScoreUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUpdateOneWithoutBidderNestedInput
  }

  export type BidderUncheckedUpdateWithoutEvaluationResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUncheckedUpdateOneWithoutBidderNestedInput
    technicalScores?: BidderCriterionScoreUncheckedUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUncheckedUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUncheckedUpdateOneWithoutBidderNestedInput
  }

  export type TenderUpsertWithoutEvaluationResultsInput = {
    update: XOR<TenderUpdateWithoutEvaluationResultsInput, TenderUncheckedUpdateWithoutEvaluationResultsInput>
    create: XOR<TenderCreateWithoutEvaluationResultsInput, TenderUncheckedCreateWithoutEvaluationResultsInput>
    where?: TenderWhereInput
  }

  export type TenderUpdateToOneWithWhereWithoutEvaluationResultsInput = {
    where?: TenderWhereInput
    data: XOR<TenderUpdateWithoutEvaluationResultsInput, TenderUncheckedUpdateWithoutEvaluationResultsInput>
  }

  export type TenderUpdateWithoutEvaluationResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutTenderNestedInput
    tenant?: TenantUpdateOneWithoutTendersNestedInput
    timelineEvents?: TenderTimelineEventUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateWithoutEvaluationResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    bidders?: BidderUncheckedUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type WorkflowLogUpsertWithWhereUniqueWithoutEvaluationResultInput = {
    where: WorkflowLogWhereUniqueInput
    update: XOR<WorkflowLogUpdateWithoutEvaluationResultInput, WorkflowLogUncheckedUpdateWithoutEvaluationResultInput>
    create: XOR<WorkflowLogCreateWithoutEvaluationResultInput, WorkflowLogUncheckedCreateWithoutEvaluationResultInput>
  }

  export type WorkflowLogUpdateWithWhereUniqueWithoutEvaluationResultInput = {
    where: WorkflowLogWhereUniqueInput
    data: XOR<WorkflowLogUpdateWithoutEvaluationResultInput, WorkflowLogUncheckedUpdateWithoutEvaluationResultInput>
  }

  export type WorkflowLogUpdateManyWithWhereWithoutEvaluationResultInput = {
    where: WorkflowLogScalarWhereInput
    data: XOR<WorkflowLogUpdateManyMutationInput, WorkflowLogUncheckedUpdateManyWithoutEvaluationResultInput>
  }

  export type WorkflowLogScalarWhereInput = {
    AND?: WorkflowLogScalarWhereInput | WorkflowLogScalarWhereInput[]
    OR?: WorkflowLogScalarWhereInput[]
    NOT?: WorkflowLogScalarWhereInput | WorkflowLogScalarWhereInput[]
    id?: StringFilter<"WorkflowLog"> | string
    evaluationResultId?: StringFilter<"WorkflowLog"> | string
    stage?: StringFilter<"WorkflowLog"> | string
    daysSpent?: FloatFilter<"WorkflowLog"> | number
    createdAt?: DateTimeFilter<"WorkflowLog"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowLog"> | Date | string
  }

  export type EvaluationResultCreateWithoutWorkflowLogsInput = {
    id?: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    compliance?: ComplianceItemCreateNestedManyWithoutEvaluationResultInput
    exceptions?: EvaluationExceptionCreateNestedManyWithoutEvaluationResultInput
    bidder: BidderCreateNestedOneWithoutEvaluationResultsInput
    tender: TenderCreateNestedOneWithoutEvaluationResultsInput
  }

  export type EvaluationResultUncheckedCreateWithoutWorkflowLogsInput = {
    id?: string
    tenderId: string
    bidderId: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    compliance?: ComplianceItemUncheckedCreateNestedManyWithoutEvaluationResultInput
    exceptions?: EvaluationExceptionUncheckedCreateNestedManyWithoutEvaluationResultInput
  }

  export type EvaluationResultCreateOrConnectWithoutWorkflowLogsInput = {
    where: EvaluationResultWhereUniqueInput
    create: XOR<EvaluationResultCreateWithoutWorkflowLogsInput, EvaluationResultUncheckedCreateWithoutWorkflowLogsInput>
  }

  export type EvaluationResultUpsertWithoutWorkflowLogsInput = {
    update: XOR<EvaluationResultUpdateWithoutWorkflowLogsInput, EvaluationResultUncheckedUpdateWithoutWorkflowLogsInput>
    create: XOR<EvaluationResultCreateWithoutWorkflowLogsInput, EvaluationResultUncheckedCreateWithoutWorkflowLogsInput>
    where?: EvaluationResultWhereInput
  }

  export type EvaluationResultUpdateToOneWithWhereWithoutWorkflowLogsInput = {
    where?: EvaluationResultWhereInput
    data: XOR<EvaluationResultUpdateWithoutWorkflowLogsInput, EvaluationResultUncheckedUpdateWithoutWorkflowLogsInput>
  }

  export type EvaluationResultUpdateWithoutWorkflowLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    compliance?: ComplianceItemUpdateManyWithoutEvaluationResultNestedInput
    exceptions?: EvaluationExceptionUpdateManyWithoutEvaluationResultNestedInput
    bidder?: BidderUpdateOneRequiredWithoutEvaluationResultsNestedInput
    tender?: TenderUpdateOneRequiredWithoutEvaluationResultsNestedInput
  }

  export type EvaluationResultUncheckedUpdateWithoutWorkflowLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    compliance?: ComplianceItemUncheckedUpdateManyWithoutEvaluationResultNestedInput
    exceptions?: EvaluationExceptionUncheckedUpdateManyWithoutEvaluationResultNestedInput
  }

  export type ComplianceRuleCreateWithoutCircularInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ComplianceItemCreateNestedManyWithoutRuleInput
  }

  export type ComplianceRuleUncheckedCreateWithoutCircularInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ComplianceItemUncheckedCreateNestedManyWithoutRuleInput
  }

  export type ComplianceRuleCreateOrConnectWithoutCircularInput = {
    where: ComplianceRuleWhereUniqueInput
    create: XOR<ComplianceRuleCreateWithoutCircularInput, ComplianceRuleUncheckedCreateWithoutCircularInput>
  }

  export type ComplianceRuleCreateManyCircularInputEnvelope = {
    data: ComplianceRuleCreateManyCircularInput | ComplianceRuleCreateManyCircularInput[]
    skipDuplicates?: boolean
  }

  export type ComplianceRuleUpsertWithWhereUniqueWithoutCircularInput = {
    where: ComplianceRuleWhereUniqueInput
    update: XOR<ComplianceRuleUpdateWithoutCircularInput, ComplianceRuleUncheckedUpdateWithoutCircularInput>
    create: XOR<ComplianceRuleCreateWithoutCircularInput, ComplianceRuleUncheckedCreateWithoutCircularInput>
  }

  export type ComplianceRuleUpdateWithWhereUniqueWithoutCircularInput = {
    where: ComplianceRuleWhereUniqueInput
    data: XOR<ComplianceRuleUpdateWithoutCircularInput, ComplianceRuleUncheckedUpdateWithoutCircularInput>
  }

  export type ComplianceRuleUpdateManyWithWhereWithoutCircularInput = {
    where: ComplianceRuleScalarWhereInput
    data: XOR<ComplianceRuleUpdateManyMutationInput, ComplianceRuleUncheckedUpdateManyWithoutCircularInput>
  }

  export type ComplianceRuleScalarWhereInput = {
    AND?: ComplianceRuleScalarWhereInput | ComplianceRuleScalarWhereInput[]
    OR?: ComplianceRuleScalarWhereInput[]
    NOT?: ComplianceRuleScalarWhereInput | ComplianceRuleScalarWhereInput[]
    id?: StringFilter<"ComplianceRule"> | string
    circularId?: StringFilter<"ComplianceRule"> | string
    code?: StringFilter<"ComplianceRule"> | string
    label?: StringFilter<"ComplianceRule"> | string
    description?: StringNullableFilter<"ComplianceRule"> | string | null
    createdAt?: DateTimeFilter<"ComplianceRule"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceRule"> | Date | string
  }

  export type ComplianceItemCreateWithoutRuleInput = {
    id?: string
    compliant: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationResult: EvaluationResultCreateNestedOneWithoutComplianceInput
  }

  export type ComplianceItemUncheckedCreateWithoutRuleInput = {
    id?: string
    evaluationResultId: string
    compliant: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceItemCreateOrConnectWithoutRuleInput = {
    where: ComplianceItemWhereUniqueInput
    create: XOR<ComplianceItemCreateWithoutRuleInput, ComplianceItemUncheckedCreateWithoutRuleInput>
  }

  export type ComplianceItemCreateManyRuleInputEnvelope = {
    data: ComplianceItemCreateManyRuleInput | ComplianceItemCreateManyRuleInput[]
    skipDuplicates?: boolean
  }

  export type CircularCreateWithoutRulesInput = {
    id?: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircularUncheckedCreateWithoutRulesInput = {
    id?: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircularCreateOrConnectWithoutRulesInput = {
    where: CircularWhereUniqueInput
    create: XOR<CircularCreateWithoutRulesInput, CircularUncheckedCreateWithoutRulesInput>
  }

  export type ComplianceItemUpsertWithWhereUniqueWithoutRuleInput = {
    where: ComplianceItemWhereUniqueInput
    update: XOR<ComplianceItemUpdateWithoutRuleInput, ComplianceItemUncheckedUpdateWithoutRuleInput>
    create: XOR<ComplianceItemCreateWithoutRuleInput, ComplianceItemUncheckedCreateWithoutRuleInput>
  }

  export type ComplianceItemUpdateWithWhereUniqueWithoutRuleInput = {
    where: ComplianceItemWhereUniqueInput
    data: XOR<ComplianceItemUpdateWithoutRuleInput, ComplianceItemUncheckedUpdateWithoutRuleInput>
  }

  export type ComplianceItemUpdateManyWithWhereWithoutRuleInput = {
    where: ComplianceItemScalarWhereInput
    data: XOR<ComplianceItemUpdateManyMutationInput, ComplianceItemUncheckedUpdateManyWithoutRuleInput>
  }

  export type CircularUpsertWithoutRulesInput = {
    update: XOR<CircularUpdateWithoutRulesInput, CircularUncheckedUpdateWithoutRulesInput>
    create: XOR<CircularCreateWithoutRulesInput, CircularUncheckedCreateWithoutRulesInput>
    where?: CircularWhereInput
  }

  export type CircularUpdateToOneWithWhereWithoutRulesInput = {
    where?: CircularWhereInput
    data: XOR<CircularUpdateWithoutRulesInput, CircularUncheckedUpdateWithoutRulesInput>
  }

  export type CircularUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircularUncheckedUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationResultCreateWithoutComplianceInput = {
    id?: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    exceptions?: EvaluationExceptionCreateNestedManyWithoutEvaluationResultInput
    bidder: BidderCreateNestedOneWithoutEvaluationResultsInput
    tender: TenderCreateNestedOneWithoutEvaluationResultsInput
    workflowLogs?: WorkflowLogCreateNestedManyWithoutEvaluationResultInput
  }

  export type EvaluationResultUncheckedCreateWithoutComplianceInput = {
    id?: string
    tenderId: string
    bidderId: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    exceptions?: EvaluationExceptionUncheckedCreateNestedManyWithoutEvaluationResultInput
    workflowLogs?: WorkflowLogUncheckedCreateNestedManyWithoutEvaluationResultInput
  }

  export type EvaluationResultCreateOrConnectWithoutComplianceInput = {
    where: EvaluationResultWhereUniqueInput
    create: XOR<EvaluationResultCreateWithoutComplianceInput, EvaluationResultUncheckedCreateWithoutComplianceInput>
  }

  export type ComplianceRuleCreateWithoutItemsInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    circular: CircularCreateNestedOneWithoutRulesInput
  }

  export type ComplianceRuleUncheckedCreateWithoutItemsInput = {
    id?: string
    circularId: string
    code: string
    label: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceRuleCreateOrConnectWithoutItemsInput = {
    where: ComplianceRuleWhereUniqueInput
    create: XOR<ComplianceRuleCreateWithoutItemsInput, ComplianceRuleUncheckedCreateWithoutItemsInput>
  }

  export type EvaluationResultUpsertWithoutComplianceInput = {
    update: XOR<EvaluationResultUpdateWithoutComplianceInput, EvaluationResultUncheckedUpdateWithoutComplianceInput>
    create: XOR<EvaluationResultCreateWithoutComplianceInput, EvaluationResultUncheckedCreateWithoutComplianceInput>
    where?: EvaluationResultWhereInput
  }

  export type EvaluationResultUpdateToOneWithWhereWithoutComplianceInput = {
    where?: EvaluationResultWhereInput
    data: XOR<EvaluationResultUpdateWithoutComplianceInput, EvaluationResultUncheckedUpdateWithoutComplianceInput>
  }

  export type EvaluationResultUpdateWithoutComplianceInput = {
    id?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    exceptions?: EvaluationExceptionUpdateManyWithoutEvaluationResultNestedInput
    bidder?: BidderUpdateOneRequiredWithoutEvaluationResultsNestedInput
    tender?: TenderUpdateOneRequiredWithoutEvaluationResultsNestedInput
    workflowLogs?: WorkflowLogUpdateManyWithoutEvaluationResultNestedInput
  }

  export type EvaluationResultUncheckedUpdateWithoutComplianceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    exceptions?: EvaluationExceptionUncheckedUpdateManyWithoutEvaluationResultNestedInput
    workflowLogs?: WorkflowLogUncheckedUpdateManyWithoutEvaluationResultNestedInput
  }

  export type ComplianceRuleUpsertWithoutItemsInput = {
    update: XOR<ComplianceRuleUpdateWithoutItemsInput, ComplianceRuleUncheckedUpdateWithoutItemsInput>
    create: XOR<ComplianceRuleCreateWithoutItemsInput, ComplianceRuleUncheckedCreateWithoutItemsInput>
    where?: ComplianceRuleWhereInput
  }

  export type ComplianceRuleUpdateToOneWithWhereWithoutItemsInput = {
    where?: ComplianceRuleWhereInput
    data: XOR<ComplianceRuleUpdateWithoutItemsInput, ComplianceRuleUncheckedUpdateWithoutItemsInput>
  }

  export type ComplianceRuleUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    circular?: CircularUpdateOneRequiredWithoutRulesNestedInput
  }

  export type ComplianceRuleUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    circularId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationResultCreateWithoutExceptionsInput = {
    id?: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    compliance?: ComplianceItemCreateNestedManyWithoutEvaluationResultInput
    bidder: BidderCreateNestedOneWithoutEvaluationResultsInput
    tender: TenderCreateNestedOneWithoutEvaluationResultsInput
    workflowLogs?: WorkflowLogCreateNestedManyWithoutEvaluationResultInput
  }

  export type EvaluationResultUncheckedCreateWithoutExceptionsInput = {
    id?: string
    tenderId: string
    bidderId: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
    compliance?: ComplianceItemUncheckedCreateNestedManyWithoutEvaluationResultInput
    workflowLogs?: WorkflowLogUncheckedCreateNestedManyWithoutEvaluationResultInput
  }

  export type EvaluationResultCreateOrConnectWithoutExceptionsInput = {
    where: EvaluationResultWhereUniqueInput
    create: XOR<EvaluationResultCreateWithoutExceptionsInput, EvaluationResultUncheckedCreateWithoutExceptionsInput>
  }

  export type EvaluationResultUpsertWithoutExceptionsInput = {
    update: XOR<EvaluationResultUpdateWithoutExceptionsInput, EvaluationResultUncheckedUpdateWithoutExceptionsInput>
    create: XOR<EvaluationResultCreateWithoutExceptionsInput, EvaluationResultUncheckedCreateWithoutExceptionsInput>
    where?: EvaluationResultWhereInput
  }

  export type EvaluationResultUpdateToOneWithWhereWithoutExceptionsInput = {
    where?: EvaluationResultWhereInput
    data: XOR<EvaluationResultUpdateWithoutExceptionsInput, EvaluationResultUncheckedUpdateWithoutExceptionsInput>
  }

  export type EvaluationResultUpdateWithoutExceptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    compliance?: ComplianceItemUpdateManyWithoutEvaluationResultNestedInput
    bidder?: BidderUpdateOneRequiredWithoutEvaluationResultsNestedInput
    tender?: TenderUpdateOneRequiredWithoutEvaluationResultsNestedInput
    workflowLogs?: WorkflowLogUpdateManyWithoutEvaluationResultNestedInput
  }

  export type EvaluationResultUncheckedUpdateWithoutExceptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    compliance?: ComplianceItemUncheckedUpdateManyWithoutEvaluationResultNestedInput
    workflowLogs?: WorkflowLogUncheckedUpdateManyWithoutEvaluationResultNestedInput
  }

  export type TenderCreateWithoutSignaturesInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutTenderInput
    tenant?: TenantCreateNestedOneWithoutTendersInput
    timelineEvents?: TenderTimelineEventCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateWithoutSignaturesInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
    bidders?: BidderUncheckedCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsUncheckedCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderCreateOrConnectWithoutSignaturesInput = {
    where: TenderWhereUniqueInput
    create: XOR<TenderCreateWithoutSignaturesInput, TenderUncheckedCreateWithoutSignaturesInput>
  }

  export type TenderUpsertWithoutSignaturesInput = {
    update: XOR<TenderUpdateWithoutSignaturesInput, TenderUncheckedUpdateWithoutSignaturesInput>
    create: XOR<TenderCreateWithoutSignaturesInput, TenderUncheckedCreateWithoutSignaturesInput>
    where?: TenderWhereInput
  }

  export type TenderUpdateToOneWithWhereWithoutSignaturesInput = {
    where?: TenderWhereInput
    data: XOR<TenderUpdateWithoutSignaturesInput, TenderUncheckedUpdateWithoutSignaturesInput>
  }

  export type TenderUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutTenderNestedInput
    tenant?: TenantUpdateOneWithoutTendersNestedInput
    timelineEvents?: TenderTimelineEventUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    bidders?: BidderUncheckedUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type TenderCreateWithoutDocumentsInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigCreateNestedOneWithoutTenderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutTenderInput
    tenant?: TenantCreateNestedOneWithoutTendersInput
    timelineEvents?: TenderTimelineEventCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateWithoutDocumentsInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
    bidders?: BidderUncheckedCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsUncheckedCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderCreateOrConnectWithoutDocumentsInput = {
    where: TenderWhereUniqueInput
    create: XOR<TenderCreateWithoutDocumentsInput, TenderUncheckedCreateWithoutDocumentsInput>
  }

  export type TenderUpsertWithoutDocumentsInput = {
    update: XOR<TenderUpdateWithoutDocumentsInput, TenderUncheckedUpdateWithoutDocumentsInput>
    create: XOR<TenderCreateWithoutDocumentsInput, TenderUncheckedCreateWithoutDocumentsInput>
    where?: TenderWhereInput
  }

  export type TenderUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: TenderWhereInput
    data: XOR<TenderUpdateWithoutDocumentsInput, TenderUncheckedUpdateWithoutDocumentsInput>
  }

  export type TenderUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUpdateOneWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutTenderNestedInput
    tenant?: TenantUpdateOneWithoutTendersNestedInput
    timelineEvents?: TenderTimelineEventUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    bidders?: BidderUncheckedUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type UserCreateWithoutAnalyticsLogsInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutUserInput
    tenant?: TenantCreateNestedOneWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationRules?: NotificationRuleCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutAnalyticsLogsInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    tenantId?: string | null
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationRules?: NotificationRuleUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutAnalyticsLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalyticsLogsInput, UserUncheckedCreateWithoutAnalyticsLogsInput>
  }

  export type UserUpsertWithoutAnalyticsLogsInput = {
    update: XOR<UserUpdateWithoutAnalyticsLogsInput, UserUncheckedUpdateWithoutAnalyticsLogsInput>
    create: XOR<UserCreateWithoutAnalyticsLogsInput, UserUncheckedCreateWithoutAnalyticsLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnalyticsLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnalyticsLogsInput, UserUncheckedUpdateWithoutAnalyticsLogsInput>
  }

  export type UserUpdateWithoutAnalyticsLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationRules?: NotificationRuleUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalyticsLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationRules?: NotificationRuleUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    analyticsLogs?: AnalyticsAccessLogCreateNestedManyWithoutUserInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutUserInput
    tenant?: TenantCreateNestedOneWithoutUsersInput
    notificationRules?: NotificationRuleCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    tenantId?: string | null
    analyticsLogs?: AnalyticsAccessLogUncheckedCreateNestedManyWithoutUserInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutUserInput
    notificationRules?: NotificationRuleUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    analyticsLogs?: AnalyticsAccessLogUpdateManyWithoutUserNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    notificationRules?: NotificationRuleUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsLogs?: AnalyticsAccessLogUncheckedUpdateManyWithoutUserNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutUserNestedInput
    notificationRules?: NotificationRuleUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutNotificationRulesInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    analyticsLogs?: AnalyticsAccessLogCreateNestedManyWithoutUserInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutUserInput
    tenant?: TenantCreateNestedOneWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationRulesInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    tenantId?: string | null
    analyticsLogs?: AnalyticsAccessLogUncheckedCreateNestedManyWithoutUserInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationRulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationRulesInput, UserUncheckedCreateWithoutNotificationRulesInput>
  }

  export type UserUpsertWithoutNotificationRulesInput = {
    update: XOR<UserUpdateWithoutNotificationRulesInput, UserUncheckedUpdateWithoutNotificationRulesInput>
    create: XOR<UserCreateWithoutNotificationRulesInput, UserUncheckedCreateWithoutNotificationRulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationRulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationRulesInput, UserUncheckedUpdateWithoutNotificationRulesInput>
  }

  export type UserUpdateWithoutNotificationRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    analyticsLogs?: AnalyticsAccessLogUpdateManyWithoutUserNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsLogs?: AnalyticsAccessLogUncheckedUpdateManyWithoutUserNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenderCreateWithoutTimelineEventsInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutTenderInput
    tenant?: TenantCreateNestedOneWithoutTendersInput
    insights?: TenderInsightsCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateWithoutTimelineEventsInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
    bidders?: BidderUncheckedCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsUncheckedCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderCreateOrConnectWithoutTimelineEventsInput = {
    where: TenderWhereUniqueInput
    create: XOR<TenderCreateWithoutTimelineEventsInput, TenderUncheckedCreateWithoutTimelineEventsInput>
  }

  export type TenderUpsertWithoutTimelineEventsInput = {
    update: XOR<TenderUpdateWithoutTimelineEventsInput, TenderUncheckedUpdateWithoutTimelineEventsInput>
    create: XOR<TenderCreateWithoutTimelineEventsInput, TenderUncheckedCreateWithoutTimelineEventsInput>
    where?: TenderWhereInput
  }

  export type TenderUpdateToOneWithWhereWithoutTimelineEventsInput = {
    where?: TenderWhereInput
    data: XOR<TenderUpdateWithoutTimelineEventsInput, TenderUncheckedUpdateWithoutTimelineEventsInput>
  }

  export type TenderUpdateWithoutTimelineEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutTenderNestedInput
    tenant?: TenantUpdateOneWithoutTendersNestedInput
    insights?: TenderInsightsUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateWithoutTimelineEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    bidders?: BidderUncheckedUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type TenderCreateWithoutInsightsInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutTenderInput
    tenant?: TenantCreateNestedOneWithoutTendersInput
    timelineEvents?: TenderTimelineEventCreateNestedManyWithoutTenderInput
    heatmap?: TenderHeatmapCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateWithoutInsightsInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
    bidders?: BidderUncheckedCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput
    heatmap?: TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderCreateOrConnectWithoutInsightsInput = {
    where: TenderWhereUniqueInput
    create: XOR<TenderCreateWithoutInsightsInput, TenderUncheckedCreateWithoutInsightsInput>
  }

  export type TenderUpsertWithoutInsightsInput = {
    update: XOR<TenderUpdateWithoutInsightsInput, TenderUncheckedUpdateWithoutInsightsInput>
    create: XOR<TenderCreateWithoutInsightsInput, TenderUncheckedCreateWithoutInsightsInput>
    where?: TenderWhereInput
  }

  export type TenderUpdateToOneWithWhereWithoutInsightsInput = {
    where?: TenderWhereInput
    data: XOR<TenderUpdateWithoutInsightsInput, TenderUncheckedUpdateWithoutInsightsInput>
  }

  export type TenderUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutTenderNestedInput
    tenant?: TenantUpdateOneWithoutTendersNestedInput
    timelineEvents?: TenderTimelineEventUpdateManyWithoutTenderNestedInput
    heatmap?: TenderHeatmapUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    bidders?: BidderUncheckedUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput
    heatmap?: TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type TenderCreateWithoutHeatmapInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutTenderInput
    tenant?: TenantCreateNestedOneWithoutTendersInput
    timelineEvents?: TenderTimelineEventCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateWithoutHeatmapInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
    bidders?: BidderUncheckedCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsUncheckedCreateNestedOneWithoutTenderInput
    complianceDashboard?: TenderComplianceDashboardUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderCreateOrConnectWithoutHeatmapInput = {
    where: TenderWhereUniqueInput
    create: XOR<TenderCreateWithoutHeatmapInput, TenderUncheckedCreateWithoutHeatmapInput>
  }

  export type TenderUpsertWithoutHeatmapInput = {
    update: XOR<TenderUpdateWithoutHeatmapInput, TenderUncheckedUpdateWithoutHeatmapInput>
    create: XOR<TenderCreateWithoutHeatmapInput, TenderUncheckedCreateWithoutHeatmapInput>
    where?: TenderWhereInput
  }

  export type TenderUpdateToOneWithWhereWithoutHeatmapInput = {
    where?: TenderWhereInput
    data: XOR<TenderUpdateWithoutHeatmapInput, TenderUncheckedUpdateWithoutHeatmapInput>
  }

  export type TenderUpdateWithoutHeatmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutTenderNestedInput
    tenant?: TenantUpdateOneWithoutTendersNestedInput
    timelineEvents?: TenderTimelineEventUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateWithoutHeatmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    bidders?: BidderUncheckedUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type BidderCreateWithoutIntelligenceInput = {
    id?: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeCreateNestedOneWithoutBidderInput
    tender: TenderCreateNestedOneWithoutBiddersInput
    technicalScores?: BidderCriterionScoreCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutBidderInput
    evidence?: EvidenceCreateNestedManyWithoutBidderInput
    riskProfile?: BidderRiskProfileCreateNestedOneWithoutBidderInput
  }

  export type BidderUncheckedCreateWithoutIntelligenceInput = {
    id?: string
    tenderId: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeUncheckedCreateNestedOneWithoutBidderInput
    technicalScores?: BidderCriterionScoreUncheckedCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutBidderInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutBidderInput
    riskProfile?: BidderRiskProfileUncheckedCreateNestedOneWithoutBidderInput
  }

  export type BidderCreateOrConnectWithoutIntelligenceInput = {
    where: BidderWhereUniqueInput
    create: XOR<BidderCreateWithoutIntelligenceInput, BidderUncheckedCreateWithoutIntelligenceInput>
  }

  export type BidderUpsertWithoutIntelligenceInput = {
    update: XOR<BidderUpdateWithoutIntelligenceInput, BidderUncheckedUpdateWithoutIntelligenceInput>
    create: XOR<BidderCreateWithoutIntelligenceInput, BidderUncheckedCreateWithoutIntelligenceInput>
    where?: BidderWhereInput
  }

  export type BidderUpdateToOneWithWhereWithoutIntelligenceInput = {
    where?: BidderWhereInput
    data: XOR<BidderUpdateWithoutIntelligenceInput, BidderUncheckedUpdateWithoutIntelligenceInput>
  }

  export type BidderUpdateWithoutIntelligenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUpdateOneWithoutBidderNestedInput
    tender?: TenderUpdateOneRequiredWithoutBiddersNestedInput
    technicalScores?: BidderCriterionScoreUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUpdateManyWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUpdateOneWithoutBidderNestedInput
  }

  export type BidderUncheckedUpdateWithoutIntelligenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUncheckedUpdateOneWithoutBidderNestedInput
    technicalScores?: BidderCriterionScoreUncheckedUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUncheckedUpdateOneWithoutBidderNestedInput
  }

  export type BidderCreateWithoutRiskProfileInput = {
    id?: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeCreateNestedOneWithoutBidderInput
    tender: TenderCreateNestedOneWithoutBiddersInput
    technicalScores?: BidderCriterionScoreCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutBidderInput
    evidence?: EvidenceCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceCreateNestedOneWithoutBidderInput
  }

  export type BidderUncheckedCreateWithoutRiskProfileInput = {
    id?: string
    tenderId: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bbbee?: BbbeeUncheckedCreateNestedOneWithoutBidderInput
    technicalScores?: BidderCriterionScoreUncheckedCreateNestedManyWithoutBidderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutBidderInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutBidderInput
    intelligence?: BidderIntelligenceUncheckedCreateNestedOneWithoutBidderInput
  }

  export type BidderCreateOrConnectWithoutRiskProfileInput = {
    where: BidderWhereUniqueInput
    create: XOR<BidderCreateWithoutRiskProfileInput, BidderUncheckedCreateWithoutRiskProfileInput>
  }

  export type BidderUpsertWithoutRiskProfileInput = {
    update: XOR<BidderUpdateWithoutRiskProfileInput, BidderUncheckedUpdateWithoutRiskProfileInput>
    create: XOR<BidderCreateWithoutRiskProfileInput, BidderUncheckedCreateWithoutRiskProfileInput>
    where?: BidderWhereInput
  }

  export type BidderUpdateToOneWithWhereWithoutRiskProfileInput = {
    where?: BidderWhereInput
    data: XOR<BidderUpdateWithoutRiskProfileInput, BidderUncheckedUpdateWithoutRiskProfileInput>
  }

  export type BidderUpdateWithoutRiskProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUpdateOneWithoutBidderNestedInput
    tender?: TenderUpdateOneRequiredWithoutBiddersNestedInput
    technicalScores?: BidderCriterionScoreUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUpdateOneWithoutBidderNestedInput
  }

  export type BidderUncheckedUpdateWithoutRiskProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUncheckedUpdateOneWithoutBidderNestedInput
    technicalScores?: BidderCriterionScoreUncheckedUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUncheckedUpdateOneWithoutBidderNestedInput
  }

  export type TenderCreateWithoutComplianceDashboardInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidders?: BidderCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentCreateNestedManyWithoutTenderInput
    tenant?: TenantCreateNestedOneWithoutTendersInput
    timelineEvents?: TenderTimelineEventCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapCreateNestedOneWithoutTenderInput
  }

  export type TenderUncheckedCreateWithoutComplianceDashboardInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantId?: string | null
    bidders?: BidderUncheckedCreateNestedManyWithoutTenderInput
    evaluationConfig?: EvaluationConfigUncheckedCreateNestedOneWithoutTenderInput
    documents?: EvaluationDocumentUncheckedCreateNestedManyWithoutTenderInput
    evaluationResults?: EvaluationResultUncheckedCreateNestedManyWithoutTenderInput
    signatures?: EvaluationSignatureUncheckedCreateNestedManyWithoutTenderInput
    scmAssignments?: ScmTenderAssignmentUncheckedCreateNestedManyWithoutTenderInput
    timelineEvents?: TenderTimelineEventUncheckedCreateNestedManyWithoutTenderInput
    insights?: TenderInsightsUncheckedCreateNestedOneWithoutTenderInput
    heatmap?: TenderHeatmapUncheckedCreateNestedOneWithoutTenderInput
  }

  export type TenderCreateOrConnectWithoutComplianceDashboardInput = {
    where: TenderWhereUniqueInput
    create: XOR<TenderCreateWithoutComplianceDashboardInput, TenderUncheckedCreateWithoutComplianceDashboardInput>
  }

  export type TenderUpsertWithoutComplianceDashboardInput = {
    update: XOR<TenderUpdateWithoutComplianceDashboardInput, TenderUncheckedUpdateWithoutComplianceDashboardInput>
    create: XOR<TenderCreateWithoutComplianceDashboardInput, TenderUncheckedCreateWithoutComplianceDashboardInput>
    where?: TenderWhereInput
  }

  export type TenderUpdateToOneWithWhereWithoutComplianceDashboardInput = {
    where?: TenderWhereInput
    data: XOR<TenderUpdateWithoutComplianceDashboardInput, TenderUncheckedUpdateWithoutComplianceDashboardInput>
  }

  export type TenderUpdateWithoutComplianceDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutTenderNestedInput
    tenant?: TenantUpdateOneWithoutTendersNestedInput
    timelineEvents?: TenderTimelineEventUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateWithoutComplianceDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    bidders?: BidderUncheckedUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type TenderCreateManyTenantInput = {
    id?: string
    number: string
    description: string
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    name?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
  }

  export type TenderUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidders?: BidderUncheckedUpdateManyWithoutTenderNestedInput
    evaluationConfig?: EvaluationConfigUncheckedUpdateOneWithoutTenderNestedInput
    documents?: EvaluationDocumentUncheckedUpdateManyWithoutTenderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutTenderNestedInput
    signatures?: EvaluationSignatureUncheckedUpdateManyWithoutTenderNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutTenderNestedInput
    timelineEvents?: TenderTimelineEventUncheckedUpdateManyWithoutTenderNestedInput
    insights?: TenderInsightsUncheckedUpdateOneWithoutTenderNestedInput
    heatmap?: TenderHeatmapUncheckedUpdateOneWithoutTenderNestedInput
    complianceDashboard?: TenderComplianceDashboardUncheckedUpdateOneWithoutTenderNestedInput
  }

  export type TenderUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    analyticsLogs?: AnalyticsAccessLogUpdateManyWithoutUserNestedInput
    scmAssignments?: ScmTenderAssignmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationRules?: NotificationRuleUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    analyticsLogs?: AnalyticsAccessLogUncheckedUpdateManyWithoutUserNestedInput
    scmAssignments?: ScmTenderAssignmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationRules?: NotificationRuleUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AnalyticsAccessLogCreateManyUserInput = {
    id?: string
    role: string
    endpoint: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ScmTenderAssignmentCreateManyUserInput = {
    id?: string
    tenderId: string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
  }

  export type NotificationRuleCreateManyOwnerInput = {
    id?: string
    trigger: string
    role: string
    enabled?: boolean
  }

  export type AnalyticsAccessLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAccessLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAccessLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScmTenderAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tender?: TenderUpdateOneRequiredWithoutScmAssignmentsNestedInput
  }

  export type ScmTenderAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScmTenderAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRuleUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationRuleUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationRuleUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BidderCreateManyTenderInput = {
    id?: string
    name: string
    price?: number | null
    disqualified?: boolean
    disqualificationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationDocumentCreateManyTenderInput = {
    id?: string
    runNumber: number
    fileUrl: string
    hash: string
    createdAt?: Date | string
  }

  export type EvaluationResultCreateManyTenderInput = {
    id?: string
    bidderId: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
  }

  export type EvaluationSignatureCreateManyTenderInput = {
    id?: string
    role: string
    name: string
    signature?: string | null
    comment?: string | null
    signedAt?: Date | string
  }

  export type ScmTenderAssignmentCreateManyTenderInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type TenderTimelineEventCreateManyTenderInput = {
    id?: string
    type: string
    label: string
    createdAt?: Date | string
  }

  export type BidderUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUpdateOneWithoutBidderNestedInput
    technicalScores?: BidderCriterionScoreUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUpdateOneWithoutBidderNestedInput
  }

  export type BidderUncheckedUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bbbee?: BbbeeUncheckedUpdateOneWithoutBidderNestedInput
    technicalScores?: BidderCriterionScoreUncheckedUpdateManyWithoutBidderNestedInput
    evaluationResults?: EvaluationResultUncheckedUpdateManyWithoutBidderNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutBidderNestedInput
    intelligence?: BidderIntelligenceUncheckedUpdateOneWithoutBidderNestedInput
    riskProfile?: BidderRiskProfileUncheckedUpdateOneWithoutBidderNestedInput
  }

  export type BidderUncheckedUpdateManyWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    disqualified?: BoolFieldUpdateOperationsInput | boolean
    disqualificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationDocumentUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    runNumber?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationDocumentUncheckedUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    runNumber?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationDocumentUncheckedUpdateManyWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    runNumber?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationResultUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    compliance?: ComplianceItemUpdateManyWithoutEvaluationResultNestedInput
    exceptions?: EvaluationExceptionUpdateManyWithoutEvaluationResultNestedInput
    bidder?: BidderUpdateOneRequiredWithoutEvaluationResultsNestedInput
    workflowLogs?: WorkflowLogUpdateManyWithoutEvaluationResultNestedInput
  }

  export type EvaluationResultUncheckedUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    compliance?: ComplianceItemUncheckedUpdateManyWithoutEvaluationResultNestedInput
    exceptions?: EvaluationExceptionUncheckedUpdateManyWithoutEvaluationResultNestedInput
    workflowLogs?: WorkflowLogUncheckedUpdateManyWithoutEvaluationResultNestedInput
  }

  export type EvaluationResultUncheckedUpdateManyWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderId?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
  }

  export type EvaluationSignatureUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationSignatureUncheckedUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationSignatureUncheckedUpdateManyWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScmTenderAssignmentUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutScmAssignmentsNestedInput
  }

  export type ScmTenderAssignmentUncheckedUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScmTenderAssignmentUncheckedUpdateManyWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenderTimelineEventUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenderTimelineEventUncheckedUpdateWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenderTimelineEventUncheckedUpdateManyWithoutTenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidderCriterionScoreCreateManyBidderInput = {
    id?: string
    criterionCode: string
    rawScore: number
    scaleMax: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationResultCreateManyBidderInput = {
    id?: string
    tenderId: string
    functionalityScore: number
    qualifies: boolean
    price: number
    priceScore: number
    bbbeeLevel?: number | null
    bbbeePoints: number
    totalScore: number
    riskScore?: number | null
    complianceRate?: number | null
    exceptionsCount?: number
    slaBreached?: boolean
    currentStage?: string | null
    createdAt?: Date | string
    hash: string
  }

  export type EvidenceCreateManyBidderInput = {
    id?: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidderCriterionScoreUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    criterionCode?: StringFieldUpdateOperationsInput | string
    rawScore?: FloatFieldUpdateOperationsInput | number
    scaleMax?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidderCriterionScoreUncheckedUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    criterionCode?: StringFieldUpdateOperationsInput | string
    rawScore?: FloatFieldUpdateOperationsInput | number
    scaleMax?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidderCriterionScoreUncheckedUpdateManyWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    criterionCode?: StringFieldUpdateOperationsInput | string
    rawScore?: FloatFieldUpdateOperationsInput | number
    scaleMax?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationResultUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    compliance?: ComplianceItemUpdateManyWithoutEvaluationResultNestedInput
    exceptions?: EvaluationExceptionUpdateManyWithoutEvaluationResultNestedInput
    tender?: TenderUpdateOneRequiredWithoutEvaluationResultsNestedInput
    workflowLogs?: WorkflowLogUpdateManyWithoutEvaluationResultNestedInput
  }

  export type EvaluationResultUncheckedUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
    compliance?: ComplianceItemUncheckedUpdateManyWithoutEvaluationResultNestedInput
    exceptions?: EvaluationExceptionUncheckedUpdateManyWithoutEvaluationResultNestedInput
    workflowLogs?: WorkflowLogUncheckedUpdateManyWithoutEvaluationResultNestedInput
  }

  export type EvaluationResultUncheckedUpdateManyWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenderId?: StringFieldUpdateOperationsInput | string
    functionalityScore?: FloatFieldUpdateOperationsInput | number
    qualifies?: BoolFieldUpdateOperationsInput | boolean
    price?: FloatFieldUpdateOperationsInput | number
    priceScore?: FloatFieldUpdateOperationsInput | number
    bbbeeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    bbbeePoints?: FloatFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    complianceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    exceptionsCount?: IntFieldUpdateOperationsInput | number
    slaBreached?: BoolFieldUpdateOperationsInput | boolean
    currentStage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hash?: StringFieldUpdateOperationsInput | string
  }

  export type EvidenceUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUncheckedUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUncheckedUpdateManyWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceItemCreateManyEvaluationResultInput = {
    id?: string
    ruleId: string
    compliant: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationExceptionCreateManyEvaluationResultInput = {
    id?: string
    type: string
    reason: string
    approved?: boolean | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowLogCreateManyEvaluationResultInput = {
    id?: string
    stage: string
    daysSpent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceItemUpdateWithoutEvaluationResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    compliant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rule?: ComplianceRuleUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ComplianceItemUncheckedUpdateWithoutEvaluationResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    compliant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceItemUncheckedUpdateManyWithoutEvaluationResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    compliant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationExceptionUpdateWithoutEvaluationResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationExceptionUncheckedUpdateWithoutEvaluationResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationExceptionUncheckedUpdateManyWithoutEvaluationResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowLogUpdateWithoutEvaluationResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    daysSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowLogUncheckedUpdateWithoutEvaluationResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    daysSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowLogUncheckedUpdateManyWithoutEvaluationResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    daysSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceRuleCreateManyCircularInput = {
    id?: string
    code: string
    label: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceRuleUpdateWithoutCircularInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ComplianceItemUpdateManyWithoutRuleNestedInput
  }

  export type ComplianceRuleUncheckedUpdateWithoutCircularInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ComplianceItemUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type ComplianceRuleUncheckedUpdateManyWithoutCircularInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceItemCreateManyRuleInput = {
    id?: string
    evaluationResultId: string
    compliant: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceItemUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    compliant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationResult?: EvaluationResultUpdateOneRequiredWithoutComplianceNestedInput
  }

  export type ComplianceItemUncheckedUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationResultId?: StringFieldUpdateOperationsInput | string
    compliant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceItemUncheckedUpdateManyWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationResultId?: StringFieldUpdateOperationsInput | string
    compliant?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenderCountOutputTypeDefaultArgs instead
     */
    export type TenderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BidderCountOutputTypeDefaultArgs instead
     */
    export type BidderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BidderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationResultCountOutputTypeDefaultArgs instead
     */
    export type EvaluationResultCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationResultCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CircularCountOutputTypeDefaultArgs instead
     */
    export type CircularCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CircularCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComplianceRuleCountOutputTypeDefaultArgs instead
     */
    export type ComplianceRuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComplianceRuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantBrandingDefaultArgs instead
     */
    export type TenantBrandingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantBrandingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScmTenderAssignmentDefaultArgs instead
     */
    export type ScmTenderAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScmTenderAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenderDefaultArgs instead
     */
    export type TenderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BidderDefaultArgs instead
     */
    export type BidderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BidderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BbbeeDefaultArgs instead
     */
    export type BbbeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BbbeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvidenceDefaultArgs instead
     */
    export type EvidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvidenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationConfigDefaultArgs instead
     */
    export type EvaluationConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BidderCriterionScoreDefaultArgs instead
     */
    export type BidderCriterionScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BidderCriterionScoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationResultDefaultArgs instead
     */
    export type EvaluationResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationResultDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowLogDefaultArgs instead
     */
    export type WorkflowLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CircularDefaultArgs instead
     */
    export type CircularArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CircularDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComplianceRuleDefaultArgs instead
     */
    export type ComplianceRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComplianceRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComplianceItemDefaultArgs instead
     */
    export type ComplianceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComplianceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationExceptionDefaultArgs instead
     */
    export type EvaluationExceptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationExceptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationSignatureDefaultArgs instead
     */
    export type EvaluationSignatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationSignatureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationDocumentDefaultArgs instead
     */
    export type EvaluationDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnalyticsAccessLogDefaultArgs instead
     */
    export type AnalyticsAccessLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnalyticsAccessLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationRuleDefaultArgs instead
     */
    export type NotificationRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenderTimelineEventDefaultArgs instead
     */
    export type TenderTimelineEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenderTimelineEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenderInsightsDefaultArgs instead
     */
    export type TenderInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenderInsightsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenderHeatmapDefaultArgs instead
     */
    export type TenderHeatmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenderHeatmapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BidderIntelligenceDefaultArgs instead
     */
    export type BidderIntelligenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BidderIntelligenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BidderRiskProfileDefaultArgs instead
     */
    export type BidderRiskProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BidderRiskProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenderComplianceDashboardDefaultArgs instead
     */
    export type TenderComplianceDashboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenderComplianceDashboardDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}